<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[AlexYoung's blog]]></title>
  <subtitle><![CDATA[当你的才华还撑不起你的野心时，你就应该静下心来学习。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://alexyyek.github.io/"/>
  <updated>2015-01-15T13:56:01.762Z</updated>
  <id>http://alexyyek.github.io/</id>
  
  <author>
    <name><![CDATA[AlexYoung]]></name>
    <email><![CDATA[alexyyek@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Java复用类]]></title>
    <link href="http://alexyyek.github.io/2015/01/14/Reusing/"/>
    <id>http://alexyyek.github.io/2015/01/14/Reusing/</id>
    <published>2015-01-14T12:48:39.000Z</published>
    <updated>2015-01-15T13:44:20.000Z</updated>
    <content type="html"><![CDATA[<p>多数时候我们不希望重新编写代码，而是希望使用已有的代码并加以更改或添加，类的复用为我们提供了这种机制，这也是面向对象语言重要的特点之一。复用类的主要方法有两种，组合与继承。继承和组合都是一种随思想渗透而下的编码方式，其根本目的都是为了复用类，减少重复代码。要实现一个类的复用，可以分为组合语法和继承语法。</p>
<h2 id="组合语法">组合语法</h2>
<blockquote>
<p>《Thinking in Java》：在新的类中产生现有类的对象。</p>
</blockquote>
<p>组合就是通过将一个对象置于一个新类中，将其作为新类的成员变量，组成类的一部分。由于新的类是由现有类的对象组成，所以称此方法为组合。</p>
<p>来看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">class WaterSource{</div><div class="line">	<span class="keyword">private</span> String s;</div><div class="line">	WaterSource(){</div><div class="line">		System.out.println(<span class="string">"WaterSource()"</span>);</div><div class="line">		s = <span class="string">"constructed"</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> String <span class="title">toString</span>(){</div><div class="line">		<span class="keyword">return</span> s;</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SprinklerSystem</span> </span>{</div><div class="line">	<span class="keyword">private</span> String name = <span class="string">"Alex"</span>;<span class="comment">//Initializing at point of definition</span></div><div class="line">	<span class="keyword">private</span> String sex;</div><div class="line">	<span class="keyword">private</span> WaterSource wSource;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">double</span> d;</div><div class="line">	<span class="keyword">public</span>  <span class="title">SprinklerSystem</span>(){</div><div class="line">		System.out.println(<span class="string">"In Sprinkler"</span>);</div><div class="line">		d = <span class="number">1.0</span>;    <span class="comment">//Initailizing in the constructor of class</span></div><div class="line">		wSource = <span class="keyword">new</span> WaterSource();</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> String <span class="title">toString</span>(){</div><div class="line">		<span class="keyword">if</span> (sex == <span class="keyword">null</span>) { sex = <span class="string">"male"</span>; }<span class="comment">//Delayed initialization</span></div><div class="line">		<span class="keyword">return</span> </div><div class="line">			<span class="string">"string"</span> + <span class="string">"="</span> + name + <span class="string">" "</span> +</div><div class="line">			<span class="string">"sex"</span> + <span class="string">"="</span> + sex + <span class="string">" "</span> +</div><div class="line">			<span class="string">"double"</span> + <span class="string">"="</span> + d + <span class="string">" "</span> +</div><div class="line">			<span class="string">"WaterSource"</span> + <span class="string">"="</span> + wSource;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		SprinklerSystem sprinklers = <span class="keyword">new</span> SprinklerSystem();</div><div class="line">		System.out.println(sprinklers);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>我们可以看到，类SprinklerSystem中直接产生现有的类WaterSource，以此可以使用关于WaterSource的各种方法。</p>
<p>但注意这里两个类中都有一个很特殊的方法：toString()。</p>
<p>当编译器需要一个String而你只有一个对象wSource时，由于只能将两个String对象相加，因此编译器会调用toString方法，将wSource转化为一个String。当然如果没有写toString方法，这里会打印对象的地址。</p>
<p>打印输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">In Sprinkler</div><div class="line">WaterSource()</div><div class="line">string=Alex sex=male <span class="keyword">double</span>=<span class="number">1.0</span> WaterSource=constructed</div></pre></td></tr></table></figure>

<p>此外，编译器并不是简单的为每一个引用都创建默认对象，避免不必要的负担。如果想初始化这些引用，可以在例子中的这些位置进行：</p>
<ol>
<li>定义对象的地方</li>
<li>在类的构造器中</li>
<li>在正要使用这些对象之前</li>
<li>使用实例初始化</li>
</ol>
<p>由此可以看出：组合是在新类产生现有类的对象，组合出功能给更强的新类。</p>
<p><strong>如果将继承比作Is-A的关系（什么是什么..），组合则是Has-A(什么有什么)的关系。</strong></p>
<h2 id="继承">继承</h2>
<blockquote>
<p>《Thinking in Java》：通过现有类的类型创建新类，采用现有类的形式并在其中添加新代码。</p>
</blockquote>
<p>当创建一个类时，总是在继承，因此除非已明确指出要从其他类中继承，否则就是隐式的从Java的标准根类Object进行继承。继承通过<code>extends</code>关键字自动获得基类中的所有域和方法。在看下面的例子前建议先理解<code>super</code>关键字的 → <a href="http://docs.oracle.com/javase/tutorial/java/IandI/super.html" target="_blank" rel="external">用法</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">class Base {</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s1 = prt(<span class="string">"s1 initialized."</span>, <span class="number">11</span>);</div><div class="line">	<span class="keyword">int</span> i1 = prt(<span class="string">"i1 initialized."</span>, <span class="number">12</span>);</div><div class="line"></div><div class="line">	Base() {</div><div class="line">		System.out.println(<span class="string">"Base construcor"</span>);</div><div class="line">		System.out.println(<span class="string">"s1 = "</span> + s1 + <span class="string">" ,i1 = "</span> + i1);</div><div class="line">		draw();<span class="comment">// （d）</span></div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">void</span> draw() {</div><div class="line">		System.out.println(<span class="string">"base.draw：s1 = "</span> + s1 + <span class="string">" ,i1 = "</span> + i1);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> prt(String s, <span class="keyword">int</span> num) {</div><div class="line">		System.out.println(s);</div><div class="line">		<span class="keyword">return</span> num;</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class Cleanser extends Base {</div><div class="line">	<span class="keyword">private</span> String s = <span class="string">"Cleaner"</span>;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s2 = prt(<span class="string">"s2 initialized."</span>, <span class="number">21</span>);</div><div class="line">	<span class="keyword">int</span> i2 = prt(<span class="string">"i2 initialized."</span>, <span class="number">22</span>);</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">Cleanser</span>() {</div><div class="line">		System.out.println(<span class="string">"Cleanser constructor"</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">Cleanser</span>(<span class="keyword">int</span> i) {</div><div class="line">		System.out.println(<span class="string">"Cleanser constructor init i:"</span> + i);</div><div class="line">		System.out.println(<span class="string">"s2 = "</span> + s2 + <span class="string">" ,i2 = "</span> + i2);</div><div class="line">		draw();</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span>(String a) {</div><div class="line">		s += a;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dilute</span>() {</div><div class="line">		append(<span class="string">" dilute()"</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrub</span>() {</div><div class="line">		append(<span class="string">" scrub()"</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">void</span> draw(){</div><div class="line">        System.out.println(<span class="string">"Cleanser.draw：s2 = "</span> + s2 + <span class="string">" ,i2 = "</span> + i2);</div><div class="line">    }</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">		<span class="keyword">return</span> s;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		Cleanser x = <span class="keyword">new</span> Cleanser();</div><div class="line">		x.dilute();</div><div class="line">		x.scrub();</div><div class="line">		System.out.println(x);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Detergent</span> <span class="keyword">extends</span> <span class="title">Cleanser</span> </span>{</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s3 = prt(<span class="string">"s3 initialized."</span>, <span class="number">31</span>);</div><div class="line">    <span class="keyword">int</span> i3 = prt(<span class="string">"i3 initialized"</span>, <span class="number">31</span>);</div><div class="line">    </div><div class="line">	<span class="keyword">public</span> <span class="title">Detergent</span>() {</div><div class="line">		<span class="keyword">super</span>(<span class="number">1024</span>);</div><div class="line">		System.out.println(<span class="string">"Detergent construcor"</span>);</div><div class="line">		System.out.println(<span class="string">"s3 = "</span> + s3 + <span class="string">" ,i3 = "</span> + i3);</div><div class="line">		draw();</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrub</span>() {</div><div class="line">		append(<span class="string">" Detergent.scrub()"</span>);</div><div class="line">		<span class="keyword">super</span>.scrub();</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foam</span>() {</div><div class="line">		append(<span class="string">" foam()"</span>);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">void</span> draw(){</div><div class="line">        System.out.println(<span class="string">"Detergent.draw：s3 = "</span> + s3 + <span class="string">" ,i3 = "</span> + i3);</div><div class="line">    }</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">		Detergent detergent = <span class="keyword">new</span> Detergent();</div><div class="line">		detergent.dilute();</div><div class="line">		detergent.scrub();</div><div class="line">		detergent.foam();</div><div class="line">		System.out.println(detergent);</div><div class="line">		System.out.println(<span class="string">"Test base class:"</span>);</div><div class="line">		Cleanser.main(args);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这个例子糅合了继承中许多重要的点，我们首先分析一下基本框架，程序包含三个类，Base类、继承Base的Cleanser类，继承Cleanser的Detergent类。类中包含了静态成员，非静态成员，以及类内部的方法。下面来梳理程序流程。</p>
<h3 id="继承的初始化">继承的初始化</h3>
<p>$1$. 装载Detergent.class文件<br>$2$. 发现Detergent有关键字extends，装载Cleanser.class文件<br>$3$. 发现Cleanser有关键字extends，装载Base.class文件<br>$4$. 初始化Base class中的静态成员。初始化Cleanser class中的静态成员。初始化Detergent class中的静态成员。<strong>如果Detergent的main函数为空，到这里已经初始化完毕。</strong>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">s1 initialized.</div><div class="line">s2 initialized.</div><div class="line">s3 initialized.</div></pre></td></tr></table></figure>

<blockquote>
<p>《Thinking in Java》：继承并不只是复制基类的接口。当创建了一个导出类的对象时，该对象包含了一个基类的子对象。</p>
</blockquote>
<p>$5$. 为detergent对象分配存储空间，并把存储空间初始化为0。在Detergent的构造器中调用super(1024)，试图产生一个Cleanser class实例。<br>$6$. 为Cleanser对象分配存储空间。由于Cleanser类继承自Base类，会在Cleanser类的构造器中调用Base的无参构造函数。<br>$7$. 产生一个Base class实例。先初始化成员变量，再调用构造函数。回到Cleanser类执行同样步骤，Detergent类亦如此。</p>
<p>至创建detergent对象结束后，初始化的输出结果如下，其中要注意几点：</p>
<ul>
<li>继承中的构建过程是“向外”扩散的，先初始化基类，后初始化导出类。</li>
<li>注意Detergent类构造函数中<code>super</code>的使用，super用于导出类的构造函数，可以调用基类的构造方法。如果基类<strong>没有默认构造器或者带有参数</strong>，则需要显式构造，构造方法则是上面提到过的super，当然super要放在构造函数内第一行。</li>
<li>注意Base类和Cleanser类构造函数中的draw()方法，并没有按想象中直接调用类内部的draw()，而是统一调用了子类Detergent中的draw()方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">i1 initialized.</div><div class="line">Base construcor</div><div class="line">s1 = <span class="number">11</span> ,i1 = <span class="number">12</span></div><div class="line">Detergent.draw：s3 = <span class="number">31</span> ,i3 = <span class="number">0</span></div><div class="line">i2 initialized.</div><div class="line">Cleanser constructor init i:<span class="number">1111</span></div><div class="line">s2 = <span class="number">21</span> ,i2 = <span class="number">22</span></div><div class="line">Detergent.draw：s3 = <span class="number">31</span> ,i3 = <span class="number">0</span></div><div class="line">i3 initialized</div><div class="line">Detergent construcor</div><div class="line">s3 = <span class="number">31</span> ,i3 = <span class="number">31</span></div><div class="line">Detergent.draw：s3 = <span class="number">31</span> ,i3 = <span class="number">31</span></div></pre></td></tr></table></figure>

<h3 id="继承语法">继承语法</h3>
<p>在创建完detergent对象后，detergent对象开始调用不同方法，在Cleanser的接口中有一组方法：append()，dilute()，scrub()，draw()和toString()。由于Detergent是由关键字<code>extends</code>从Cleanser导出的，所以它可以再其接口中自动获得这些方法，因此可以将继承视作是对类的复用。</p>
<p>在Detergent中，我们复用了部分Cleanser中的方法，但改写了其中的scrub()，如果需要在新版本中调用从基类继承而来的方法，可以利用<code>super</code>关键字，正如开头链接中<code>super</code>的第一种使用方法：Accessing Superclass Members。</p>
<p>当然在继承中并不一定非要使用基类的方法，可以在导出类中添加新的方法，如Detergent类中新增的foam()方法。后续输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Cleaner dilute() Detergent.scrub() scrub() foam()</div><div class="line">Test base class:</div><div class="line">i1 initialized.</div><div class="line">Base constructor</div><div class="line">s1 = <span class="number">11</span> ,i1 = <span class="number">12</span></div><div class="line">Cleanser.draw：s2 = <span class="number">21</span> ,i2 = <span class="number">0</span></div><div class="line">i2 initialized.</div><div class="line">Cleanser constructor</div><div class="line">Cleaner dilute() scrub()</div></pre></td></tr></table></figure>

<h3 id="清理">清理</h3>
<p>清理过程是先执行导出类的清理代码，再执行基类的清除代码。这就像一棵大树，生长的时候要从根向叶子生长，但剪除的时候要从叶子向根剪除。如果一下子去掉了根，那么叶子你也就都找不到了。这种清理与以前说过的finalize方法不同，如果要执行这种清理工作，最好还是自己编写清理代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Shape {</div><div class="line">    Shape(<span class="keyword">int</span> i) { print(<span class="string">"Shape constructor"</span>); }</div><div class="line">    <span class="keyword">void</span> dispose() { print(<span class="string">"Shape dispose"</span>); }</div><div class="line">}</div><div class="line">class Circle extends Shape {</div><div class="line">    Circle(<span class="keyword">int</span> i) {</div><div class="line">        <span class="keyword">super</span>(i);</div><div class="line">        print(<span class="string">"Drawing Circle"</span>);</div><div class="line">    }</div><div class="line">    <span class="keyword">void</span> dispose() {</div><div class="line">        print(<span class="string">"Erasing Circle"</span>);</div><div class="line">        <span class="keyword">super</span>.dispose();</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="名称屏蔽">名称屏蔽</h3>
<p>如果Java的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并不会屏蔽其在基类中的任何版本（与C++不同）。Java SE5新增了<code>@Override</code>注释，它并不是关键字，但是可以当做关键字使用。当你想要<strong><code>覆写</code></strong>某个方法时，可以选择添加这个注解，防止你不留心重载了该方法。通过下面表格区分重载和覆写：<br><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">范围</th>
<th style="text-align:center">重载（Overload）</th>
<th style="text-align:center">覆写（Override）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">范围</td>
<td style="text-align:center">类内定义方法的不同版本</td>
<td style="text-align:center">子类为满足需要重复定义某个方法的不同实现</td>
</tr>
<tr>
<td style="text-align:center">方法名</td>
<td style="text-align:center">相同</td>
<td style="text-align:center">相同</td>
</tr>
<tr>
<td style="text-align:center">参数列表</td>
<td style="text-align:center">必须不同</td>
<td style="text-align:center">相同</td>
</tr>
<tr>
<td style="text-align:center">返回值类型</td>
<td style="text-align:center">可以不同</td>
<td style="text-align:center">相同</td>
</tr>
</tbody>
</table>
<h2 id="组合与继承的选择">组合与继承的选择</h2>
<p>组合与继承都允许在新的类中放置子对象，组合是显示的这样做，而继承是隐式地做。</p>
<p>组合技术通常用于想在新类中使用现有类的功能，而非它的接口。即在新类中嵌入某个对象，让其实现所需要的功能，但新类的用户只能看到为新类定义的接口，而非所有嵌入对象的接口。为取得此效果，<strong>需要在新类中嵌入一个现有类的private对象</strong>。</p>
<p>继承常用于你在使用一个通用类时，为了某种特殊需求而将其特殊化，开发一个它的特殊版本。就像开头说的：<strong>如果将继承比作Is-A的关系（什么是什么..），组合则是Has-A(什么有什么)的关系。</strong></p>
<h2 id="Protected关键字">Protected关键字</h2>
<p>讲完了继承，关键字protected也终于有了意义。在实际项目中，经常会想要境某些事物尽可能<strong>对这个世界隐藏起来，但仍然允许导出类或者其他位于同一个包内的类来说，它却是可以访问的</strong>。（protected也提供了包内访问权限）</p>
<p>尽管可以创建protected域，但是最好的方式还是将域保持为private；你应当一直保留<strong>更改底层实现的权利。</strong>然后通过protected方法来控制类的继承者的访问权限。</p>
<blockquote>
<p>The protected modifier specifies that the member can only be accessed within its own package (as with package-private) and, in addition, by a subclass of its class in another package.</p>
</blockquote>
<h2 id="向上转型">向上转型</h2>
<blockquote>
<p>《Thinking in Java》：The most important aspect of <strong>inheritance</strong> is not that it provides methods for the new class.It’s the <strong>relationship</strong> expressed between the new class and the base class. </p>
</blockquote>
<p>Wind类继承了基类Instrument，并创建了Wind对象，但是Instrument类仍可以使用Wind对象，程序代码可以对Instrument和它所有的导出类起作用。由于继承可以确保基类中所有的方法在导出类中也同样有效，所以能够向基类发送的所有信息同样也可以向导出类发送。这种将Wind引用转换为Instrument引用的动作，称为向上转型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Instrument {</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span>() {}</div><div class="line">    <span class="keyword">static</span> <span class="keyword">void</span> tune(Instrument i) {</div><div class="line">    i.play(); }</div><div class="line">}</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wind</span> <span class="keyword">extends</span> <span class="title">Instrument</span> </span>{</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Wind flute = <span class="keyword">new</span> Wind();</div><div class="line">        Instrument.tune(flute); <span class="comment">// Upcasting</span></div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>由于向上转型是从一个较专用类型向较通用类型转换，所以总是很安全的。在向上转型中，类接口中唯一可能发生的事情是丢失方法，而不是获取它们。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class Game{</div><div class="line">	Game(<span class="keyword">int</span> i){</div><div class="line">		System.out.println(<span class="string">"Game constructor"</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class BoardGame extends Game{</div><div class="line">	BoardGame(<span class="keyword">int</span> i){</div><div class="line">		<span class="keyword">super</span>(i);</div><div class="line">		System.out.println(<span class="string">"BoardGame constructor"</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chess</span> <span class="keyword">extends</span> <span class="title">BoardGame</span></span>{</div><div class="line">	Chess(){</div><div class="line">		<span class="keyword">super</span>(<span class="number">250</span>);</div><div class="line">		System.out.println(<span class="string">"Chess constructor"</span>);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span>(){};</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		Game game = <span class="keyword">new</span> Chess();    <span class="comment">//向上转型</span></div><div class="line">		<span class="comment">/* Error </span></div><div class="line">		 * The method f() is undefined for the type Game</div><div class="line">		   game.f(); */</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>如果运行Chess，输出的是Game constructor 还是三个类全部初始化？</p>
<p>答案是全部初始化，即创建了子类Chess对象。这是因为game实际上指向的是一个子类对象。当然，你不用担心，Java虚拟机会自动准确地识别出究竟该调用哪个具体的方法。不过，由于向上转型，game对象会遗失和父类不同的方法，例如f()。</p>
<p>向上转型可以简化程序代码，例如这里的Monitor类 → <a href="http://blog.csdn.net/shanghui815/article/details/6088588" target="_blank" rel="external">栗子</a></p>
<h2 id="final关键字">final关键字</h2>
<p>为了设计或效率这两个截然不同的目的，我们可能会使用到final关键字。</p>
<h3 id="final_data">final data</h3>
<p>相比于C/C++中的const关键字，Java使用final来声明数据。对于基本类型，final保证数值恒定不变；用于对象引用，则保证引用恒定不变，也就是说无法再把该引用指向另一个对象。通常声明一个常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALUE = <span class="number">10</span>;</div></pre></td></tr></table></figure>

<p>定义为static强调只有一份，定义为final说明它是一个常量。</p>
<ul>
<li>final声明的变量，意味着无法将其引用对象再次指向另一个新的对象，而不是无法改变它的值。</li>
<li>带有恒等初始值的final static基本类型全用大写字母命名。</li>
<li>final成员变量必须在声明的时候初始化，或在构造器中初始化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">class Vincent{</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">public</span> <span class="title">Vincent</span>(<span class="keyword">int</span> i){</div><div class="line">		<span class="keyword">this</span>.i = i;</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalData</span></span>{</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> String id;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">25</span>);</div><div class="line">	FinalData(String id){</div><div class="line">		<span class="keyword">this</span>.id = id;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> first = <span class="number">1024</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SECOND = <span class="number">2048</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THIRD = <span class="number">3072</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Vincent v1 = <span class="keyword">new</span> Vincent(<span class="number">1024</span>);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Vincent v2 = <span class="keyword">new</span> Vincent(<span class="number">2048</span>);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Vincent V3 = <span class="keyword">new</span> Vincent(<span class="number">3072</span>);</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> rand = random.nextInt(<span class="number">100</span>);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RAND = random.nextInt(<span class="number">100</span>); </div><div class="line">	</div><div class="line">	<span class="keyword">public</span> String <span class="title">toString</span>(){</div><div class="line">		<span class="keyword">return</span> id + <span class="string">"\t"</span> + rand + <span class="string">"\t"</span> + RAND; </div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		FinalData fData = <span class="keyword">new</span> FinalData(<span class="string">"first trial"</span>);</div><div class="line">		</div><div class="line">		<span class="comment">/*	Error: Can't change value</span></div><div class="line">		 * 	fData.first++;</div><div class="line">		 */</div><div class="line">		</div><div class="line">		fData.v1.i++;</div><div class="line">		fData.v2.i++;</div><div class="line">		</div><div class="line">		fData.v1 = <span class="keyword">new</span> Vincent(<span class="number">1</span>); <span class="comment">//withour final</span></div><div class="line">		</div><div class="line">		<span class="comment">/* Error: Can't change reference </span></div><div class="line">		 * fData.v2 = new Value(2);</div><div class="line">		 * fData.V3 = new Value(3);</div><div class="line">		 */</div><div class="line">		</div><div class="line">		System.out.println(fData);	<span class="comment">//first trial	28	81</span></div><div class="line">		FinalData fData2 = <span class="keyword">new</span> FinalData(<span class="string">"second trial"</span>);</div><div class="line">		System.out.println(fData2); <span class="comment">//second trial	47	81</span></div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li>对final修饰的基本类型视为常量，不能再修改（如first、SECOND和THIRD）</li>
<li>final修饰的引用对象，可以改变值，如<code>fData.v2.i++;</code>，但不可修改指向对象。</li>
<li>不能因为数据是final的就认为在编译时已知了它的值，如rand和RAND，用static修饰的RAND在最开始便初始化完毕，故两次值不变。</li>
</ol>
<h3 id="final_method">final method</h3>
<p>现在使用final方法的原因只有一个：把方法锁定，以防止任何继承类修改他的含义，想要确保继承中使方法行为<strong>保持不变</strong>，并且<strong>不会覆盖</strong>。</p>
<ul>
<li>对于实例方法，final意味着在子类<strong>不能重写</strong>该方法，但<strong>可以重载</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Father{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span>(){};</div><div class="line">}</div><div class="line">class Child extends Father{</div><div class="line">    <span class="comment">/* Error: Cannot override the final method from Father</span></div><div class="line">     * public final void f(){};</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f</span>(<span class="keyword">int</span> i){};</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>对于静态方法final的含义为，子类中<strong>不能隐藏（覆盖或重写）</strong>这个方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class Father{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span>(){};</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f2</span>(){};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span></span>{</div><div class="line">	<span class="comment">/* Error: This instance method cannot override the static method from Father</span></div><div class="line">	 * public void f(){System.out.println("Alex");}</div><div class="line">	 */</div><div class="line">	</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span>(<span class="keyword">int</span> i){System.out.println(<span class="string">"Alex"</span>);}</div><div class="line">    </div><div class="line">    <span class="comment">/* Error: Cannot override the final method from Father</span></div><div class="line">     * public static void f2(){};</div><div class="line">     */</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">f2</span>(<span class="keyword">int</span> i){};</div><div class="line">}</div></pre></td></tr></table></figure>

<p>静态方法是可以继承的，但是在子类中即使可以定义一个与父类方法签名相同的方法覆盖掉父类的方法，但是这并不是重写。重写应该在多态性上有所体现，但是覆盖父类静态方法并不会体现<a href="http://segmentfault.com/blog/zhaobing/1190000000669897" target="_blank" rel="external">多态性</a>。</p>
<h3 id="final_classes">final classes</h3>
<p>当将某个类整体定义为final时，就表明你不打算继承该类，而且也不允许别人这么做。换句话说，你对该类的设计用不需要做出任何变动，或者是出于安全考虑，你不希望它有子类。</p>
<p>由于final类禁止继承，所以final类中所有的方法都隐式指定为final的，因为无法覆盖他们。</p>
]]></content>
    <summary type="html">
    <![CDATA[One of the most compelling features about Java is code reuse. But to be revolutionary, you’ve got to be able to do a lot more than copy code and change it.]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java访问权限控制]]></title>
    <link href="http://alexyyek.github.io/2015/01/12/Inherit/"/>
    <id>http://alexyyek.github.io/2015/01/12/Inherit/</id>
    <published>2015-01-12T14:47:08.000Z</published>
    <updated>2015-01-12T14:50:51.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>《Thinking in Java》：把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作封装。</p>
</blockquote>
<p>在Thinking in Java这本书中，并没有用封装这个词来为这一章命名，而是选择访问控制权这个更接近本质的词。</p>
<p>访问控制权主要解决两个问题：</p>
<ol>
<li>设定客户端程序猿可以使用和不可用使用的界限。<br>利用这个界限可以在结构中建立自己的内部机制，而不用担心客户端程序猿将内部机制当作可以调用的接口。</li>
<li>接口和具体实现的分离。<br>客户端程序员只是调用你的接口，所以你可以任意修改所有访问权限控制不是public的代码，而不会破坏客户端的代码。</li>
</ol>
<p>在Java中，提供了四种访问权限控制：default（包访问权限），public，private 以及 protected，具体权限范围相信大家都比较熟悉，下面主要分享一些更深入的观点。</p>
<h2 id="类访问权限">类访问权限</h2>
<p>类中的访问权限只包含两种：public和包访问权限，为什么没有private和protect呢？</p>
<p>public就是说这个类可以随便外界使用，包访问权限就是辅助类的权限了，只允许同一个包内的别的类使用该辅助类。  </p>
<p>如果是要添加private控制一个类的权限，那么想表达什么意思呢？可能会说，我在辅助类的前面添加上一个Private，就想控制：仅仅允许同一个java文件内的主类使用这个类。有没有这个需求呢？肯定有，因为如果这个辅助类仅仅属于这一个主类，那么我就可以方便修改了，而不用管别的类是否在使用。 但是Java为什么没有设定这个private权限？ </p>
<p>答案是：Java提供了一个更容易理解的方式－－内部类实现了这个需求。用private修饰一个辅助类，其实是不符合private的意思的。所以用内部类来表示显的更自然。</p>
<p>那类为什么没有protected呢？其实可以发现并没有这个需求。 别的类要想继承我这个类，必须先能看到我这个类。如果你看不到我这个类，那还继承个毛线。</p>
<p>假设这样一种情况：不希望其他任何人对该类拥有访问权限，可以把所有的构造器都指定为private，从而阻止任何人创建该类的对象。该如何的实现呢？看下面一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">class Alex1 {</div><div class="line">	<span class="keyword">private</span> <span class="title">Alex1</span>() {</div><div class="line">	};</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Alex1 <span class="title">makeAlex1</span>() {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Alex1();</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class Alex2 {</div><div class="line">	<span class="keyword">private</span> <span class="title">Alex2</span>() {</div><div class="line">	};</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Alex2 alex = <span class="keyword">new</span> Alex2();</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Alex2 <span class="title">access</span>() {</div><div class="line">		<span class="keyword">return</span> alex;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span>() {</div><div class="line">	};</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Geek</span> </span>{</div><div class="line">	<span class="keyword">void</span> testPrivate() {</div><div class="line">		<span class="comment">/* Error : The constructor Alex1() is not visible </span></div><div class="line">		 * Alex1 alex1 = new Alex1();</div><div class="line">		 */</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">void</span> testStatic() {</div><div class="line">		Alex1 alex1 = Alex1.makeAlex1();</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">void</span> testSingleton() {</div><div class="line">		Alex2.access().f();</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>Alex1类和Alex2类展示了如何通过将所有的构造器指定为private来阻止直接创建某个类的实例。</p>
<p>但是现在别人该如何使用这个类呢？</p>
<p>上面的例子给出了两种选择：</p>
<ol>
<li>在Alex1中，创建一个static方法，该方法创建一个新的Alex1对象并返回一个对它的引用。如果想要在返回引用之前在Alex1上做一些额外的工作，或是如果想要记录到底创建了多少个Alex1对象，这种做法将会大有裨益。</li>
<li>Alex2用到了所谓的设计模式，这种特定的模式被称为singleton（单例），这是因为你始终只能创建它的一个对象。Alex2类的对象时作为Alex2的一个static private成员而创建的，所以有且仅有一个，而且除非调用public方法access()，否则是无法访问到它的。</li>
</ol>
<h2 id="域/变量访问权限">域/变量访问权限</h2>
<p>访问权限请看下面的表格，具体<a href="http://www.cnblogs.com/dolphin0520/p/3734915.html" target="_blank" rel="external">事例</a>不再赘述。<br><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">范围</th>
<th style="text-align:center">private</th>
<th style="text-align:center">default</th>
<th style="text-align:center">protect</th>
<th style="text-align:center">public</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">在同一包的同一类</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">同一包的不同类</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">不同包的子类</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">不同包的非子类</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[把数据和方法包装进类中，以及具体实现的隐藏，常共同被称作封装。]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[编译与解释]]></title>
    <link href="http://alexyyek.github.io/2015/01/08/CompileAndInterpreter/"/>
    <id>http://alexyyek.github.io/2015/01/08/CompileAndInterpreter/</id>
    <published>2015-01-08T14:20:56.000Z</published>
    <updated>2015-01-08T14:40:07.000Z</updated>
    <content type="html"><![CDATA[<p>很多文章和书籍习惯将高级编程语言分成编译型语言和解释型语言，其实这是有误导成分的，如果你从编程语言底层分析其运行过程，会发现编译与解释往往并不是独立存在的，下面分析理解其内部机理。</p>
<h2 id="解析器与解释器">解析器与解释器</h2>
<p>首先来明确两个基本概念：解析器是<a href="http://en.wikipedia.org/wiki/Parsing" target="_blank" rel="external">parser</a>，而解释器是<a href="http://en.wikipedia.org/wiki/Interpreter_computing" target="_blank" rel="external">interpreter</a>。两者不是同一样东西。</p>
<p><code>解析器</code>是编译器/解释器的重要组成部分，也可以用在IDE之类的地方；其主要作用是进行语法分析，提取出句子的结构。</p>
<p>广义来说输入一般是程序的源码，输出一般是<a href="http://en.wikipedia.org/wiki/Parse_tree" target="_blank" rel="external">语法树</a>（syntax tree，也叫parse tree等）或<a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="external">抽象语法树</a>（abstract syntax tree，AST）。</p>
<p>广义的解析器里一般包含：</p>
<ol>
<li>扫描器（scanner，也叫tokenizer或者lexical analyzer，词法分析器）。扫描器的输入一般是文本，经过词法分析，输出是将文本切割为单词的流。</li>
<li>狭义的解析器（parser，也叫syntax analyzer，语法分析器）。狭义的解析器输入是单词的流，经过语法分析，输出是语法树或者精简过的AST。</li>
</ol>
<p>来看一段源码：$i = a + b * c$</p>
<p><center>　<img src="http://alexyoung.qiniudn.com/parser.png" alt=""> <center></center></center></p>
<p>其中词法分析由扫描器完成，语法分析由狭义的解析器完成。 </p>
<p><code>解释器</code>则是实现程序执行的一种实现方式，与<code>编译器</code>相对。它直接实现程序源码的语义，输入是程序源码，输出则是执行源码得到的计算结果；编译器的输入与解释器相同，而输出是用别的语言实现了输入源码的语义的程序。通常编译器的输入语言比输出语言高级，但不一定；也有输入输出是同种语言的情况，此时编译器很可能主要用于优化代码。 </p>
<p>把同样的源码分别输入到编译器与解释器中，得到的输出不同： </p>
<p><center> <img src="http://alexyoung.qiniudn.com/parser1.png" alt=""> <center></center></center></p>
<p>值得留意的是，编译器生成出来的代码执行后的结果应该跟解释器输出的结果一样——它们都应该实现源码所指定的语义。</p>
<h2 id="“编译器”与“编译型语言”">“编译器”与“编译型语言”</h2>
<p>一种高级编程语言，从源代码开始，一直到被执行生成相应的动作，大约经历了这几个步骤：</p>
<p><center> 源代码 ====&gt; 中间表示形式（e.g obj） ====&gt; 基本操作序列 ====&gt; 生成最终动作 <center></center></center></p>
<p>编译型语言的代表是C，源代码被编译之后生成中间文件（.o和.obj），然后用链接器和汇编器生成机器码，也就是一系列基本操作的序列，机器码最后被执行生成最终动作。编译生成了目标文件，而这个目标文件是针对特定的 CPU 体系的，为 ARM 生成的目标文件，不能被用于 MIPS 的 CPU。这段代码在编译过程中就已经被翻译成了目标 CPU 指令，所以，如果这个程序需要在另外一种 CPU 上面运行，这个代码就必须重新编译。</p>
<p>解释型的语言以Ruby为例，也经历了这些步骤，不同的是，C语言会把那些从源代码“变”来的基本操作序列（保存）起来，而Ruby直接将这些生成的基本操作序列（Ruby虚拟机）指令丢给Ruby虚拟机执行然后产生动作了。即解释型语言同样也可能存在某种编译过程，但他们编译生成的通常是一种『平台无关』的中间代码，这种代码一般不是针对特定的 CPU 平台，他们是在运行过程中才被翻译成目标 CPU 指令的，因而，在 ARM CPU 上能执行，换到 MIPS 也能执行，换到 X86 也能执行，不需要重新对源代码进行编译。</p>
<p>所以我们看到的现象是，编译型语言要先编译再运行，而解释性语言直接“运行”源代码。</p>
<p>换个角度说，采用编译和解释方式实现虚拟机最大的区别就在于是否存下目标代码：编译的话会把输入的源程序以某种单位（例如基本块/函数/方法/trace等）翻译生成为目标代码，并存下来（无论是存在内存中还是磁盘上，无所谓），后续执行可以复用之；解释的话则是把源程序中的指令逐条解释，不生成也不存下目标代码，后续执行没有多少可复用的信息。</p>
<h2 id="“解释器”与“解释型语言”">“解释器”与“解释型语言”</h2>
<p>很多资料会说，Python、Ruby、JavaScript都是“解释型语言”，是通过解释器来实现的。这么说其实很容易引起误解：<strong>语言一般只会定义其抽象语义，而不会强制性要求采用某种实现方式</strong>。</p>
<p>例如说C一般被认为是“编译型语言”，但C的解释器也是存在的，例如<a href="http://www.softintegration.com/" target="_blank" rel="external">Ch</a>。同样，C++也有解释器版本的实现，例如<a href="https://root.cern.ch/drupal/content/cint" target="_blank" rel="external">Cint</a>。 </p>
<p>一般被称为“解释型语言”的是主流实现为解释器的语言，但并不是说它就无法编译。例如说经常被认为是“解释型语言”的Scheme就有好几种编译器实现，其中率先支持R6RS规范的大部分内容的是Ikarus，支持在x86上编译Scheme；它最终不是生成某种虚拟机的字节码，而是直接生成x86机器码。 </p>
<p>解释器就是个黑箱，输入是源码，输出就是输入程序的执行结果，对用户来说中间没有独立的“编译”步骤。这非常抽象，内部是怎么实现的都没关系，只要能实现语义就行。你可以写一个C语言的解释器，里面只是先用普通的C编译器把源码编译为in-memory image，然后直接调用那个image去得到运行结果；用户拿过去，发现直接输入源码可以得到源程序对应的运行结果就满足需求了，无需在意解释器这个“黑箱子”里到底是什么。 </p>
<p>实际上很多解释器内部是以“编译器+虚拟机”的方式来实现的，先通过编译器将源码转换为AST或者字节码，然后由虚拟机去完成实际的执行。<strong>所谓“解释型语言”并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已</strong> 。</p>
]]></content>
    <summary type="html">
    <![CDATA[很多文章习惯将高级编程语言分成编译型语言和解释型语言，其实这是有误导成分的。语言一般只会定义其抽象语义，而不会强制性要求采用某种实现方式。]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="JVM" scheme="http://alexyyek.github.io/categories/JVM/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[博客文章汇总目录]]></title>
    <link href="http://alexyyek.github.io/2015/01/06/sticky/"/>
    <id>http://alexyyek.github.io/2015/01/06/sticky/</id>
    <published>2015-01-06T12:00:49.000Z</published>
    <updated>2015-01-14T12:56:01.000Z</updated>
    <content type="html"><![CDATA[<p>为了方便大家更好的梳理本博客的资源，更快的检索自己需要的博文，现将文章涉及的知识来源作如下归类，以后发表新的教程也会在本置顶帖内<strong>同步更新</strong>，后期考虑将加入更多的博客以外的资源链接，欢迎关注AlexYoung’s blog，与我一同成长。</p>
<h2 id="Thinking_in_Java系列">Thinking in Java系列</h2>
<ul>
<li><p><a href="http://alexyyek.github.io/2014/12/29/wrapperClass/" target="_blank" rel="external"><strong>JAVA基本类型和包装类</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/29/Reference/" target="_blank" rel="external"><strong>对象和引用</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2015/01/03/initial/" target="_blank" rel="external"><strong>JAVA初始化</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2015/01/12/Inherit/" target="_blank" rel="external"><strong>Java访问权限控制</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2015/01/14/Reusing/" target="_blank" rel="external"><strong>Java复用类</strong></a></p>
</li>
</ul>
<h2 id="算法导论系列">算法导论系列</h2>
<ul>
<li><p><a href="http://alexyyek.github.io/2014/12/07/heap/" target="_blank" rel="external"><strong>堆排序</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/07/lineSort/" target="_blank" rel="external"><strong>线性时间排序</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/08/select/" target="_blank" rel="external"><strong>中位数和顺序统计学</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/11/hash/" target="_blank" rel="external"><strong>散列函数</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/14/hashCollapse/" target="_blank" rel="external"><strong>哈希碰撞附Hashtable源码分析</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/17/BinaryTree/" target="_blank" rel="external"><strong>二叉查找树</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/23/RBTree/" target="_blank" rel="external"><strong>红黑树</strong></a></p>
</li>
</ul>
<h2 id="黑科技系列">黑科技系列</h2>
<ul>
<li><p><a href="http://alexyyek.github.io/2014/12/27/ipv6/" target="_blank" rel="external"><strong>教育网配置IPV6回避收费及轻松翻墙</strong></a></p>
</li>
<li><p><a href="http://alexyyek.github.io/2014/12/31/GFW/" target="_blank" rel="external"><strong>GAE + goagent + switchysharp + chrome翻墙</strong></a></p>
</li>
</ul>
<h2 id="影评书评系列">影评书评系列</h2>
<ul>
<li><a href="http://alexyyek.github.io/2015/01/05/BeginAgain/" target="_blank" rel="external"><strong>歌曲改变人生</strong></a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[博客传送机，帮你快速定位所需教程，以后的文章也将在此帖同步更新，后期将不断加入博客外的优秀学习资源链接和下载地址。]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[歌曲改变人生]]></title>
    <link href="http://alexyyek.github.io/2015/01/05/BeginAgain/"/>
    <id>http://alexyyek.github.io/2015/01/05/BeginAgain/</id>
    <published>2015-01-05T07:42:31.000Z</published>
    <updated>2015-01-05T10:10:55.000Z</updated>
    <content type="html"><![CDATA[<p><center> <img src="http://alexyoung.qiniudn.com/c4b9d7a5547a66ef3613f5c52584ab6c.jpg" alt=""> <center></center></center></p>
<hr>
<p><br><br>当你结束一天疲惫的工作，回到家独自静静的蜷缩在被窝，为自己重复的人生轨迹默哀、麻木时， <a href="http://movie.douban.com/celebrity/1280127/" target="_blank" rel="external">John Carney</a>总会在在不经意间用一段总时长不到一百分钟，编剧毫无好莱坞大片般的起伏跌宕，甚至场景都略显的不怎么上心的普通故事，轻松的叩开你最深层的防备，让流淌的音乐代替所有的言语，灌进你缺少母爱的心灵。影片结束的一瞬间，你仿佛有千言万语，却也只是最后通通化作淡然的一笑。因为你已阅片无数，作为一个老观影人你能轻松解构评价这种类型的影片，但你只是迅速的登陆了BT账号搜索原声OST，在发现居然没有人上传后，忍痛连上一个月10G的校园网，开启虾米VIP默默的下载了Soundtrack，然后开启列表循环写下这些文字。</p>
<p>感觉跑题的观众姥爷不要在意，上面只是一个屌丝的故事而已。</p>
<p>2006年的<a href="http://movie.douban.com/subject/2053515/" target="_blank" rel="external">Once</a>，八年后<a href="http://movie.douban.com/subject/6874403/" target="_blank" rel="external">Begin Again</a>，这位爱尔兰出身的导演兼音乐人似乎永远有走不完的年少青春，无论岁月如何在所有人的身上静静流逝，只要音乐存在，他就永远是那个不变的他。你可以四十五度角仰望天空并用轻蔑的语气说从中仿佛看到了岛国中年大叔对某种低级情趣的执迷不悟，也可以低垂眼睑用修长的睫毛为之刻上男人至死都是少年的信念，或者干脆大声指责这根本就是一个音乐疯子才可能经历的故事，但不管你如何一本正经或是假装不屑，都已在这短短的一百分钟被烙上了John Carney的烙印，他用大街小巷随处可见的故事告诉你：这就是生活的美丽。</p>
<p>So，why not to be better?</p>
<p>影片中的场景缤纷多彩，无论是经典的酒吧，难得一见的录音棚，别出新意的帝国大厦楼顶、夜间的地下铁，还是随处可见的大街小巷，都在旋律的悦动中被激发出了不同以往的感觉，不需要花哨的演奏技巧，跟着演员们自然甚至略显生涩的演奏，很难保证自己的身体不随之而颤动。而更令人惊艳的便是女主角<a href="http://movie.douban.com/celebrity/1054448/" target="_blank" rel="external">Keira Knightley</a>在众多场景的不同着装，当你感觉真心不会有比这更好看更自然的搭配时，她就身着另一套不同的搭配出现在你的视野里，颠覆你的审美，刷新你的三观，告诉你做人flag不要立的太早。</p>
<p><center> <img src="http://alexyoung.qiniudn.com/BeginAgain2.jpg" alt=""> <center> </center></center></p>
<p>当然各路配角们同样的出彩，学院气质拉大小提琴的姐弟、嘻哈风格的黑人鼓手和贝斯手、看似古板实则为音乐而躁动的钢琴手，配上男主角的贝斯和女儿的吉他，相信你也会产生这才是音乐的共鸣。</p>
<p>为什么要推荐Begin Again这部电影呢，你或许会以为肯定是博主小清新爆棚，三观幼稚，性格中二，所以推荐了这样一部看人看风景听音乐的爱情电影。当然你这么想也无妨，毕竟看过才能体会。</p>
<p>那么除此以外呢，我想大概是因为它毫不掩饰的描述了人们追寻梦想的路径，但导演并没有把梦想悬空，更没有一点点对梦想的歌颂腔。男女主角遭遇了都市中的一切困窘与冷漠，物质上的贫困和精神上的挫败都是他们生活中的常态。他们处理着这些事务，但没有被琐碎打败。他们做着奔向梦想的事情，但绝没有到处声称自己是理想主义者以博得同情。更有意味的是，电影中和男女主角一起追梦的还有一群和他们同样的普通人。当他们的音乐被大唱片公司拒绝，他们就决定在纽约这座城市的各处独立录音。Gretta和Dan找来了街头卖艺的音乐人、黑人鼓手、心怀梦想但一直只能给学校舞蹈队伴奏的键盘演奏家，无论地铁站、帝国大厦的楼顶、大桥下、唐人街都成为了他们的露天录音棚。他们录下了音乐，也录下了这座城市的所有声响，从这个意义上讲，他们所做的不只是对音乐的追寻和完成一张唱片，而是真的融化进了纽约，或者说，把纽约融化进了自己的身体，呈现了这座城市以及生活在其中的人们的呼吸与脉动。做这些时，Gretta和Dan没有区隔哪些是梦想，哪些是生存，每一天，他们尽量快乐地活在当下，也尽最大努力接近梦想。 </p>
<p><center> <img src="http://alexyoung.qiniudn.com/BeginAgain4.jpg" alt=""> <center> </center></center></p>
<p><br><br>这部电影告诉我们，梦想从来都不是挂在嘴边炫耀的名词，它是个动词，你应该因它成为一个Doer，而不是一个Talker，更不是做一个自鸣得意沾沾自喜的Thinker，梦想从来都是因行动而伟大。</p>
<p>所以看到这里的少男少女们，燥起来吧，用心体会生活的美妙，追寻生命的意义，就像结尾男主角所唱的<a href="http://www.xiami.com/song/1773303359?spm=a1z1s.6626017.226669510.11.NXNvB1&amp;from=search_popup_song#wall_list" target="_blank" rel="external"><strong>Lost stars</strong></a>里最后一句：<strong>But are we all lost stars, trying to light up the dark?</strong></p>
<p><center> <img src="http://alexyoung.qiniudn.com/BeginAgain1.jpg" alt=""> <center><br><br></center></center></p>
<p>一百分钟的人生转瞬即逝，片尾回想起Gretta和Dan第一次见面时说的话</p>
<blockquote>
<p>Gretta：”This really is a bit of a long shot, isn’t it?”<br>Dan Mulligan：”Absolutely! That’s when the magic happens.”</p>
</blockquote>
<p>也许就是人生，你永远不知道你会成就什么，但仍然将为之而义无反顾。<br>多年后，偶然回想起那些依稀闪光的片段，这也许也正是人生美妙的地方。</p>
<p>PS. 喜欢电影的同学可以关注博主的豆瓣，博客这里将不定期更新推荐电影或不涉及剧透的影评，欢迎大家一起分享自己的观影体验。当然喜欢本博客的土豪们可以在首页进行支付宝赞助，所得赞助将全部用于博客图床扩容和域名购买。</p>
]]></content>
    <summary type="html">
    <![CDATA[Gretta："This really is a bit of a long shot, isn't it?" <br> Dan Mulligan："Absolutely! That's when the magic happens."]]>
    
    </summary>
    
      <category term="Movie" scheme="http://alexyyek.github.io/tags/Movie/"/>
    
      <category term="生活感悟" scheme="http://alexyyek.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA初始化]]></title>
    <link href="http://alexyyek.github.io/2015/01/03/initial/"/>
    <id>http://alexyyek.github.io/2015/01/03/initial/</id>
    <published>2015-01-03T13:13:55.000Z</published>
    <updated>2015-01-04T11:22:57.000Z</updated>
    <content type="html"><![CDATA[<p>初始化和清理是涉及安全的两个问题，许多C程序的错误都源于忘记初始化变量，当使用完一个元素时，也很容易忘记清理它。C++引入了构造器的概念，这是一个在创建对象时被自动调用的特殊方法，Java中也采用了构造器，并额外提供了垃圾回收器，对于不再使用的内存资源，垃圾回收器能自动将其释放。</p>
<p>在Java中，通过提供构造器，类的设计者可确保每个对象都会得到初始化。创建对象时，如果类具有构造器，就会自动调用相应的构造器。</p>
<p>本文提纲源于Thingking in Java，但主体讲解内容在其上有更深入的探讨。我们首先明确一下this关键词在构造器中的作用，然后分析构造器的初始化流程。    </p>
<h2 id="this关键字">this关键字</h2>
<p>从本质上讲，<code>this</code>是一个指向对象的指针（引用）。通常写<code>this</code>的时候，都是指这个对象或当前对象。而在构造器中，如果为<code>this</code>添加参数列表，将产生对符合此参数列表的某个构造器的明确调用，从而可以直接调用其他构造器。</p>
<p>首先看一个<a href="http://stackoverflow.com/questions/3728062/what-is-the-meaning-of-this-in-java" target="_blank" rel="external">stackoverflow</a>上的例子：</p>
<figure class="highlight JAVA"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThisTest</span> </span>{</div><div class="line">		<span class="keyword">private</span> <span class="keyword">int</span> a;</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="title">MyThisTest</span>() {</div><div class="line">			<span class="keyword">this</span>(<span class="number">42</span>); <span class="comment">// calls the other constructor</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="title">MyThisTest</span>(<span class="keyword">int</span> a) {</div><div class="line">			<span class="keyword">this</span>.a = a; <span class="comment">// assigns the value of the parameter a to the field of</span></div><div class="line">						<span class="comment">// the same name</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">frobnicate</span>() {</div><div class="line">			<span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line">			System.out.println(a); <span class="comment">// refers to the local variable a</span></div><div class="line">			System.out.println(<span class="keyword">this</span>.a); <span class="comment">// refers to the field a</span></div><div class="line">			System.out.println(<span class="keyword">this</span>); <span class="comment">// refers to this entire object</span></div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">			<span class="keyword">return</span> <span class="string">"MyThisTest a="</span> + a; <span class="comment">// refers to the field a</span></div><div class="line">		}</div><div class="line">		</div><div class="line">		MyThisTest increment(){</div><div class="line">			a++;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// refer to the reference of class MyThisTest</span></div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>从这个例子可以总结<code>this</code>的几种关键用法：</p>
<ol>
<li>区分同名变量：<code>this</code>关键字是类内部当中对自己的一个引用，可以方便类中方法访问自己的属性。成员变量与方法内部的变量重名时，希望在方法内部调用成员变量，如<code>this.a = a</code></li>
<li>返回类自身的引用，在<code>increment()</code>方法中通过<code>this</code>关键字返回了对当前对象的引用</li>
<li>在当前类的一个构造函数当中调用另一个构造函数，在无参构造器中通过<code>this(42)</code>调用构造器<code>MyThisTest(int a)</code><br><br></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Flower {</div><div class="line">		<span class="keyword">int</span> petals = <span class="number">0</span>;</div><div class="line">		String s = <span class="string">"initial value"</span>;</div><div class="line"></div><div class="line">		Flower() {</div><div class="line">			<span class="keyword">this</span>(<span class="string">"hello"</span>, <span class="number">5</span>);</div><div class="line">		}</div><div class="line"></div><div class="line">		Flower(<span class="keyword">int</span> petals) {</div><div class="line">			<span class="keyword">this</span>.petals = petals;</div><div class="line">		}</div><div class="line"></div><div class="line">		Flower(String s) {</div><div class="line">			<span class="keyword">this</span>.s = s;</div><div class="line">		}</div><div class="line"></div><div class="line">		Flower(String s, <span class="keyword">int</span> petals) {</div><div class="line">			<span class="keyword">this</span>(petals);</div><div class="line">			<span class="comment">/* Error : this(s);</span></div><div class="line">			 * Constructor call must be the first statement in a constructor */</div><div class="line">			<span class="keyword">this</span>.s = s;			</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">void</span> print() {</div><div class="line">			<span class="comment">/* Error : this(s);</span></div><div class="line">			 * can not call the constructor in any method other than a constructor. */</div><div class="line">			System.out.println(<span class="keyword">this</span>.petals + <span class="string">" "</span> + s);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>上面的例子列出了一些要注意的使用情况：</p>
<ol>
<li>在构造方法中调用另一个构造方法，调用动作必须置于最起始的位置。</li>
<li>在一个构造方法内只能调用一个构造方法。</li>
<li>不能在构造方法以外的任何方法内调用构造方法。 </li>
</ol>
<h2 id="构造器初始化">构造器初始化</h2>
<h3 id="初始化顺序">初始化顺序</h3>
<ol>
<li>变量定义的先后顺序决定了初始化的顺序</li>
<li>但是不论变量定义在什么位置，都会在任何方法（包括构造器）被调用之前得到初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class House{</div><div class="line">	Window window1 = <span class="keyword">new</span> Window(<span class="number">1</span>);</div><div class="line">	House(){</div><div class="line">		System.out.println(<span class="string">"In House"</span>);</div><div class="line">		window3 = <span class="keyword">new</span> Window(<span class="number">33</span>);</div><div class="line">	}</div><div class="line">	Window window2 = <span class="keyword">new</span> Window(<span class="number">2</span>);</div><div class="line">	<span class="keyword">void</span> f(){System.out.println(<span class="string">"f()"</span>);}</div><div class="line">	Window window3 = <span class="keyword">new</span> Window(<span class="number">3</span>);</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitStatic</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		House h = <span class="keyword">new</span> House();</div><div class="line">		h.f();</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>在House类中，故意将几个Window对象的定义散布到各处，从而证明他们全部会在<strong>调用构造函器或其他方法之前</strong>得到初始化。此外window3在构造器内再次被初始化，第一次引用的对象将被丢弃，作为垃圾回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Windows:<span class="number">1</span></div><div class="line">Windows:<span class="number">2</span></div><div class="line">Windows:<span class="number">3</span></div><div class="line">In House</div><div class="line">Windows:<span class="number">33</span></div><div class="line">f()</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<h3 id="静态数据初始化">静态数据初始化</h3>
<p>无论创建多少个对象，静态数据都只占<strong>一份存储区域</strong>。静态数据初始化遵循以下原则：</p>
<ul>
<li>初始化的顺序是先静态对象，而后是非静态对象。</li>
<li>静态数据成员的初始化只有在必要时才会进行。<ol>
<li>创建类的对象             </li>
<li>引用类的静态数据成员</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">class Window{</div><div class="line">	Window(<span class="keyword">int</span> marker){</div><div class="line">		System.out.println(<span class="string">"Window:"</span> + marker);</div><div class="line">	}</div><div class="line">	<span class="keyword">void</span> f1(<span class="keyword">int</span> marker){</div><div class="line">		System.out.println(<span class="string">"f1():"</span> + marker);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class House{</div><div class="line">	<span class="keyword">static</span> Window window1 = <span class="keyword">new</span> Window(<span class="number">1</span>);</div><div class="line">	House(){</div><div class="line">		System.out.println(<span class="string">"Table():"</span>);</div><div class="line">		window2.f1(<span class="number">1</span>);</div><div class="line">	}</div><div class="line">	<span class="keyword">void</span> f2(<span class="keyword">int</span> marker){</div><div class="line">		System.out.println(<span class="string">"f2():"</span> + marker);</div><div class="line">	}</div><div class="line">	<span class="keyword">static</span> Window window2 = <span class="keyword">new</span> Window(<span class="number">2</span>);</div><div class="line">}</div><div class="line"></div><div class="line">class People{</div><div class="line">	Window window3 = <span class="keyword">new</span> Window(<span class="number">3</span>);</div><div class="line">	<span class="keyword">static</span> Window window4 = <span class="keyword">new</span> Window(<span class="number">4</span>);</div><div class="line">	People(){</div><div class="line">		System.out.println(<span class="string">"People():"</span>);</div><div class="line">		window4.f1(<span class="number">2</span>);</div><div class="line">	}</div><div class="line">	<span class="keyword">void</span> f3(<span class="keyword">int</span> marker){</div><div class="line">		System.out.println(<span class="string">"f3():"</span> + marker);</div><div class="line">	}</div><div class="line">	<span class="keyword">static</span> Window window5 = <span class="keyword">new</span> Window(<span class="number">5</span>);</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitStatic</span> </span>{</div><div class="line">	<span class="keyword">static</span> House house = <span class="keyword">new</span> House();</div><div class="line">	<span class="keyword">static</span> People people = <span class="keyword">new</span> People();</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		System.out.println(<span class="string">"Creating new House in main"</span>);</div><div class="line">		<span class="keyword">new</span> People();</div><div class="line">		System.out.println(<span class="string">"Creating new House in main"</span>);</div><div class="line">		<span class="keyword">new</span> People();</div><div class="line">		house.f2(<span class="number">1</span>);</div><div class="line">		people.f3(<span class="number">1</span>);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li>要加载main()，必须加载ExplicitStatic类，然后其静态域house和people被初始化，这导致他们对应的类也被加载。类House内先初始化静态数据成员window1和window2，然后初始化构造器，调用类Window的f1()方法；类People内同理，注意先初始化静态成员，后非静态成员，所以顺序是4,5,3.</li>
<li>main函数中生成新的People对象，由于之前类People中静态成员加载过，故不再加载。</li>
</ol>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Window:<span class="number">1</span></div><div class="line">Window:<span class="number">2</span></div><div class="line">Table():</div><div class="line">f1():<span class="number">1</span></div><div class="line">Window:<span class="number">4</span></div><div class="line">Window:<span class="number">5</span></div><div class="line">Window:<span class="number">3</span></div><div class="line">People():</div><div class="line">f1():<span class="number">2</span></div><div class="line">Creating <span class="keyword">new</span> House in main</div><div class="line">Window:<span class="number">3</span></div><div class="line">People():</div><div class="line">f1():<span class="number">2</span></div><div class="line">Creating <span class="keyword">new</span> House in main</div><div class="line">Window:<span class="number">3</span></div><div class="line">People():</div><div class="line">f1():<span class="number">2</span></div><div class="line">f2():<span class="number">1</span></div><div class="line">f3():<span class="number">1</span></div></pre></td></tr></table></figure>


<p><br></p>
<hr>
<h3 id="显示的静态初始化">显示的静态初始化</h3>
<p>Java允许将多个静态初始化动作组织成一个特殊的“静态子句”（静态块）。与其他静态初始化动作一样，仅执行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitStatic</span> </span>{</div><div class="line">    <span class="comment">//  static Cups cup3 = new Cups();</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		Cups.cup1.f(<span class="number">99</span>);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class Cup{</div><div class="line">	Cup(<span class="keyword">int</span> marker){</div><div class="line">		System.out.println(<span class="string">"Cup:"</span> + marker);</div><div class="line">	}</div><div class="line">	<span class="keyword">void</span> f(<span class="keyword">int</span> marker){</div><div class="line">		System.out.println(<span class="string">"f:"</span> + marker);</div><div class="line">	}</div><div class="line">}</div><div class="line"></div><div class="line">class Cups{</div><div class="line">	<span class="keyword">static</span> Cup cup1;</div><div class="line">	<span class="keyword">static</span> Cup cup2;</div><div class="line">	<span class="keyword">static</span>{                 <span class="comment">//静态块</span></div><div class="line">		cup1 = <span class="keyword">new</span> Cup(<span class="number">1</span>);</div><div class="line">		cup2 = <span class="keyword">new</span> Cup(<span class="number">2</span>);</div><div class="line">	}</div><div class="line">	Cups(){</div><div class="line">		System.out.println(<span class="string">"Cups"</span>);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>程序访问Cups的静态成员cup1，类Cups初始化，首先初始化静态数据成员cup1、cup2，<strong>由于这里并没有生成类Cups的对象</strong>，所以类Cups的无参构造函数并不执行。<br>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Cup:<span class="number">1</span></div><div class="line">Cup:<span class="number">2</span></div><div class="line">f:<span class="number">99</span></div></pre></td></tr></table></figure>

<p>如果把main方法上面的cup3的注释去掉，那么由于生成了Cups类的对象，此时输出结果变成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Cup:<span class="number">1</span></div><div class="line">Cup:<span class="number">2</span></div><div class="line">Cups</div><div class="line">f:<span class="number">99</span></div></pre></td></tr></table></figure>

<p><strong>注意</strong>：如果类Cups里包含了非静态数据成员<code>Cup cup3 = new Cup();</code>，在执行main程序访问类Cups静态成员cup1时<code>Cups.cup1.f(99);</code>，也只会初始化静态成员cup1和cup2，输出结果不变。<br><br></p>
<hr>
<h3 id="非静态实例初始化">非静态实例初始化</h3>
<p>非静态初始化与静态初始化子句一模一样，只不过少了<code>static</code>关键字。这种语法对于支持“匿名内部类”的初始化时必须的，但是它也使得你可以保证无论调用了哪个显示构造器，某些操作都会发生。同时它不再具备静态对象初始化的优先级，所以可能先初始化构造器，后执行实例初始化。</p>
<p><br></p>
<h2 id="数组初始化">数组初始化</h2>
<p>Thinking in Java中数组初始化的问题讲的并不透彻，现在我们来深入一下对Java数组的认识。</p>
<h3 id="理解数组">理解数组</h3>
<p>数组也是一种数据类型，本身就是一种引用类型，我们从它的初始化方法，通过关键字new去完成定义及初始化就可以知道。</p>
<p>数组的长度是不变的，一旦数组完成初始化后，它的长度就固定下来了，在内存中占有的空间也就固定了，即使里面的数据被清空了，占有的空间还是保留下来了，依然是属于数组的，当然长度依旧是不变的。</p>
<p>数组里边存放的数据类型要一致，可以基本数据类型，也可以是引用数据类型，但是唯一的标准就是相同的类型。在Java中，类与类是支持继承关系的，所以就可能造成数组里面可以存在多中数据类型的假象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class Animal {</div><div class="line">    <span class="keyword">public</span> String name;</div><div class="line">   </div><div class="line">    <span class="keyword">public</span> <span class="title">Animal</span>(String name) {</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    }</div><div class="line">}</div><div class="line">class Cat extends Animal {</div><div class="line">    <span class="keyword">public</span> <span class="title">Cat</span>(String name) {</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    }</div><div class="line">}</div><div class="line">class Dog extends Animal {</div><div class="line">    <span class="keyword">public</span> <span class="title">Dog</span>(String name) {</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Animal[] animals = <span class="keyword">new</span> Animal[<span class="number">2</span>];</div><div class="line">        Cat cat = <span class="keyword">new</span> Cat(<span class="string">"little cat"</span>);</div><div class="line">        Dog dog = <span class="keyword">new</span> Dog(<span class="string">"little dog"</span>);</div><div class="line">        animals[<span class="number">0</span>] = cat;</div><div class="line">        animals[<span class="number">1</span>] = dog;</div><div class="line">        System.out.println(animals[<span class="number">0</span>].name);</div><div class="line">        System.out.println(animals[<span class="number">1</span>].name);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这样看上去，好像数组里面存放了Cat类型和Dog类型，但是实际上他们都是Animal类型，数组里面都是相同的类型，请大家不要搞混淆了。</p>
<h3 id="定义数组和初始化数组">定义数组和初始化数组</h3>
<p>定义数组的语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">type[] arrayName;</div><div class="line">type arrayName[];</div></pre></td></tr></table></figure>

<p>无论是Thinking in Java还是我个人都推荐第一种方式，直观的告诉别人定义了一个type类型数组，而不是type类型变量。</p>
<p>初始化数组：</p>
<p>$1$. 静态初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arrayName = <span class="keyword">new</span> type[]{element1,element2, element3......};</div></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> [] int_arr_1 = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</div><div class="line">Integer arr = {<span class="keyword">new</span> Integer(<span class="number">1</span>), <span class="keyword">new</span> Integer(<span class="number">2</span>), <span class="number">3</span>}; <span class="comment">// JAVA基本类型和包装类探讨过的*自动装箱功能*</span></div></pre></td></tr></table></figure>

<p>$2$. 动态初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">arrayName = <span class="keyword">new</span> type[length];</div></pre></td></tr></table></figure>

<p>当然不同的数据类型，系统分配的初始值不同。<br><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">基本类型</th>
<th style="text-align:center">初始值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">整数类型（byte、short、int、long）</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">浮点类型（float、double）</td>
<td style="text-align:center">0.0</td>
</tr>
<tr>
<td style="text-align:center">字符类型（char）</td>
<td style="text-align:center">‘\u0000’（代表空格）</td>
</tr>
<tr>
<td style="text-align:center">布尔类型（boolean）</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">引用类型（类、接口、数组）</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
<h3 id="内存中的数组">内存中的数组</h3>
<p>们让一个引用变量指向另外一个实际的数组的时候，可能产生数组长度可变的假象，大家来看看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo3</span> </span>{</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        </div><div class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]{<span class="number">1</span>, <span class="number">2</span>};</div><div class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</div><div class="line">        System.out.println(<span class="string">"length of b:"</span> + b.length);</div><div class="line">        </div><div class="line">        b = a;</div><div class="line">        System.out.println(<span class="string">"length of b:"</span> + b.length);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>结果：b数组的长度好像发生了变化，但是实际上不是这样的，我们来分析一下内存中的变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">length of b:<span class="number">4</span></div><div class="line">length of b:<span class="number">2</span></div></pre></td></tr></table></figure>

<p>如果你不能明确的理解Java中对象和引用以及参数传递的本质，建议你首先看一下<a href="http://alexyyek.github.io/2014/12/29/Reference/" target="_blank" rel="external">之前的博客</a>。</p>
<p>上面的程序中：</p>
<ol>
<li>在堆中创建数组对象{1,2}，占用两个长度，并在堆栈中创建引用a指向堆中数组{1,2}的首地址。</li>
<li>在堆中开辟长度为4的数组空间，初始化为{0,0,0,0}；然后在堆栈中创建引用b指向堆中数组{0,0,0,0}的首地址。</li>
<li>将引用a指向的地址副本传递给引用b，故引用b不再指向{0,0,0,0}，而是指向引用a所指的{1,2}</li>
</ol>
<p><strong>总结</strong>：我们所说的<strong>数组的长度不变是针对堆内存中真正数组的长度</strong>，引用变量是可以改变指向的，指到哪里肯定就显示指到的数组的长度了，但是真正的长度是不曾改变的。</p>
<h2 id="可变参数列表">可变参数列表</h2>
<h3 id="基本使用">基本使用</h3>
<p>当调用方法时，方法的参数个数或类型未知时，称其为可变参数列表。可变长参数列表是Java 5中的一个新特性。如果方法需要传入多个同类型参数的话，这个功能就非常有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArrays</span>(Object[] args ){</div><div class="line">        <span class="keyword">for</span> (Object arg : args)</div><div class="line">            System.out.println( arg );</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		printArrays(<span class="keyword">new</span> Object[]{<span class="keyword">new</span> Integer(<span class="number">25</span>),<span class="keyword">new</span> Float(<span class="number">3.1415</span>),<span class="keyword">new</span> Character(<span class="string">'a'</span>), <span class="keyword">new</span> String(<span class="string">"shit"</span>)});</div><div class="line">		printArrays(<span class="keyword">new</span> Object[]{<span class="keyword">new</span> A(),<span class="keyword">new</span> A(),<span class="keyword">new</span> A()});</div><div class="line">}</div></pre></td></tr></table></figure>

<p>由于所有的类都直接或间接继承于Object类，所以可以创建以Object数组为参数的方法并如上调用。然而Java 5增加了对可变参数的支持，现在你可以用下面的方法更简洁的调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class A{}</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArrays</span>(Object... args ){</div><div class="line">        <span class="keyword">for</span> (Object arg : args)</div><div class="line">            System.out.println( arg );</div><div class="line">}</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		printArrays(<span class="number">3</span>,<span class="number">3.547</span>,<span class="number">3.456</span>f,<span class="string">"Alex"</span>,<span class="keyword">new</span> A(),<span class="keyword">new</span> Date(),<span class="string">"string"</span>+<span class="number">50</span>);</div><div class="line">		printArrays((Object[])<span class="keyword">new</span> Integer[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">32</span>,<span class="number">4</span>});</div><div class="line">}</div></pre></td></tr></table></figure>

<p>注意main程序最后一行，Integer数组传递给了printArrays()，因为它已经是一个数组，所以不再进行转换。<br>因此，如果你有一组事物，可以把它们当做列表传递；而如果你已经有了一个数组，该方法可以把其当做可变参数列表来接受。</p>
<h3 id="使用规范">使用规范</h3>
<p>$1$. 一个方法只能有一个可变长参数，并且这个可变长参数必须是该方法的最后一个参数   </p>
<p>正确体位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> printArrays(String arg, String...args){</div><div class="line">		System.out.println(arg);</div><div class="line">		<span class="keyword">for</span>(Object obj : args){</div><div class="line">			System.out.print(obj + <span class="string">"\t"</span>);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>$2$. 你应该总是只在重载方法的一个版本上使用可变参数列表，或者压根就不用丫。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> printArrays(String... args){</div><div class="line">		<span class="keyword">for</span>(Object obj : args){</div><div class="line">			System.out.print(obj + <span class="string">"\t"</span>);</div><div class="line">		}</div><div class="line">		System.out.println();</div><div class="line">	}</div><div class="line">	<span class="keyword">static</span> <span class="keyword">void</span> printArrays(String arg, String...args){</div><div class="line">		System.out.println(arg);</div><div class="line">		<span class="keyword">for</span>(Object obj : args){</div><div class="line">			System.out.print(obj + <span class="string">"\t"</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">	<span class="comment">/*  Compile Error</span></div><div class="line">	 *  printArrays("what","the","fuck");*/</div><div class="line">}</div></pre></td></tr></table></figure>

<p>此时编译器无法知道你到底是要调用哪个方法，因为两个方法看起来都可以。除非你为这两个方法都添加一个非可变参数。</p>
<p>$3$. 别让null值和空值威胁到变长方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> func(Integer...args){}</div><div class="line">	</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> func(String...args){}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">            func(<span class="number">0</span>);</div><div class="line">		    func(<span class="string">"Alex"</span>);</div><div class="line">		    func(); <span class="comment">//Compile Error</span></div><div class="line">		    </div><div class="line">		    String word = <span class="keyword">null</span>;</div><div class="line">	    	func(word); <span class="comment">//That's OK</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>在每一种情况，编译器都会使用<a href="http://alexyyek.github.io/2014/12/29/wrapperClass/" target="_blank" rel="external">自动包装</a>机制来匹配重载的方法，然后调用最明确的匹配方法。但是调用<code>f()</code>时，编译器不知道应该调用哪个方法，可以通过第10、11行的修改编译通过。</p>
<p>最后来个简单的测试，看看你是否还清醒：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span>(String arg, String... args) {</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) {</div><div class="line">            System.out.println(args[i]);</div><div class="line">        }</div><div class="line">    }</div><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){   </div><div class="line">            f(<span class="string">""</span>);</div><div class="line">               f(<span class="string">"aaa"</span>);</div><div class="line">               f(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>);</div><div class="line">}</div></pre></td></tr></table></figure>

<p>这是看到的一个<a href="http://java-performance.info/java-varargs-performance-issues/" target="_blank" rel="external">英文版讲解</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Java采用构造器的概念（在创建对象时被自动调用的特殊方法），并额外提供垃圾回收器，来确保避免不安全的编程方式，本节主要讨论初始化的相关问题。]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写在2014边上]]></title>
    <link href="http://alexyyek.github.io/2014/12/31/2014/"/>
    <id>http://alexyyek.github.io/2014/12/31/2014/</id>
    <published>2014-12-31T13:46:08.000Z</published>
    <updated>2014-12-31T15:55:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="2014总结">2014总结</h2>
<p>2014年对我来说是过得非常快的一年，这种快不是由于过于重复单调而产生的那种令人忘却的快，而是因为在这一年我遇见了很多有趣的人，走遍了很多有趣的地方，激发了很多想要列上Todo List的想法，也更加坚定了自己前进的方向后，那种突然将未来的所有可能性放在眼前让人应接不暇的快。</p>
<h3 id="实习">实习</h3>
<p>2013年研究生刚刚入学，十一月份便跑去参加了百度的实习面试，现在回想起来当初其实并不是非常想要实习，只是想试试自己能不能获得某种程度的认可。一共面了两家公司，搜狗和百度，搜狗的面试让我充分意识到了机器学习中人工标注和预处理的重要性，但并不是非常符合我的预期，所以委婉拒绝了搜狗的实习。第二天面百度，两轮下来就两个小时没了，虽然有的问题没有回答上来，但给出了基本的思路和尝试方法，一周内便接到了入职的电话。</p>
<p>一实习便是半年，从最初的很多东西都不懂，通过不断的请教各位大神，自己查资料想解决办法，到能独立的完成每天的Job，再开始略加指导新来的同事，这半年见证了我的成长。当然实习有利有弊，在获得实习能力提升的时候，往往很难顾及实验室的工作，这是我比较遗憾的地方，人的精力还是有限的，需要合理分配。</p>
<p>这里想说一下百度给我个人的印象，也方便想去实习的同学有个参考吧。首先百度的公司氛围非常好，有很浓厚的技术气息，因为基本上都是三十岁以下的年轻人，讨论或者咨询问题都非常舒服，可以充分开发你的脑洞，提出不同的想法和思路。其次百度的作息时间也比较合理，早上十点上班，下午六点下班，周末放假。最后也是最幸福的一点便是每个季度都可以免费向公司买书，这对于实习生有莫大的价值。</p>
<h3 id="生活">生活</h3>
<p>五月末辞了实习，便和妹子去杭州玩了一趟，至于为什么选择杭州，当然是有阿里的成分在里面，相比帝都的房价和雾霾，我可能更偏向选择较为舒适的南方城市。</p>
<p>杭州的景色并没有辜负我的期望，想去游玩的同学不要错过，土豪记得带上你们的单反，出片率高到飞起。杭州的美食也非常可口，虽然饮食口味偏于清淡，但灵活多变的美食做法也不会让你厌倦。</p>
<p>唯一可惜的就是阿里上市了，就这么在我还没毕业之前上市了…</p>
<h3 id="感悟">感悟</h3>
<p>常常和别人谈论到一个很土的话题，成功与失败。</p>
<p>聪明的人告诉我你应该理性分析，合理投资，回避风险，最大化收益。话并没有错，但如果你是一个程序猿，请听下面的建议：</p>
<p>我觉得你应该尝试经历失败。</p>
<p>常常让我感触比较深的是在学习一种新的技术时，明明有网上的教程指导，但还是出现了各种奇怪的问题，按理说不应该发生的问题。于是我不断的寻找解决方案，对比不同的解决方法，分析他们的原理，最后选择合适的方案继续下一步，然后再遇到突发问题，再解决掉，如此不断反复，总算是亦趋亦步的走了过来。</p>
<p>然后回头再看那个教程，你应该会有这样一种感觉，我可以针对你这个教程专门再写一个教程来纠正和补充你，并且解释其中的原理。并且无论以后面试中问到这方面的问题，还是实际工作中遇到这方面的问题，我相信都能理性的分析，并快速定位问题源头，最终合理的解决。</p>
<p>而如果我当初按照那个教程傻傻的一遍成功了，可能我并不会了解这么深。</p>
<p>所以想说的本质其实就是一句话：<strong>一定要重视理解的深度。</strong></p>
<p>我相信这便是人与人的区别。</p>
<h2 id="2015_Todo_List">2015 Todo List</h2>
<ul>
<li>一两个拿得出手的项目</li>
<li>实习经验，创业公司为先，有项目可参与</li>
<li>刷面试书籍 </li>
<li>学习一门动态语言</li>
<li>论文中稿，求过！！！ </li>
<li>五月去内蒙古</li>
<li>拿到理想中的offer好养活妹纸</li>
</ul>
<p>最后祝大家元旦快乐~单身狗早日脱单，找到想要的实习和工作~~<br>请接收我最真诚的祝福。</p>
]]></content>
    <summary type="html">
    <![CDATA[You do what you love, and fuck the rest.]]>
    
    </summary>
    
      <category term="life" scheme="http://alexyyek.github.io/tags/life/"/>
    
      <category term="生活感悟" scheme="http://alexyyek.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[免费且使用便捷的翻墙方案]]></title>
    <link href="http://alexyyek.github.io/2014/12/31/GFW/"/>
    <id>http://alexyyek.github.io/2014/12/31/GFW/</id>
    <published>2014-12-31T09:55:42.000Z</published>
    <updated>2014-12-31T10:52:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录">目录</h2>
<p>翻墙方法多如牛毛，但都因为自身的因素而各有利弊。Freegate使用简单，适合初学者，但开启后访问国内网站将出现问题；VPN有的收费有的免费，免费的VPN由于使用者众多网速low的一比，收费的能够提供更好的服务，但需要为之买单。而且从技术角度分析VPN加密流程会发现：你的机子-&gt;(加密)-&gt;VPN-&gt;(解密后的)-&gt;访问目标机子，就算你的机子和VPN之间怎么加密，在最终发给目标机子都会还原成没加密的。这并不是吓唬大家，只是万事有利有弊，自行取舍罢了。而上一篇<a href="http://alexyyek.github.io/2014/12/27/ipv6/" target="_blank" rel="external">改Hosts</a>的办法虽然简单，但能翻的网站有限，而且需要不断更新。</p>
<p>下面推荐的是一种基于GAE（Google App Engine）+ goagent + switchysharp + chrome的翻墙之法，相对刚才介绍的方案，此方法上手较易，使用体验也非常不错（当你配置完后便能充分的感受到），并且完全免费。所以请不要害怕这过长的篇幅，按部就班10分钟左右搞定。</p>
<p>那么让我们一起迎接2015这新世界吧。</p>
<p><center> <img src="http://alexyoung.qiniudn.com/464564.jpg" alt=""> <center><br><br></center></center></p>
<hr>
<h3 id="入门介绍">入门介绍</h3>
<ol>
<li>GAE（Google App Engine）是一个开发、托管网络应用程序的平台；</li>
<li>goagent是一个使用Python和Google Appengine SDK编写的代理软件；</li>
<li>switch sharp是一个chrome插件，具体功能类似于Firefox的AutoProxy.</li>
</ol>
<h3 id="申请Google_App_Engine并创建app">申请Google App Engine并创建app</h3>
<ul>
<li>首先去注册一个google账户，没有绑定手机号码的建议<a href="https://security.google.com/settings/security/signinoptions/rescuephone" target="_blank" rel="external">绑定</a>。</li>
<li>创建属于你的<a href="https://appengine.google.com/start/createapp" target="_blank" rel="external"><strong>Application</strong></a>，填写你的APP ID，</li>
</ul>
<p><strong>错误体位</strong>：</p>
<p><center> <img src="http://alexyoung.qiniudn.com/GAE1.png" alt=""> <center></center></center></p>
<p><strong>正确体位</strong></p>
<p><center> <img src="http://alexyoung.qiniudn.com/GAE2.png" alt=""> <center></center></center></p>
<p><strong>填写方式</strong></p>
<p><center> <img src="http://alexyoung.qiniudn.com/GAE3.png" alt=""> <center></center></center></p>
<ul>
<li>一切正常的话就会看到下面的界面（告诉你App已经申请成功了）<br><center> <img src="http://alexyoung.qiniudn.com/GAE4.png" alt=""> <center></center></center></li>
</ul>
<p><br><br><strong>注意</strong>：GAE的check不一定可靠，可能出现提示available但是commit后提示<code>This application ID or version is already in use</code>的情况，所以请另换ID。现在每个用户可以创建25个APP，每个应用每天有1GB的免费流量。如果你经常下载或者观看视频建议多创建几个Google App Engine应用。<br><br></p>
<hr>
<h3 id="下载_goagent_并上传至_Google_App_Engine">下载 goagent 并上传至 Google App Engine</h3>
<ul>
<li>去Github下载 <a href="https://github.com/goagent/goagent" target="_blank" rel="external"><strong>goagent客户端</strong></a> 并解压，目前是3.2.3版</li>
<li>修改<code>\local\proxy.ini</code>，把其中 appid = goagent 中的 goagent 改成你之前申请的应用的 appid 后保存。<br><center> <img src="http://alexyoung.qiniudn.com/GFW9.jpg" alt=""> <center></center></center></li>
</ul>
<p>如果要使用多个appid，appid之间用<code>|</code>隔开，如：<code>appid1|appid2|appid3</code>，每个 appid 必须确认上传成功才能使用</p>
<blockquote>
<p>[gae]<br>appid = appid1|appid2|appid3</p>
</blockquote>
<ul>
<li>双击 server 文件夹下的 uploader.bat， 依次输入你的Application ID，邮箱地址和密码（如果设置了Gmail的两步验证请输入两步验证中生成的16位密码，即为独立应用单独生成的随机16位字符，而不是你的邮箱密码，Gmail两步验证在这里<a href="http://www.cooear.com/archives/168.htm" target="_blank" rel="external">详细介绍</a>）<br><center> <img src="http://alexyoung.qiniudn.com/GFW10.jpg" alt=""> <center></center></center></li>
</ul>
<p><br></p>
<ul>
<li>看到下面的提示便上传成功。<br><center> <img src="http://alexyoung.qiniudn.com/GFW6.jpg" alt=""> <center></center></center></li>
</ul>
<p><strong>注意</strong>：如果输完账户密码后出现：<code>AttributeError: can’t set attribute</code> 的问题，可尝试进入 <a href="https://www.google.com/settings/security" target="_blank" rel="external"><strong>Google 安全性</strong></a> 页面里看到了『帐户所授权限』 中的『不够安全的应用的访问权限』，进入设置之后，点击『启用』即可。<br><br></p>
<hr>
<h3 id="Chrome下安装Switchysharp">Chrome下安装Switchysharp</h3>
<ul>
<li>去chrome的<a href="https://chrome.google.com/webstore/category/home" target="_blank" rel="external">应用商店</a>安装Switchysharp</li>
<li><p>下载好后Switchysharp图标会出现在chrome的右上角，点击选项<br><center> <img src="http://alexyoung.qiniudn.com/GFW11.jpg" alt=""> <center></center></center></p>
</li>
<li><p>在导入/导出界面，选择从文件恢复，选中<code>\local\SwitchyOptions.bak</code>确认导入<br><center> <img src="http://alexyoung.qiniudn.com/GFW8.jpg" alt=""> <center></center></center></p>
</li>
<li><p>成功导入后，想去外网时选择自动切换模式即可，不访问时便选择直接连接<br><center> <img src="http://alexyoung.qiniudn.com/GFW12.jpg" alt=""> <center></center></center></p>
</li>
</ul>
<p><strong>注意</strong>：使用Firefox浏览器和opera浏览器的同学去<a href="https://github.com/goagent/goagent/blob/wiki/InstallGuide.md" target="_blank" rel="external"><strong>这里</strong></a>看配置插件教程。<br><br></p>
<hr>
<h3 id="最后">最后</h3>
<p>恭喜你已经成功配置好了插件，想去外网时记得先打开<code>local\goagent.exe</code>，最好管理员权限打开，如果嫌每次都打开麻烦，设置开机自动启动也OK，浏览器会根据你浏览的具体界面选择代理方式，一键都不用便可翻墙，这便是此方案便捷的地方。</p>
<p>有兴趣的同学可以研究研究<a href="http://shadowsocks.cn/" target="_blank" rel="external">ShadowSocks</a>，ShadowSocks服务器端提供了各种版本，如Python、Nodejs、Go、C libev等等，安装配置过程极其简单。而用户端则可以在windows、mac、iOS和android上轻松运行。首先，当然你需要有一个shadowsocks账号。(￣∇￣;)</p>
]]></content>
    <summary type="html">
    <![CDATA[不要问我为什么翻墙，因为墙就在那里。]]>
    
    </summary>
    
      <category term="skill" scheme="http://alexyyek.github.io/tags/skill/"/>
    
      <category term="黑科技" scheme="http://alexyyek.github.io/categories/%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对象和引用]]></title>
    <link href="http://alexyyek.github.io/2014/12/29/Reference/"/>
    <id>http://alexyyek.github.io/2014/12/29/Reference/</id>
    <published>2014-12-29T13:43:15.000Z</published>
    <updated>2014-12-30T13:08:38.000Z</updated>
    <content type="html"><![CDATA[<p>Java中对象和引用的东西之前看了不少，但一方面因为网上知识过于繁杂，不能很好的梳理，另一方面不同的博客讲解专业程度不一样，可能会导致一定的误解。此篇博客争取以最精炼，最具条理的方式理清其中的难点和疑点。</p>
<h2 id="对象和引用">对象和引用</h2>
<h3 id="对象">对象</h3>
<blockquote>
<p>《Java编程思想》：按照通俗的说法，每个对象都是某个类（class）的一个实例（instance），这里，‘类’就是‘类型’的同义词。</p>
</blockquote>
<p><strong>理解本质</strong>：对象是类的实例。例如<a href="http://ww2.sinaimg.cn/bmiddle/53539f83jw1emh2fiopjtj20u01hc4qp.jpg" target="_blank" rel="external">Alex</a>是人类，Alex是对象，就是“人类”的实例。对象一般存储在堆中。</p>
<h3 id="引用">引用</h3>
<blockquote>
<p>《Java编程思想》： 每种编程语言都有自己的数据处理方式。有些时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C/C++里的指针）来操作对象。所有这些在 Java 里都得到了简化，一切都被视为对象。因此，我们可采用一种统一的语法。尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。</p>
</blockquote>
<p><strong>理解本质</strong>：引用是指向对象的标识符。可以理解对象是一个个气球，我们通过引用这条绳子和它链接。引用存储在速度更快的堆栈中。 </p>
<h3 id="实例讲解">实例讲解</h3>
<p>首先看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>{</div><div class="line">	String name;</div><div class="line">	String sex;</div><div class="line">	<span class="keyword">int</span> age;</div><div class="line">	</div><div class="line">	<span class="comment">//构造函数</span></div><div class="line">	<span class="keyword">public</span> <span class="title">People</span>(){</div><div class="line">	</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">People</span>(String name, String sex, <span class="keyword">int</span> age){</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.sex = sex;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>people是一个类，包含属性 name、sex、age，有了这个类，我们创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">People one = <span class="keyword">new</span> People();</div></pre></td></tr></table></figure>

<p>这条语句的动作称为创建一个对象，它包含了四个动作:</p>
<ol>
<li>右边的new People，是以Pelple类为模板，在堆空间中创建一个People类对象</li>
<li>结尾的()，在对象创建后，立刻调用People类的构造函数，对刚生成的对象初始化。这个例子中包含了构造函数，如果没写，java会自动帮你补上。</li>
<li>左侧的People one创建了一个People类的引用变量。即one是指向People对象的引用。</li>
<li>“=”操作符使对象引用<strong>指向</strong>刚创建的People对象。注意是指向，不是赋值。</li>
</ol>
<p>可以将上面的话拆成两句，效果一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">People one;</div><div class="line">one = <span class="keyword">new</span> People();</div></pre></td></tr></table></figure>

<p>如果只执行了第一条语句，还没执行第二条，此时创建的引用变量one还没指向任何一个对象，它的值是null。引用变量可以指向某个对象，或者为null。然后看下面这段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">People two;</div><div class="line">two = one;</div></pre></td></tr></table></figure>

<p>首先又创建了一个引用two，此时two指向null，第二句将one指向的地址传给two，发生了复制行为，注意这里复制的是<code>对象引用</code>，此时two也指向one所指的对象，具体如何传递后面会讲。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">two = <span class="keyword">new</span> People();</div></pre></td></tr></table></figure>

<p>这句将two指向了一个新的对象，所以可以分析如下两条性质：</p>
<ol>
<li>一个引用可以指向0个或1个对象（一根绳子可以不系汽球，也可以系一个汽球）；</li>
<li>一个对象可以有N个引用指向它（可以有N条绳子系住一个汽球）。 </li>
</ol>
<p>如果发生这样的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">People one = <span class="keyword">new</span> People(<span class="string">"张三"</span>);</div><div class="line">People two = <span class="keyword">new</span> People(<span class="string">"李四"</span>);</div><div class="line">one = two;</div></pre></td></tr></table></figure>

<p>按上面的逻辑，引用one先指向对象“张三”，然后又指向了引用two指向的“李四”，所以最后one和two都指向对象“李四”，问题是之前的对象“张三”呢？还在堆里么？</p>
<p>多数书里说，它被Java的垃圾回收机制回收了。这不确切。</p>
<blockquote>
<p>正确地说，它已成为垃圾回收机制的处理对象。至于什么时候真正被回收，那要看垃圾回收机制的心情了。 </p>
</blockquote>
<p><br></p>
<hr>
<h3 id="参数传递">参数传递</h3>
<p>参数传递是个大坑，面试时常常会被问及，但其实并不难，看透本质即可。</p>
<blockquote>
<p>《thinking in Java》：When you’re passing primitives into a method，you get a distinct copy of the primitive. When you’re passing a reference into a method, you get a copy of the reference.</p>
</blockquote>
<p><strong>本质</strong>：不管JAVA参数类型是什么，一律传递参数的<strong><code>副本</code></strong></p>
<p><br></p>
<h4 id="例一">例一</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		<span class="keyword">boolean</span> test = <span class="keyword">true</span>;</div><div class="line">		System.out.println(<span class="string">"before test() :"</span> + test);</div><div class="line">		test(test);</div><div class="line">		System.out.println(<span class="string">"after test() :"</span> + test);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="keyword">boolean</span> test){</div><div class="line">		test = !test;</div><div class="line">		System.out.println(<span class="string">"In test() :"</span> + test);</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><strong>分析</strong>：首先声明一个基本类型为boolean的对象true，并用test指向它，在函数test内，引用test将值的副本传递进去，所以原本的test不改变，在test内输出false，而after test仍然还是true。<br><strong>注意</strong>：基本类型传值的副本，对象变量传引用的副本<br><br></p>
<h4 id="例二">例二</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		StringBuffer string = <span class="keyword">new</span> StringBuffer(<span class="string">"Hello"</span>);</div><div class="line">		test(string);</div><div class="line">		System.out.println(string);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>(StringBuffer str){</div><div class="line">		str.append(<span class="string">",world!"</span>);</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><strong>分析</strong>：首先声明一个stringbuffer类型的对象型变量，string指向对象Hello，在test内将string的引用副本传给str，因此string和str都在栈内指向同一个堆地址，只不过所处栈地址不同。test内改变了str指向的对象，因此string指向的对象也改变了，变成Hello,world!.<br><br></p>
<h4 id="例三">例三</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class value{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">15</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dataType</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		dataType type = <span class="keyword">new</span> dataType();</div><div class="line">		type.first();</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span>(){</div><div class="line">		<span class="keyword">int</span> i = <span class="number">5</span>;</div><div class="line">		value v = <span class="keyword">new</span> value();</div><div class="line">		v.i = <span class="number">25</span>;</div><div class="line">		second(v, i);</div><div class="line">		System.out.println(v.i);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span>(value v, <span class="keyword">int</span> i){</div><div class="line">		i = <span class="number">0</span>;</div><div class="line">		v.i = <span class="number">20</span>;</div><div class="line">		value val = <span class="keyword">new</span> value();</div><div class="line">		v = val;</div><div class="line">		System.out.println(v.i + <span class="string">" "</span> + i);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li><p>在first内，首先程序在栈内存中开辟了一块地址编号为AD9500内存空间，用于存放<code>v</code>的引用地址，里边放的值是堆内存中的一个地址，示例中的值为BE2500<br><center> <img src="http://alexyoung.qiniudn.com/QQ图片20141229225902.png" alt=""> <center></center></center></p>
</li>
<li><p>调用函数second，程序在栈内开辟地址为AD9600内存空间存放v的副本，v的副本同样指向堆地址为BE2500的空间，然后将v的副本传入second，并且在second内，将v的副本所指对象<code>i=25</code>改为<code>i=20</code><br><center> <img src="http://alexyoung.qiniudn.com/QQ图片20141229225924.png" alt=""> <center></center></center></p>
</li>
<li><p>在second内，程序新建一个对象放在地址为BE2600的堆内，并用新的引用val（栈中地址为AD9700）指向它，所以second中输出结果为：15 0<br><center> <img src="http://alexyoung.qiniudn.com/QQ图片20141229225934.png" alt=""> <center></center></center></p>
</li>
<li><p>但原v并未改变，改变的只是它传入second的副本，所以在first中仍然输出<code>i=20</code><br><br></p>
</li>
</ol>
<hr>
<p><strong>PS</strong>：在JAVA里，“=”不能被看成是一个赋值语句，它不是在把一个对象赋给另外一个对象，它的执行过程实质上是将右边对象的地址传给了左边的引用，使得左边的引用指向了右边的对象。JAVA表面上看起来没有指针，但它的引用其实质就是一个指针，引用里面存放的并不是对象，而是该对象的地址，使得该引用指向了对象。在JAVA里，“=”语句不应该被翻译成赋值语句，因为它所执行的确实不是一个赋值的过程，而是一个传地址的过程，被译成赋值语句会造成很多误解，译得不准确。 </p>
]]></content>
    <summary type="html">
    <![CDATA[When you're passing primitives into a method，you get a distinct copy of the primitive. When you're passing a reference into a method, you get a copy of the reference.]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA基本类型和包装类]]></title>
    <link href="http://alexyyek.github.io/2014/12/29/wrapperClass/"/>
    <id>http://alexyyek.github.io/2014/12/29/wrapperClass/</id>
    <published>2014-12-29T09:03:38.000Z</published>
    <updated>2014-12-29T14:20:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="JAVA的包装类">JAVA的包装类</h2>
<p>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)，有些地方也翻译为外覆类或数据类型类，如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">基本类型</th>
<th style="text-align:center">大小</th>
<th style="text-align:center">包装器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">/</td>
<td style="text-align:center">Boolean</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">16bit</td>
<td style="text-align:center">Character</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">8bit</td>
<td style="text-align:center">Byte</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">16bit</td>
<td style="text-align:center">Short</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">32bit</td>
<td style="text-align:center">Integer</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">64bit</td>
<td style="text-align:center">Long</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">32bit</td>
<td style="text-align:center">Float</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">64bit</td>
<td style="text-align:center">Double</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">/</td>
<td style="text-align:center">Void</td>
</tr>
</tbody>
</table>
<p>Java中的包装器类有两个主要的目的： </p>
<ol>
<li>提供一种机制，将基本值“包装”到对象中，从而使基本值能够包含在为对象而保留的操作中，比如添加到Collections 中，或者从带对象返回值的方法中返回。注意，java5增加了自动装箱和拆箱，程序员过去需手工执行的许多包装操作，现在可以由java自动处理了。 </li>
<li>为基本值提供分类功能。这些功能大多数于各种转换有关：在基本值和String对象间相互转换，在基本值和String对象之间按不同基数转换，如二进制、八进制和十六进制。 </li>
</ol>
<h3 id="包装类共同的方法">包装类共同的方法</h3>
<ul>
<li>带有<code>基本值参数</code>并创建包装类对象的构造函数。如利用Integer包装类创建对象，Integer obj=new Integer(145);</li>
<li>带有<code>字符串参数</code>并创建包装类对象的构造函数.如：new Integer(“-45.36”);</li>
<li>可生成对象基本值的<code>typeValue</code>方法，如：obj.intValue();</li>
<li>将字符串转换为基本值的<code>parseType</code>方法，如：Integer.parseInt(args[0]);</li>
<li>生成哈稀表代码的<code>hashCode</code>方法，如：obj.hasCode();</li>
<li>对同一个类的两个对象进行比较的<code>equals()</code>方法，如：obj1.eauqls(obj2);</li>
<li>生成字符串表示法的<code>toString()</code>方法，如：obj.toString().<br><br></li>
</ul>
<hr>
<h3 id="装箱和拆箱">装箱和拆箱</h3>
<p>自动装箱和拆箱问题是Java中一个老生常谈的问题了，今天就来一些看一下装箱和拆箱中的若干问题。本文先讲述装箱和拆箱最基本的东西，再来看一下面试笔试中经常遇到的与装箱、拆箱相关的问题。<br><br></p>
<h4 id="定义">定义</h4>
<p>在前面的文章中提到，Java为每种基本数据类型都提供了对应的包装器类型，至于为什么会为每种基本数据类型提供包装器类型在此不进行阐述，有兴趣的朋友可以查阅相关资料。在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</div></pre></td></tr></table></figure>

<p>而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</div></pre></td></tr></table></figure>

<p>这个过程中会自动根据数值创建对应的 Integer对象，这就是装箱。<br>那什么是拆箱呢？顾名思义，跟装箱对应，就是自动将包装器类型转换为基本数据类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer i = <span class="number">10</span>; <span class="comment">//装箱</span></div><div class="line"><span class="keyword">int</span> index = i;  <span class="comment">//拆箱</span></div></pre></td></tr></table></figure>

<p>简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</p>
<p>注意：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer test = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">int</span> f = test.intValue();</div></pre></td></tr></table></figure>

<p>上面的代码编写时不会报错，但编译是通不过的。<br><br></p>
<h4 id="实现机制">实现机制</h4>
<p>我们就以Interger类为例，下面看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">    Integer i = <span class="number">10</span>; <span class="comment">//装箱</span></div><div class="line">    <span class="keyword">int</span> index = i;  <span class="comment">//拆箱</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>反编译class文件之后得到如下内容：</p>
<p><center> <img src="http://alexyoung.qiniudn.com/101641567956500.jpg" alt=""> <center></center></center></p>
<p>从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是Integer的<code>valueOf(int)</code>方法。而在拆箱的时候自动调用的是Integer的<code>intValue</code>方法。</p>
<p>其他的也类似，比如Double、Character，不相信的朋友可以自己手动尝试一下。</p>
<p>因此可以用一句话总结装箱和拆箱的实现过程：</p>
<p><strong>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的xxxValue方法实现的。（xxx代表对应的基本数据类型）。</strong></p>
<p><br></p>
<hr>
<p><br></p>
<h4 id="面试问题">面试问题</h4>
<p>虽然大多数人对装箱和拆箱的概念都清楚，但是在面试和笔试中遇到了与装箱和拆箱的问题却不一定会答得上来。下面列举一些常见的与装箱/拆箱有关的面试题，建议先自己尝试编译看源码做做。</p>
<ul>
<li>下面这段代码的输出结果是什么？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Integer i1 = <span class="number">100</span>;</div><div class="line">        Integer i2 = <span class="number">100</span>;</div><div class="line">        Integer i3 = <span class="number">200</span>;</div><div class="line">        Integer i4 = <span class="number">200</span>;</div><div class="line">        </div><div class="line">        System.out.println(i1==i2);</div><div class="line">        System.out.println(i3==i4);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>也许有些朋友会说都会输出false，或者也有朋友会说都会输出true。这里注意“==”和“equal”的区别：<br><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">基本类型</th>
<th style="text-align:center">==</th>
<th style="text-align:center">equals</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">字符串变量</td>
<td style="text-align:center">对象在内存中的首地址</td>
<td style="text-align:center">字符串内容</td>
</tr>
<tr>
<td style="text-align:center">非字符串变量</td>
<td style="text-align:center">对象在内存中的首地址</td>
<td style="text-align:center">对象在内存中的首地址</td>
</tr>
<tr>
<td style="text-align:center">基本类型</td>
<td style="text-align:center">值</td>
<td style="text-align:center">不可用</td>
</tr>
<tr>
<td style="text-align:center">包装类</td>
<td style="text-align:center">地址</td>
<td style="text-align:center">内容</td>
</tr>
</tbody>
</table>
<p>结果：<br>true<br>false</p>
<p>为什么会出现这样的结果？输出结果表明 i1 和 i2 指向的是同一个对象，而 i3 和 i4 指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的<code>valueOf</code>方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span>(<span class="keyword">int</span> i) {</div><div class="line">        <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> && i &lt;= IntegerCache.high)</div><div class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在 [-128,127] 之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p>
<p>上面的代码中 i1 和 i2 的数值为100，因此会直接从cache中取已经存在的对象，所以 i1 和 i2 指向的是同一个对象，而 i3 和 i4 则是分别指向不同的对象。</p>
<ul>
<li>下面这段代码的输出结果是什么？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Double i1 = <span class="number">100.0</span>;</div><div class="line">        Double i2 = <span class="number">100.0</span>;</div><div class="line">        Double i3 = <span class="number">200.0</span>;</div><div class="line">        Double i4 = <span class="number">200.0</span>;</div><div class="line">        </div><div class="line">        System.out.println(i1==i2);</div><div class="line">        System.out.println(i3==i4);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>也许有的朋友会认为跟上面一道题目的输出结果相同，但是事实上却不是。实际输出结果为：<br>false<br>false<br>至于具体为什么，读者可以去查看Double类的<code>valueOf</code>的实现。</p>
<p>在这里只解释一下为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p>
<p>注意，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的，Double、Float的valueOf方法的实现是类似的。</p>
<ul>
<li>下面这段代码的输出结果是什么？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Boolean i1 = <span class="keyword">false</span>;</div><div class="line">        Boolean i2 = <span class="keyword">false</span>;</div><div class="line">        Boolean i3 = <span class="keyword">true</span>;</div><div class="line">        Boolean i4 = <span class="keyword">true</span>;</div><div class="line">         </div><div class="line">        System.out.println(i1==i2);</div><div class="line">        System.out.println(i3==i4);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果为：<br>true<br>true<br>至于为什么是这个结果，同样地，看了Boolean类的源码也会一目了然。下面是Boolean的valueOf方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span>(<span class="keyword">boolean</span> b) {</div><div class="line">        <span class="keyword">return</span> (b ? TRUE : FALSE);</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>至于TRUE和FALSE的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line">     * The {@code Boolean} object corresponding to the primitive</div><div class="line">     * value {@code true}.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line">     * The {@code Boolean} object corresponding to the primitive</div><div class="line">     * value {@code false}.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</div></pre></td></tr></table></figure>

<ul>
<li>谈谈Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。<br>当然，这个题目属于比较宽泛类型的。但是要点一定要答上，我总结一下主要有以下这两点区别：</li>
</ul>
<p>1）第一种方式不会触发自动装箱的过程；而第二种方式会触发；</p>
<p>2）在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。</p>
<ul>
<li>下面这段代码的输出结果是什么？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Integer a = <span class="number">1</span>;</div><div class="line">        Integer b = <span class="number">2</span>;</div><div class="line">        Integer c = <span class="number">3</span>;</div><div class="line">        Integer d = <span class="number">3</span>;</div><div class="line">        Integer e = <span class="number">321</span>;</div><div class="line">        Integer f = <span class="number">321</span>;</div><div class="line">        Long g = <span class="number">3</span>L;</div><div class="line">        Long h = <span class="number">2</span>L;</div><div class="line">         </div><div class="line">        System.out.println(c==d);</div><div class="line">        System.out.println(e==f);</div><div class="line">        System.out.println(c==(a+b));</div><div class="line">        System.out.println(c.equals(a+b));</div><div class="line">        System.out.println(g==(a+b));</div><div class="line">        System.out.println(g.equals(a+b));</div><div class="line">        System.out.println(g.equals(a+h));</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>先别看输出结果，读者自己想一下这段代码的输出结果是什么。这里面需要注意的是：当 “==” 运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals方法并不会进行类型转换。明白了这2点之后，上面的输出结果便一目了然：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">false</span></div><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">false</span></div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>

<p>第一个和第二个输出结果没有什么疑问。第三句由于  a+b 包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等。而对于c.equals(a+b)会先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较。同理对于后面的也是这样，不过要注意倒数第二个和最后一个输出的结果（如果数值是int类型的，装箱过程调用的是Integer.valueOf；如果是long类型的，装箱调用的Long.valueOf方法）。</p>
]]></content>
    <summary type="html">
    <![CDATA[Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，统称为包装类(Wrapper Class).]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[教育网配置IPV6回避收费及轻松翻墙]]></title>
    <link href="http://alexyyek.github.io/2014/12/27/ipv6/"/>
    <id>http://alexyyek.github.io/2014/12/27/ipv6/</id>
    <published>2014-12-27T09:06:18.000Z</published>
    <updated>2014-12-30T02:20:08.000Z</updated>
    <content type="html"><![CDATA[<p>明光村职业技术学院终于还是没能逃离收费的命运，虽然还有半年就卷铺盖跑路了，但面对每个月只给10G外网流量，100块都不给我的抠门政策，废话不多说，直接上干货。</p>
<h2 id="目录">目录</h2>
<h3 id="设置IPV6">设置IPV6</h3>
<ul>
<li>首先安装ipv6，这个是基础，win7默认安装，xp运行命令<code>ipv6 install</code>。访问网站 <a href="http://6rank.edu.cn/" target="_blank" rel="external">http://6rank.edu.cn</a> 看看IPv6配置是否正常。更详细介绍请自行百度。</li>
<li>打开网络和共享中心 → 更改适配器设置 → 本地连接 → 属性 → 双击Internet协议版本6（IPV6），设置首选DNS服务器为：<strong>2001:778::37</strong></li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/QQ图片20141227164226.jpg" alt=""> <center></center></center></p>
<p><a href="http://ipv6.lt/nat64_en.php" target="_blank" rel="external"><strong>原理</strong></a>：NAT64服务器，能将所有ipv4的网站都转化对应的ipv6地址，也相当于一种代理。晚上速度比较受影响，日间科研完全可以满足。</p>
<p><center> <img src="http://alexyoung.qiniudn.com/graph_relay.png" alt=""> <center></center></center></p>
<ul>
<li>将Internet协议版本4（IPV4）前的对勾去掉，确定后退出，即可只通过IPV6访问网站，不用登陆 <a href="http://10.3.8.211/" target="_blank" rel="external">http://10.3.8.211/</a>，此时流量不计入已使用流量</li>
</ul>
<h3 id="设置hosts翻墙">设置hosts翻墙</h3>
<p>如果你是通过代理访问 <a href="https://www.youtube.com/" target="_blank" rel="external">youtube</a>，往往速度很不给力。如果是教育网有ipv6的话，那就好办了，看1080P流畅的一比，而且是教育网使用ipv6是不计费的。方法很简单，就是修改hosts.</p>
<ul>
<li><p>访问 <a href="http://serve.netsh.org/pub/ipv6-hosts/" target="_blank" rel="external"><strong>网站</strong></a>，勾选你所要的服务，如下图，点击立刻获取。<br><center> <img src="http://alexyoung.qiniudn.com/QQ图片20141227165359.jpg" alt=""> <center></center></center></p>
</li>
<li><p>将生成的hosts文件内容贴到你的hosts文件里并保存：<code>C:\Windows\System32\drivers\etc</code></p>
</li>
<li>最后总是以<strong>HTTPS</strong>的方式打开Youtube、facebook，如：<a href="https://www.youtube.com/" target="_blank" rel="external">https://www.youtube.com/</a>，<a href="https://www.facebook.com/" target="_blank" rel="external">https://www.facebook.com/</a><br>如果嫌麻烦，可以 <a href="http://blog.netsh.org/posts/chrome-http-redirect-https_369.netsh.html" target="_blank" rel="external"><strong>点这里</strong></a> 设置chrome强制http定向到https</li>
</ul>
<p>PS.如果某天发生访问不了例如youtube的情况，是因为ipv6地址会经常失效，也可能是地址变更，或者河蟹出现，记得更新hosts。<br>访问youtube看1080P无压力</p>
<p><img src="http://alexyoung.qiniudn.com/QQ图片20141227161806.jpg" alt=""></p>
<p><a href="https://code.google.com/p/ipv6-hosts/" target="_blank" rel="external">https://code.google.com/p/ipv6-hosts/</a></p>
<p><strong>PS</strong>：本方法只是临时解决方案，目的是培养大家合理利用搜索引擎，解决实际问题的意识，欢迎大家提出不同的改进意见和更完善的解决方案。</p>
]]></content>
    <summary type="html">
    <![CDATA[IPV6谁用谁知道]]>
    
    </summary>
    
      <category term="skill" scheme="http://alexyyek.github.io/tags/skill/"/>
    
      <category term="黑科技" scheme="http://alexyyek.github.io/categories/%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[红黑树]]></title>
    <link href="http://alexyyek.github.io/2014/12/23/RBTree/"/>
    <id>http://alexyyek.github.io/2014/12/23/RBTree/</id>
    <published>2014-12-23T08:13:09.000Z</published>
    <updated>2014-12-25T08:13:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="红黑树">红黑树</h2>
<p>红黑树(Red-Black Tree，简称R-B Tree)，它一种特殊的二叉查找树。<br>红黑树是特殊的二叉查找树，意味着它满足二叉查找树的特征：任意一个节点所包含的键值，大于等于左孩子的键值，小于等于右孩子的键值。<br>除了具备该特性之外，红黑树还包括许多额外的信息。</p>
<h3 id="性质">性质</h3>
<p>红黑树的每个节点上都有存储位表示节点的颜色，颜色是红(Red)或黑(Black)。<br>红黑树的特性:</p>
<ol>
<li>每个节点或者是黑色，或者是红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ol>
<p>关于它的特性，需要注意的是：<br>第一，特性(3)中的叶子节点，是只为空(NIL或null)的节点。<br>第二，特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
<p>红黑树结构图类似：</p>
<p><center> <img src="http://alexyoung.qiniudn.com/8394323_13013004048ddW.jpg" alt=""> <center><br><br></center></center></p>
<hr>
<h3 id="基本操作">基本操作</h3>
<p>从某个结点x出发（不包括该结点）到达一个叶节点的任意一条路径上，黑色结点的个数成为该结点x的黑高度，用<code>bh(x)</code>表示。根据性质5黑高度概念是明确定义的，红黑树的黑高度定义为其根节点的黑高度。</p>
<p><strong>性质</strong>：一颗有n个内结点的红黑树的高度至多为<code>2lg(n+1)</code>，红黑树的插入和删除操作都可以在<code>O(lgn)</code>时间内完成。<br><br></p>
<h4 id="旋转">旋转</h4>
<p>红黑树的旋转分为左旋和右旋，因为在插入和删除基本操作中可能改变树的结构，从而破坏红黑树的基本性质，所以需要一定的旋转操作。</p>
<p><center> <img src="http://alexyoung.qiniudn.com/251733282013849.jpg" alt=""> <center></center></center></p>
<p>从图上可以看到，左旋操作中将Y节点顶替其父节点X，之前的父节点X成为Y的左子树，Y的右子树不动，Y的左子树移到X的右子树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span>(Node&lt;T&gt; x){</div><div class="line">		<span class="comment">//consider the left child of y</span></div><div class="line">		Node&lt;T&gt; y = x.right;</div><div class="line">		x.right = y.left;</div><div class="line">		<span class="keyword">if</span> (y.left != <span class="keyword">null</span>) {</div><div class="line">			y.left.parent = x;</div><div class="line">		}</div><div class="line">		<span class="comment">//consider the node y</span></div><div class="line">		y.parent = x.parent;</div><div class="line">		<span class="keyword">if</span> (x.parent == <span class="keyword">null</span>) {</div><div class="line">			root = y;</div><div class="line">		}<span class="keyword">else</span>{</div><div class="line">			<span class="keyword">if</span>(x == x.parent.left)</div><div class="line">			x.parent.left = y;</div><div class="line">			<span class="keyword">else</span> </div><div class="line">			x.parent.right = y;</div><div class="line">		}</div><div class="line">		<span class="comment">//consider the Node x</span></div><div class="line">		y.left = x;</div><div class="line">		x.parent = y;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>右旋同理，是左旋的逆操作：</p>
<p><center> <img src="http://alexyoung.qiniudn.com/251735527958942.jpg" alt=""> <center></center></center></p>
<p><br></p>
<hr>
<p><br></p>
<h4 id="插入">插入</h4>
<p>将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过”旋转和重新着色”等一系列操作来修正该树，使之重新成为一颗红黑树。详细描述如下：<br><strong>第一步</strong>： 将红黑树当作一颗二叉查找树，将节点插入。<br>红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。</p>
<p><strong>第二步</strong>：将插入的节点着色为”红色”。<br>为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 注意：这里叶子节点，是指为空的叶子节点！<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p>将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。</p>
<p><strong>第三步</strong>：通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。<br>    第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？<br>    对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。<br>    对于”特性(2)”，唯一可能违背的情况是插入的节点为根节点。<br>    对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。<br>    对于”特性(4)”，如果插入节点的父节点是红色的，就有可能违背！<br>    那接下来，想办法使之”满足特性”，就可以将树重新构造成红黑树了。</p>
<p>插入操作代码见最后的完整代码，下面主要研究插入后的修正操作：</p>
<ul>
<li>修复情况1：当前结点的父结点是红色，祖父结点的另一个子结点（叔叔结点）是红色。</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_insert_case_3.png" alt=""> <center></center></center></p>
<p>父节点和叔叔节点都是RED，则祖父节点肯定存在，且为BLACK，改变祖父节点、父节点和叔叔节点的颜色，将N上移到祖父节点继续迭代。</p>
<ul>
<li>修复情况2：当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的右孩子</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_insert_case_4.png" alt=""> <center></center></center></p>
<p>此时当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。</p>
<ul>
<li>插入修复情况3：当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的左孩子</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_insert_case_5.png" alt=""> <center></center></center></p>
<p>情况2通过一个左旋转变成情况三，因为节点N和父节点P都是红色的，所以旋转不影响数的黑高度。情况三中改变一些节点颜色，然后通过一个右旋解决。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertFixUp</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="comment">//	若父节点存在，并且父节点的颜色是红色</span></div><div class="line">		<span class="keyword">while</span>(node.parent != <span class="keyword">null</span> && isRed(node.parent)) {</div><div class="line">			<span class="comment">// 若父节点”是“祖父节点的左孩子</span></div><div class="line">			<span class="keyword">if</span> (parentOf(node) == parentOf(parentOf(node)).left) {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(parentOf(node)).right;	 <span class="comment">//叔叔节点，即父节点的兄弟节点</span></div><div class="line">				<span class="comment">//情况一：如果叔叔节点是红色，因为父节点是红色，显然祖父节点是黑色</span></div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {									</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					node = parentOf(parentOf(node));</div><div class="line">				}</div><div class="line">				<span class="keyword">else</span> {	</div><div class="line">					<span class="keyword">if</span> (parentOf(node).right == node) {	<span class="comment">//情况二：叔叔节点是黑色，而Z是右孩子</span></div><div class="line">						 node = parentOf(node);</div><div class="line">						 leftRotate(node);</div><div class="line">					}</div><div class="line">					</div><div class="line">					parentOf(node).color = BLACK;	<span class="comment">//情况三：叔叔节点黑色，Z是左孩子</span></div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					rightRotate(parentOf(parentOf(node)));</div><div class="line">				}</div><div class="line">			}</div><div class="line">			<span class="comment">// 若父节点”是“祖父节点的右孩子</span></div><div class="line">			<span class="keyword">else</span> {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(parentOf(node)).left;</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					node = parentOf(parentOf(node));</div><div class="line">				}</div><div class="line">				<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">if</span> (parentOf(node).left == node) {</div><div class="line">						 node = parentOf(node);</div><div class="line">						 rightRotate(node);</div><div class="line">					}</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					leftRotate(parentOf(parentOf(node)));</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="comment">/* 1.防止插入节点为根节点        </span></div><div class="line">		 * 2.防止树深度较低时grandparent为root节点,从而在情况一uncle为red时，把root节点置为red 	 */</div><div class="line">		<span class="keyword">if</span> (node == root) {</div><div class="line">			node.color = BLACK;</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<p><br></p>
<h4 id="删除">删除</h4>
<p>将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：<br><strong>第一步</strong>：将红黑树当作一颗二叉查找树，将节点删除。<br>这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：</p>
<ol>
<li>被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。</li>
<li>被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</li>
<li>被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了,从而转换成为情况1或情况2</li>
</ol>
<p><strong>第二步</strong>：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。<br>因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p>
<p>删除操作代码见最后的完整代码，下面主要研究插入后的修正操作：<br>当删除节点是红色的，红黑性质仍然得以保存，故考虑删除节点是黑色的情况。</p>
<ul>
<li>修复情况1：兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)。</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_delete_case_2.png" alt=""> <center></center></center></p>
<p>因为兄弟节点必有黑孩子，可以改变兄弟节点S和父节点P的颜色，在对P做一次左旋，从而转换为情形2-4，图中转换为情况2</p>
<ul>
<li>修复情况2：兄弟是黑色且兄弟节点的两个子节点全为黑色。</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_delete_case_4.png" alt=""> <center></center></center></p>
<p>因为S节点和S的两个子节点都是黑色，故需要从S支数去除一层黑色，来平衡黑高度，故将S的颜色改为RED，并将N直到P上，继续迭代。</p>
<ul>
<li>修复情况3：兄弟节点是黑色，兄弟的左子是红色，右子是黑色。</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_delete_case_5.png" alt=""> <center></center></center></p>
<p>交换兄弟节点S与其左孩子的颜色，然后对S进行右旋，现在N的新兄弟S是一个有红色右孩子的黑节点，进入情况4</p>
<ul>
<li>修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意。</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_delete_case_6.png" alt=""> <center></center></center></p>
<p>修改某些节点颜色，并对P做一次左旋，将N置为根，循环结束。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeFixUp</span>(Node&lt;T&gt; node){</div><div class="line">	</div><div class="line">		<span class="keyword">while</span> (node != <span class="keyword">this</span>.root && node.color == BLACK) {</div><div class="line">			<span class="comment">// 若节点是父节点的左孩子</span></div><div class="line">			<span class="keyword">if</span> (node == parentOf(node).left) {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(node).right;		</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {		<span class="comment">//情况一：叔叔节点为红色</span></div><div class="line">					parentOf(node).color = RED;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					leftRotate(parentOf(node));</div><div class="line">					uncle = parentOf(node).right;</div><div class="line">				}</div><div class="line">				<span class="comment">//情况二：叔叔节点为黑色，且有两个黑孩子</span></div><div class="line">				<span class="keyword">if</span> (isBlack(uncle.left) && isBlack(uncle.right)) {</div><div class="line">					uncle.color = RED;</div><div class="line">					node = parentOf(node);</div><div class="line">				}<span class="keyword">else</span> {										</div><div class="line">					<span class="keyword">if</span> (isBlack(uncle.right)) {		<span class="comment">//情况三：叔叔节点的左孩子为红色，右孩子为黑色</span></div><div class="line">						uncle.left.color = BLACK;</div><div class="line">						uncle.color = RED;</div><div class="line">						rightRotate(uncle);</div><div class="line">						uncle = parentOf(node).right;</div><div class="line">					}</div><div class="line">					uncle.color = parentOf(node).color;		<span class="comment">//情况四：叔叔节点的右孩子为红色</span></div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.right.color = BLACK;</div><div class="line">					leftRotate(parentOf(node));</div><div class="line">					node = root;</div><div class="line">				}</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(node).left;</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {</div><div class="line">					parentOf(node).color = RED;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					rightRotate(parentOf(node));</div><div class="line">					uncle = parentOf(node).left;</div><div class="line">				}</div><div class="line">				<span class="keyword">if</span> (isBlack(uncle.left) && isBlack(uncle.right)) {</div><div class="line">					uncle.color = RED;</div><div class="line">					node = parentOf(node);</div><div class="line">				}<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">if</span> (isBlack(uncle.left)) {</div><div class="line">						uncle.right.color = BLACK;</div><div class="line">						uncle.color = RED;</div><div class="line">						leftRotate(uncle);</div><div class="line">						uncle = parentOf(node).left;</div><div class="line">					}</div><div class="line">					uncle.color = parentOf(node).color;</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.left.color = BLACK;</div><div class="line">					rightRotate(parentOf(node));</div><div class="line">					node = root;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		node.color = BLACK;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<p><br></p>
<h3 id="动态顺序统计">动态顺序统计</h3>
<p>在之前的<a href="http://alexyyek.github.io/2014/12/08/select/" target="_blank" rel="external"><strong>顺序统计学</strong></a>问题中，我们尝试在<code>O(n)</code>的时间内找到无序集合中第i小的数。这里将介绍如何修改红黑树的结构，使得任意的顺序统计量都可以在<code>O(lgn)</code>时间内确定。</p>
<p>一颗<strong>顺序统计量数</strong>通过在红黑树的每个节点中存入附加信息而成，即除了节点的key值，还包含了域<code>size</code>，如下图size的规则为：</p>
<p><center> $size[x]=size[left[x]]+size[right[x]]+1$ <center></center></center></p>
<p><center> <img src="http://alexyoung.qiniudn.com/01212325-22d4dc3f9b39450e9e5254db69372047.png" alt=""><center></center></center></p>
<p><strong>如何扩张数据结构：</strong></p>
<ul>
<li>选择基础的数据结构</li>
<li>确定要在基础数据结构中添加哪些信息（根据需要）</li>
<li>验证可用基础数据结构上的基础修改操作来维护新添加的信息</li>
<li>设计新的操作</li>
</ul>
<p><br></p>
<h4 id="检索给定排序的元素">检索给定排序的元素</h4>
<p>为了找出顺序统计数中第i小的关键字，递归版伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">OS-SELECT(root[T],i)</div><div class="line">r = size[left[x]] + <span class="number">1</span></div><div class="line"><span class="keyword">if</span> r = i</div><div class="line">    then <span class="keyword">return</span> x</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> i &lt; r</div><div class="line">    then <span class="keyword">return</span> OS-SELECT(left[x],i)</div><div class="line"><span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> OS-SELECT(right[x], i-r)</div></pre></td></tr></table></figure>

<p><br></p>
<h4 id="确定一个元素的秩">确定一个元素的秩</h4>
<p>过程OS-RANK返回在对树进行中序遍历得到的线性序中x的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">OS-RANK(T,x)</div><div class="line">r = size[left[x]] + <span class="number">1</span></div><div class="line">y = x</div><div class="line"><span class="keyword">while</span> y != root[T]</div><div class="line">    do <span class="keyword">if</span> y = right[p[y]]</div><div class="line">        r = r + size[left[p[y]]] + <span class="number">1</span></div><div class="line">        y = p[y]</div><div class="line"><span class="keyword">return</span> r</div></pre></td></tr></table></figure>

<p><br></p>
<h4 id="对子树规模的维护">对子树规模的维护</h4>
<p>红黑树的插入和删除可能会改变树的结构，为了维护红黑树的结构，需要更新域size的值，左旋在原有代码下增加两行：</p>
<p><center> $size[y] = size[x]$ <center></center></center></p>
<p><center> $size[x] = size[left[x]] + size[right[x]] + 1$ <center></center></center></p>
<p><center> <img src="http://alexyoung.qiniudn.com/101600338568211.png" alt=""> <center></center></center></p>
<p>点击<a href="http://www.cnblogs.com/alan-forever/p/3657086.html" target="_blank" rel="external"><strong>具体讲解</strong></a></p>
<figure class="highlight C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * x结点上进行左旋转，y结点（x结点的右儿子）的左儿子成为x结点的新右儿子</div><div class="line"> * x结点成为y结点的左儿子的新父结点</div><div class="line"> * x结点的父结点成为y结点的新父结点，y结点成为x结点的新父结点</div><div class="line"> * x结点成为y结点的新左儿子</div><div class="line"> */</div><div class="line"><span class="keyword">void</span> Left_Rotate(RB_Tree *T, RB_TreeNode *x){</div><div class="line">    RB_TreeNode *y = x-&gt;right;       <span class="comment">//x点右儿子          </span></div><div class="line">    x-&gt;right = y-&gt;left;              <span class="comment">//y结点的左儿子会成为x结点的右儿子</span></div><div class="line">    <span class="keyword">if</span>(y-&gt;left != NIL)</div><div class="line">        y-&gt;left-&gt;parent = x;         <span class="comment">//如果y有左儿子,y的左儿子的父结点为x</span></div><div class="line">    y-&gt;parent = x-&gt;parent;</div><div class="line">    <span class="keyword">if</span>(x-&gt;parent == NIL)</div><div class="line">        T-&gt;root = y;                <span class="comment">//如果x的父结点为哨兵，说明x为根结点，则y成为根结点</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)</div><div class="line">        x-&gt;parent-&gt;left = y;        </div><div class="line">    <span class="keyword">else</span></div><div class="line">        x-&gt;parent-&gt;right = y;       <span class="comment">//判断x为其父结点的左、右儿子，y成为x父结点对应的儿子</span></div><div class="line">    y-&gt;left = x;                    <span class="comment">//y的左儿子为x</span></div><div class="line">    x-&gt;parent = y;                  <span class="comment">//x的父结点为y</span></div><div class="line"></div><div class="line">    <span class="comment">/*调整size域*/</span></div><div class="line">    y-&gt;size = x-&gt;size;</div><div class="line">    x-&gt;size = x-&gt;left-&gt;size + x-&gt;right-&gt;size + <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<h3 id="完整代码">完整代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Algorithm;</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * red-black tree</div><div class="line"> *<span class="javadoctag"> @author</span> AlexYoung</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>{</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; root;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt;</span>{</div><div class="line">		T key;</div><div class="line">		Node&lt;T&gt; left;</div><div class="line">		Node&lt;T&gt; right;</div><div class="line">		Node&lt;T&gt; parent;</div><div class="line">		<span class="keyword">boolean</span> color;</div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> <span class="title">Node</span>(T key, Node&lt;T&gt; left, Node&lt;T&gt; right, Node&lt;T&gt; parent, Boolean color){</div><div class="line">			<span class="keyword">this</span>.key = key;</div><div class="line">			<span class="keyword">this</span>.left = left;</div><div class="line">			<span class="keyword">this</span>.right = right;</div><div class="line">			<span class="keyword">this</span>.parent = parent;</div><div class="line">			<span class="keyword">this</span>.color = color;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> T <span class="title">getKey</span>(){</div><div class="line">			<span class="keyword">return</span> key;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> String <span class="title">toString</span>(){</div><div class="line">			<span class="keyword">return</span> <span class="string">""</span> + key + <span class="string">" "</span> + color;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">RBTree</span>(){</div><div class="line">		root = <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">parentOf</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">return</span> (node != <span class="keyword">null</span>) ? node.parent : <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">colorOf</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">return</span> (node != <span class="keyword">null</span>) ? node.color : BLACK;</div><div class="line">	}</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">return</span> (node != <span class="keyword">null</span>) && (node.color == RED) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlack</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">return</span> !isRed(node);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">miNode</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">while</span> (node.left != <span class="keyword">null</span>) {</div><div class="line">			node = node.left;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> node;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span>(Node&lt;T&gt; tree){</div><div class="line">		<span class="keyword">if</span>(tree != <span class="keyword">null</span>) {</div><div class="line">			inOrder(tree.left);</div><div class="line">			System.out.print(tree.key + <span class="string">"\t"</span>);</div><div class="line">			inOrder(tree.right);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span>(){</div><div class="line">		inOrder(root);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">maxNode</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">while</span> (node.right != <span class="keyword">null</span>) {</div><div class="line">			node = node.right;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> node;</div><div class="line">	}</div><div class="line">	<span class="comment">// 前趋</span></div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">succussor</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">if</span> (node.right != <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> miNode(node.right);</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; parent = node.parent;</div><div class="line">		<span class="keyword">while</span> (parent != <span class="keyword">null</span> && node == parent.right) {</div><div class="line">			node = parent;</div><div class="line">			parent = parent.parent;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> parent;</div><div class="line">	}</div><div class="line">	<span class="comment">// 后继</span></div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">preDecessor</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">if</span> (node.left != <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> maxNode(node.left);</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; parent = node.parent;</div><div class="line">		<span class="keyword">while</span> (parent != <span class="keyword">null</span> && node == parent.left) {</div><div class="line">			node = parent;</div><div class="line">			parent = parent.parent;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> parent;</div><div class="line">	}</div><div class="line">	<span class="comment">//	左旋</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span>(Node&lt;T&gt; x){</div><div class="line">		<span class="comment">//consider the left child of y</span></div><div class="line">		Node&lt;T&gt; y = x.right;</div><div class="line">		x.right = y.left;</div><div class="line">		<span class="keyword">if</span> (y.left != <span class="keyword">null</span>) {</div><div class="line">			y.left.parent = x;</div><div class="line">		}</div><div class="line">		<span class="comment">//consider the node y</span></div><div class="line">		y.parent = x.parent;</div><div class="line">		<span class="keyword">if</span> (x.parent == <span class="keyword">null</span>) {</div><div class="line">			root = y;</div><div class="line">		}<span class="keyword">else</span>{</div><div class="line">			<span class="keyword">if</span>(x == x.parent.left)</div><div class="line">			x.parent.left = y;</div><div class="line">			<span class="keyword">else</span> </div><div class="line">			x.parent.right = y;</div><div class="line">		}</div><div class="line">		<span class="comment">//consider the Node x</span></div><div class="line">		y.left = x;</div><div class="line">		x.parent = y;</div><div class="line">	}</div><div class="line">	<span class="comment">//	右旋</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span>(Node&lt;T&gt; x){</div><div class="line">		Node&lt;T&gt; y= x.left;</div><div class="line">		x.left = y.right;</div><div class="line">		<span class="keyword">if</span> (y.right != <span class="keyword">null</span>) {</div><div class="line">			y.right.parent = x;</div><div class="line">		}</div><div class="line">		</div><div class="line">		y.parent = x.parent;</div><div class="line">		<span class="keyword">if</span> (x.parent == <span class="keyword">null</span>) {</div><div class="line">			root = y;</div><div class="line">		}<span class="keyword">else</span>{</div><div class="line">			<span class="keyword">if</span> (x == x.parent.left)</div><div class="line">			x.parent.left = y;</div><div class="line">			<span class="keyword">else</span> </div><div class="line">			x.parent.right = y;</div><div class="line">		}</div><div class="line">		</div><div class="line">		y.right = x;</div><div class="line">		x.parent =y;</div><div class="line">	}</div><div class="line">	<span class="comment">//递归查找</span></div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">search</span>(Node&lt;T&gt; tree, T key){</div><div class="line">		<span class="keyword">if</span> (tree == <span class="keyword">null</span> || key == tree.key) {</div><div class="line">			<span class="keyword">return</span> tree;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (key.compareTo(tree.key) &lt;= <span class="number">0</span>) {</div><div class="line">			<span class="keyword">return</span> search(tree.left, key);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> search(tree.right, key);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">//非递归查找</span></div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">searchNode</span>(Node&lt;T&gt; tree, T key){</div><div class="line">		<span class="keyword">while</span> (tree != <span class="keyword">null</span> && tree.key != key) {</div><div class="line">			<span class="keyword">if</span> (key.compareTo(tree.key) &lt;= <span class="number">0</span>) {</div><div class="line">				tree = tree.left;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				tree = tree.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 将结点插入到红黑树中</div><div class="line">	 *<span class="javadoctag"> @param</span> node : 插入的结点</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span>(Node&lt;T&gt; node){</div><div class="line">		Node&lt;T&gt; y = <span class="keyword">null</span>;</div><div class="line">		Node&lt;T&gt; x = <span class="keyword">this</span>.root;</div><div class="line">		<span class="keyword">while</span> (x != <span class="keyword">null</span>) {</div><div class="line">			y = x;</div><div class="line">			<span class="keyword">if</span> (node.key.compareTo(x.key) &lt;= <span class="number">0</span>) {</div><div class="line">				x = x.left;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				x = x.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">		node.parent = y;</div><div class="line">		<span class="keyword">if</span> (y == <span class="keyword">null</span>) {</div><div class="line">			root = node;</div><div class="line">			node.color = BLACK;</div><div class="line">		} <span class="keyword">else</span> {</div><div class="line">			<span class="keyword">if</span> (node.key.compareTo(y.key) &lt;= <span class="number">0</span>) {</div><div class="line">				y.left = node;</div><div class="line">				node.color = RED;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				y.right = node;</div><div class="line">				node.color = RED;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		</div><div class="line">		</div><div class="line">		insertFixUp(node);</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * </div><div class="line">	 *<span class="javadoctag"> @param</span> key : 插入节点的键值</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span>(T key){</div><div class="line">		Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;(key, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, BLACK);</div><div class="line">		<span class="keyword">if</span> (node != <span class="keyword">null</span>) {</div><div class="line">			insert(node);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertFixUp</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="comment">//	若父节点存在，并且父节点的颜色是红色</span></div><div class="line">		<span class="keyword">while</span>(node.parent != <span class="keyword">null</span> && isRed(node.parent)) {</div><div class="line">			<span class="comment">// 若父节点”是“祖父节点的左孩子</span></div><div class="line">			<span class="keyword">if</span> (parentOf(node) == parentOf(parentOf(node)).left) {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(parentOf(node)).right;		<span class="comment">//叔叔节点，即父节点的兄弟节点</span></div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {									<span class="comment">//情况一：如果叔叔节点是红色，因为父节点是红色，显然祖父节点是黑色</span></div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					node = parentOf(parentOf(node));</div><div class="line">				}</div><div class="line">				<span class="keyword">else</span> {	</div><div class="line">					<span class="keyword">if</span> (parentOf(node).right == node) {				<span class="comment">//情况二：叔叔节点是黑色，而Z是右孩子</span></div><div class="line">						 node = parentOf(node);</div><div class="line">						 leftRotate(node);</div><div class="line">					}</div><div class="line">					</div><div class="line">					parentOf(node).color = BLACK;					<span class="comment">//情况三：叔叔节点黑色，Z是左孩子</span></div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					rightRotate(parentOf(parentOf(node)));</div><div class="line">				}</div><div class="line">			}</div><div class="line">			<span class="comment">// 若父节点”是“祖父节点的右孩子</span></div><div class="line">			<span class="keyword">else</span> {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(parentOf(node)).left;</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					node = parentOf(parentOf(node));</div><div class="line">				}</div><div class="line">				<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">if</span> (parentOf(node).left == node) {</div><div class="line">						 node = parentOf(node);</div><div class="line">						 rightRotate(node);</div><div class="line">					}</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					leftRotate(parentOf(parentOf(node)));</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="comment">/* 1.防止插入节点为根节点        </span></div><div class="line">		 * 2.防止树深度较低时grandparent为root节点,从而在情况一uncle为red时，把root节点置为red 	 */</div><div class="line">		<span class="keyword">if</span> (node == root) {</div><div class="line">			node.color = BLACK;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 删除节点</div><div class="line">	 *<span class="javadoctag"> @param</span> node : 待删除节点</div><div class="line">	 *<span class="javadoctag"> @return</span></div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">remove</span>(Node&lt;T&gt; node){</div><div class="line">		Node&lt;T&gt; replace = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span> (node.left == <span class="keyword">null</span> || node.right == <span class="keyword">null</span>) {</div><div class="line">			replace = node;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			replace = succussor(node);</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; child = replace.left != <span class="keyword">null</span> ? replace.left : replace.right; </div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (child == <span class="keyword">null</span>) {</div><div class="line">			child = <span class="keyword">new</span> Node&lt;T&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, replace.parent, BLACK);</div><div class="line">		}</div><div class="line">		child.parent = replace.parent;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (replace.parent == <span class="keyword">null</span>) {</div><div class="line">			root = child;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">if</span>(replace == replace.parent.left)</div><div class="line">				replace.parent.left = child;</div><div class="line">			<span class="keyword">else</span></div><div class="line">				replace.parent.right = child;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (replace != node) {</div><div class="line">			node.key = replace.key;</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (isBlack(replace)) {</div><div class="line">			removeFixUp(child);</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> replace;</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 删除某一数值</div><div class="line">	 *<span class="javadoctag"> @param</span> key : 待删除值</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(T key){</div><div class="line">		Node&lt;T&gt; node = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span> ((node = searchNode(root, key)) != <span class="keyword">null</span>) {</div><div class="line">			remove(node);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeFixUp</span>(Node&lt;T&gt; node){</div><div class="line">	</div><div class="line">		<span class="keyword">while</span> (node != <span class="keyword">this</span>.root && node.color == BLACK) {</div><div class="line">			<span class="comment">// 若节点是父节点的左孩子</span></div><div class="line">			<span class="keyword">if</span> (node == parentOf(node).left) {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(node).right;		</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {							<span class="comment">//情况一：叔叔节点为红色</span></div><div class="line">					parentOf(node).color = RED;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					leftRotate(parentOf(node));</div><div class="line">					uncle = parentOf(node).right;</div><div class="line">				}</div><div class="line">				<span class="comment">//情况二：叔叔节点为黑色，且有两个黑孩子</span></div><div class="line">				<span class="keyword">if</span> (isBlack(uncle.left) && isBlack(uncle.right)) {</div><div class="line">					uncle.color = RED;</div><div class="line">					node = parentOf(node);</div><div class="line">				}<span class="keyword">else</span> {										</div><div class="line">					<span class="keyword">if</span> (isBlack(uncle.right)) {				<span class="comment">//情况三：叔叔节点的左孩子为红色，右孩子为黑色</span></div><div class="line">						uncle.left.color = BLACK;</div><div class="line">						uncle.color = RED;</div><div class="line">						rightRotate(uncle);</div><div class="line">						uncle = parentOf(node).right;</div><div class="line">					}</div><div class="line">					uncle.color = parentOf(node).color;		<span class="comment">//情况四：叔叔节点的右孩子为红色</span></div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.right.color = BLACK;</div><div class="line">					leftRotate(parentOf(node));</div><div class="line">					node = root;</div><div class="line">				}</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(node).left;</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {</div><div class="line">					parentOf(node).color = RED;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					rightRotate(parentOf(node));</div><div class="line">					uncle = parentOf(node).left;</div><div class="line">				}</div><div class="line">				<span class="keyword">if</span> (isBlack(uncle.left) && isBlack(uncle.right)) {</div><div class="line">					uncle.color = RED;</div><div class="line">					node = parentOf(node);</div><div class="line">				}<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">if</span> (isBlack(uncle.left)) {</div><div class="line">						uncle.right.color = BLACK;</div><div class="line">						uncle.color = RED;</div><div class="line">						leftRotate(uncle);</div><div class="line">						uncle = parentOf(node).left;</div><div class="line">					}</div><div class="line">					uncle.color = parentOf(node).color;</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.left.color = BLACK;</div><div class="line">					rightRotate(parentOf(node));</div><div class="line">					node = root;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		node.color = BLACK;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		<span class="keyword">int</span>[] arr = {<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">80</span>};</div><div class="line">		RBTree&lt;Integer&gt; tree = <span class="keyword">new</span> RBTree&lt;Integer&gt;();</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i : arr){</div><div class="line">			tree.insert(i);</div><div class="line">		}</div><div class="line">		tree.inOrder();</div><div class="line">		tree.remove(<span class="number">20</span>);</div><div class="line">		System.out.println();</div><div class="line">		tree.inOrder();</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[一颗高度为H的二叉树可以实现任何一种基本的动态集合操作，时间都为O(h)，当数的高度较低时，这种操作较快，但是当树的高度较高时，红黑树由于其平衡树的特点，保证了基本动态操作时间为O(lgn)。]]>
    
    </summary>
    
      <category term="Tree" scheme="http://alexyyek.github.io/tags/Tree/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉查找树]]></title>
    <link href="http://alexyyek.github.io/2014/12/17/BinaryTree/"/>
    <id>http://alexyyek.github.io/2014/12/17/BinaryTree/</id>
    <published>2014-12-17T09:39:28.000Z</published>
    <updated>2014-12-17T13:21:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="二叉查找树">二叉查找树</h2>
<p>一颗二叉查找树是按二叉树的结构来组织的，树中每个结点都是一个对象，节点中除了<code>key</code>域外，还包含域<code>left</code>，<code>right</code>以及<code>parent</code>，分别指向当前节点的左子节点、右子节点和父节点。</p>
<p><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/QQ图片20141217175217.png" alt=""> <center></center></center></p>
<p>在二叉查找树中：</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树。</li>
<li>没有键值相等的节点（待定）</li>
</ol>
<h3 id="遍历操作">遍历操作</h3>
<p>根据二叉查找树的性质，可以由递归算法按排列顺序输出树中的所有关键字。</p>
<p><strong>中序遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span>(Node root){</div><div class="line">		<span class="keyword">if</span> (root != <span class="keyword">null</span>) {</div><div class="line">			inOrder(root.left);</div><div class="line">			System.out.print(root.value +<span class="string">"\t"</span>);</div><div class="line">			inOrder(root.right);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>前序遍历和后续遍历形式基本一致，前序先输出root节点，后续最后输出root节点。</p>
<h3 id="查找操作">查找操作</h3>
<p>从二叉查找树根节点开始查找，并沿着树下降，对每个碰到的非空节点比较节点值与查找值大小，按情况向左右子树下降，直到找到并返回节点对象。非递归版本普遍较快。</p>
<p><strong>递归版本</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Node <span class="title">search</span>(Node tree, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">if</span> (tree == <span class="keyword">null</span> || value == tree.value) {</div><div class="line">			<span class="keyword">return</span> tree;</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (value &lt;= tree.value) {</div><div class="line">			<span class="keyword">return</span> search(tree.left, value);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> search(tree.right, value);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><strong>非递归版本</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Node <span class="title">searchNode</span>(Node tree, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">while</span> (tree != <span class="keyword">null</span> && tree.value != value) {</div><div class="line">			<span class="keyword">if</span> (value &lt;= tree.value) {</div><div class="line">				tree = tree.left;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				tree = tree.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="插入操作">插入操作</h3>
<p>插入操作与查找操作类似，将待插值与当前节点值比较，小于当前节点值则去左子树继续比较，大于当前节点值去右子树比较，直到下降直空节点，则将待插值赋给空节点并返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Node <span class="title">insertNode</span>(Node tree, <span class="keyword">int</span> x){</div><div class="line">		<span class="keyword">if</span> (tree == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Node(x);</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (x &lt;= tree.value) {</div><div class="line">			tree.left = insertNode(tree.left, x);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			tree.right = insertNode(tree.right, x);</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="删除操作">删除操作</h3>
<p>删除操作根据所删节点的子女数量可能会改变树的结构，主要分为三种情况：</p>
<ol>
<li>无children节点，直接删除<br><img src="http://7rf27k.com1.z0.glb.clouddn.com/20130506115644277.png" alt=""></li>
<li>有一个children节点，将子节点覆盖删除节点<br><img src="http://7rf27k.com1.z0.glb.clouddn.com/20130506115712159.png" alt=""></li>
<li>两个children节点都不为空，寻址其后继节点（右子树中的最小值），用后继节点值替换删除节点值，然后在其右子树中删除后继节点<br><img src="http://7rf27k.com1.z0.glb.clouddn.com/QQ图片20141217174837.jpg" alt=""></li>
</ol>
<h3 id="二叉查找树性能">二叉查找树性能</h3>
<p>对高度为<strong><code>h</code></strong>的二叉查找树，动态集合操作INSERT和DELETE的运行时间为<strong><code>O(h)</code></strong></p>
<h2 id="完整代码">完整代码</h2>
<h3 id="简单版">简单版</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</div><div class="line">		Node left;</div><div class="line">		Node right;</div><div class="line">		<span class="keyword">int</span> value;</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> <span class="title">Node</span>(<span class="keyword">int</span> value){</div><div class="line">			<span class="keyword">this</span>.value = value;</div><div class="line">			left = <span class="keyword">null</span>;</div><div class="line">			right = <span class="keyword">null</span>;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">private</span> Node root;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">BinarySearchTree</span>(){</div><div class="line">		root = <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">BinarySearchTree</span>(<span class="keyword">int</span>[] arr){</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i : arr){</div><div class="line">			insert(i);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span>(<span class="keyword">int</span> value){</div><div class="line">		root = insert(root, value);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node <span class="title">insert</span>(Node root, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) {</div><div class="line">			root = <span class="keyword">new</span> Node(value);</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (value &lt;= root.value) {</div><div class="line">			<span class="keyword">if</span> (root.left == <span class="keyword">null</span>) {</div><div class="line">				root.left = <span class="keyword">new</span> Node(value);</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				insert(root.left, value);</div><div class="line">			}</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">if</span> (root.right == <span class="keyword">null</span>) {</div><div class="line">				root.right = <span class="keyword">new</span> Node(value);</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				insert(root.right, value);</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="comment">//中序遍历</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span>(Node tree){</div><div class="line">		<span class="keyword">if</span> (tree != <span class="keyword">null</span>) {</div><div class="line">			inOrder(tree.left);</div><div class="line">			System.out.print(tree.value + <span class="string">"\t"</span>);</div><div class="line">			inOrder(tree.right);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">//前序遍历</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span>(Node tree){</div><div class="line">		<span class="keyword">if</span> (tree != <span class="keyword">null</span>) {</div><div class="line">			System.out.print(tree.value +<span class="string">"\t"</span>);</div><div class="line">			preOrder(tree.left);</div><div class="line">			preOrder(tree.right);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">//后续遍历</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span>(Node tree){</div><div class="line">		<span class="keyword">if</span> (tree != <span class="keyword">null</span>) {</div><div class="line">			postOrder(tree.left);</div><div class="line">			postOrder(tree.right);</div><div class="line">			System.out.print(tree.value +<span class="string">"\t"</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">//递归</span></div><div class="line">	<span class="keyword">public</span> Node <span class="title">search</span>(Node tree, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">if</span> (tree == <span class="keyword">null</span> || value == tree.value) {</div><div class="line">			<span class="keyword">return</span> tree;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (value &lt;= tree.value) {</div><div class="line">			<span class="keyword">return</span> search(tree.left, value);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> search(tree.right, value);</div><div class="line">		}</div><div class="line">		</div><div class="line">	}</div><div class="line">	<span class="comment">//非递归</span></div><div class="line">	<span class="keyword">public</span> Node <span class="title">searchNoIter</span>(Node root, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">while</span> (root != <span class="keyword">null</span> && value != root.value) {</div><div class="line">			<span class="keyword">if</span> (value &lt;= root.value) {</div><div class="line">				root = root.left;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				root = root.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Null Poninter"</span> + value);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> root;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">//	最小值节点</span></div><div class="line">	<span class="keyword">public</span> Node <span class="title">minNode</span>(Node root){</div><div class="line">		<span class="keyword">while</span> (root.left != <span class="keyword">null</span>) {</div><div class="line">			root = root.left;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	}</div><div class="line">	<span class="comment">//	最大值节点</span></div><div class="line">	<span class="keyword">public</span> Node <span class="title">maxNode</span>(Node root){</div><div class="line">		<span class="keyword">while</span> (root.right != <span class="keyword">null</span>) {</div><div class="line">			root = root.right;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node <span class="title">insertNode</span>(Node root, Node x){</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Node(x.value);</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (x.value &lt;= root.value) {</div><div class="line">			root.left = insertNode(root.left, x);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			root.right = insertNode(root.right, x);</div><div class="line">		}</div><div class="line">	</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	}</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node <span class="title">remove</span>(Node root, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> root;</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (value &lt; root.value) {</div><div class="line">			root.left = remove(root.left, value);</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root.value) {</div><div class="line">			root.right = remove(root.right, value);</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (root.left != <span class="keyword">null</span> && root.right != <span class="keyword">null</span>) {</div><div class="line">			root.value = minNode(root.right).value;</div><div class="line">			root.right = remove(root.right, root.value);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			root = (root.left != <span class="keyword">null</span>)? root.left:root.right;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<h3 id="泛型带parent节点版本">泛型带parent节点版本</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Algorithm;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiSearchTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>{</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; root;</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt;</span>{</div><div class="line">		T key;</div><div class="line">		Node&lt;T&gt; left;</div><div class="line">		Node&lt;T&gt; right;</div><div class="line">		Node&lt;T&gt; parent;</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> <span class="title">Node</span>(T key, Node&lt;T&gt; parent, Node&lt;T&gt; left, Node&lt;T&gt;right){</div><div class="line">			<span class="keyword">this</span>.key = key;</div><div class="line">			<span class="keyword">this</span>.parent = parent;</div><div class="line">			<span class="keyword">this</span>.left = left;</div><div class="line">			<span class="keyword">this</span>.right = right;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> T <span class="title">getKey</span>(){</div><div class="line">			<span class="keyword">return</span> key;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">BiSearchTree</span>(){</div><div class="line">		root = <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span>(Node&lt;T&gt; root){</div><div class="line">		<span class="keyword">if</span> (root != <span class="keyword">null</span>) {</div><div class="line">			inOrder(root.left);</div><div class="line">			System.out.print(root.key + <span class="string">"\t"</span>);</div><div class="line">			inOrder(root.right);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">search</span>(Node&lt;T&gt; tree, T key){</div><div class="line">		<span class="keyword">if</span> (tree == <span class="keyword">null</span> || key == tree.key) {</div><div class="line">			<span class="keyword">return</span> tree;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> cmp = key.compareTo(tree.key);</div><div class="line">		<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) {</div><div class="line">			<span class="keyword">return</span> search(tree.left, key);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> search(tree.right, key);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">searchNode</span>(Node&lt;T&gt; tree, T key){</div><div class="line">		<span class="keyword">while</span> (tree != <span class="keyword">null</span> && key != tree.key) {</div><div class="line">			<span class="keyword">int</span> cmp = key.compareTo(tree.key);</div><div class="line">			<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) {</div><div class="line">				tree = tree.left;</div><div class="line">			}<span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) {</div><div class="line">				tree = tree.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">minNode</span>(Node&lt;T&gt; tree){</div><div class="line">		<span class="keyword">while</span> (tree.left != <span class="keyword">null</span>) {</div><div class="line">			tree = tree.left;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">maxNode</span>(Node&lt;T&gt; tree){</div><div class="line">		<span class="keyword">while</span> (tree.right != <span class="keyword">null</span>) {</div><div class="line">			tree = tree.right;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 如果x没有右孩子。则x有以下两种可能：</div><div class="line">	 * (01) x是"一个左孩子"，则"x的后继结点"为 "它的父结点"。</div><div class="line">	 * (02) x是"一个右孩子"，则查找"是其父节点的左儿子的节点"为止，找到的这个"最低的父结点"就是"x的后继结点"。</div><div class="line">	 *<span class="javadoctag"> @param</span> x</div><div class="line">	 *<span class="javadoctag"> @return</span></div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">successor</span>(Node&lt;T&gt; x){</div><div class="line">		<span class="comment">// 如果x存在右孩子，则"x的后继结点"为 "以其右孩子为根的子树的最小结点"。</span></div><div class="line">		<span class="keyword">if</span> (x.right != <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> minNode(x.right);</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; before = x.parent;</div><div class="line">		<span class="keyword">while</span> (before != <span class="keyword">null</span> && x == before.right) {</div><div class="line">			x = before;</div><div class="line">			before = before.parent;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> before;</div><div class="line">	}</div><div class="line">	<span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></div><div class="line">	<span class="comment">// (01) x是"一个右孩子"，则"x的前驱结点"为 "它的父结点"。</span></div><div class="line">	<span class="comment">// (01) x是"一个左孩子"，则查找"是其父节点的右儿子节点"，找到的这个"最低的父结点"就是"x的前驱结点"。</span></div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">preDecessor</span>(Node&lt;T&gt; x){</div><div class="line">		<span class="keyword">if</span> (x.left != <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> maxNode(x.left);</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; before = x.parent;</div><div class="line">		<span class="keyword">while</span> (before != <span class="keyword">null</span> && x == before.left) {</div><div class="line">			x = before;</div><div class="line">			before = before.right;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> before;</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 先找到插入位置的父节点，如果父节点为null，则插到父节点，否则插入左或右节点</div><div class="line">	 *<span class="javadoctag"> @param</span> tree</div><div class="line">	 *<span class="javadoctag"> @param</span> node 待插入节点</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertNode</span>(Node&lt;T&gt; tree, Node&lt;T&gt; node){</div><div class="line">		Node&lt;T&gt; before = <span class="keyword">null</span>;</div><div class="line">		Node&lt;T&gt; index = tree;</div><div class="line">		<span class="keyword">while</span> (index != <span class="keyword">null</span>) {</div><div class="line">			before = index;</div><div class="line">			<span class="keyword">if</span> (node.key.compareTo(index.key) &lt; <span class="number">0</span>) {</div><div class="line">				index = index.left;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				index = index.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		node.parent = before;</div><div class="line">		<span class="keyword">if</span> (before == <span class="keyword">null</span>) {</div><div class="line">			tree = node;</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (node.key.compareTo(before.key) &lt; <span class="number">0</span>) {</div><div class="line">			before.left = node;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			before.right = node;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">remove</span>(Node&lt;T&gt; tree, T key){</div><div class="line">		Node&lt;T&gt; node = search(tree, key);</div><div class="line">		<span class="keyword">if</span> (node == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> node;</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; index = <span class="keyword">null</span>;</div><div class="line">		Node&lt;T&gt; child = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span> (node.left == <span class="keyword">null</span> || node.left == <span class="keyword">null</span>) {</div><div class="line">			index = node;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			index = successor(node);</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (index.left != <span class="keyword">null</span>) {</div><div class="line">			child = index.left;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			child = index.right;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (child != <span class="keyword">null</span>) {</div><div class="line">			child.parent = index.parent;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (index.parent == <span class="keyword">null</span>) {</div><div class="line">			tree = child;</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (index == index.parent.left) {</div><div class="line">			index.parent.left = child;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			index.parent.right = child;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (index != node) {</div><div class="line">			node.key = index.key;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> index;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[二叉查找树是一种数据结构，支持多种动态集合操作。在二叉查找树上执行的基本操作时间与树高成正比。]]>
    
    </summary>
    
      <category term="Tree" scheme="http://alexyyek.github.io/tags/Tree/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[哈希碰撞]]></title>
    <link href="http://alexyyek.github.io/2014/12/14/hashCollapse/"/>
    <id>http://alexyyek.github.io/2014/12/14/hashCollapse/</id>
    <published>2014-12-14T11:46:07.000Z</published>
    <updated>2014-12-16T13:59:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="链地址法">链地址法</h2>
<p>Java.util.Hashtable类实现了JAVA中的哈希表，内部采用Entry[]数组，每个Entry均可作为链表的头，用来解决哈希碰撞。</p>
<h3 id="Hashtable特点"><strong>Hashtable特点</strong></h3>
<ul>
<li>线程安全，能用于多线程环境中。</li>
<li>Key、Value均不能为null。</li>
<li>Hashtable同样实现了Serializable接口，它支持序列化，实现了Cloneable接口，能被克隆。</li>
<li>包含了一个Entry[]数组，而Entry又是一个链表，用来处理冲突。</li>
<li>每个Key对应了Entry数组中固定的位置（记为index），称为槽位（Slot）。槽位计算公式为：<pre><code>       (key.hash<span class="variable">Code</span>() &amp; <span class="number">0</span>x7<span class="variable">FFFFFFF</span>) <span class="comment">% Entry[].length() </span>
</code></pre></li>
<li>当Entry[]的实际元素数量（Count）超过了分配容量（Capacity）的75%时，新建一个Entry[]是原先的2倍，重新Hash（rehash）。</li>
<li>rehash的核心思路是，将旧Entry[]数组的元素重新计算槽位，散列到新Entry[]中。<br><br></li>
</ul>
<hr>
<h3 id="Hashtable源码分析"><strong>Hashtable源码分析</strong></h3>
<p><strong>Entry类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Entry&lt;K,V&gt; <span class="comment">// Entry&lt;K,V&gt;是槽中的元素，可做链表，解决散列冲突。</span></div><div class="line">{</div><div class="line">     <span class="keyword">int</span> hash; <span class="comment">// 即key.hashCode()</span></div><div class="line">     K key;</div><div class="line">     V value;</div><div class="line">     Entry&lt;K,V&gt; next; <span class="comment">// 用来实现链表结构。同一链表中的key的hash是相同的。</span></div><div class="line">     <span class="keyword">protected</span> <span class="title">Entry</span>(<span class="keyword">int</span> hash, K key, V value, Entry&lt;K,V&gt; next) {</div><div class="line">          <span class="keyword">this</span>.hash=hash;<span class="keyword">this</span>.key=key;<span class="keyword">this</span>.value=value;<span class="keyword">this</span>.next=next;</div><div class="line">     }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><br><br><strong>构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">Hashtable</span>(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor) {</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                initialCapacity);</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</div><div class="line">        initialCapacity = <span class="number">1</span>;</div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity];</div><div class="line">    threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Constructs a new, empty hashtable with the specified initial capacity</div><div class="line"> * and default load factor (0.75).</div><div class="line"> *<span class="javadoctag"> @param</span>     initialCapacity   the initial capacity of the hashtable.</div><div class="line"> *<span class="javadoctag"> @exception</span> IllegalArgumentException if the initial capacity is less</div><div class="line"> *              than zero.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="title">Hashtable</span>(<span class="keyword">int</span> initialCapacity) {</div><div class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75</span>f);</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Constructs a new, empty hashtable with a default initial capacity (11)</div><div class="line"> * and load factor (0.75).</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="title">Hashtable</span>() {</div><div class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75</span>f);</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>threshold：Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”</li>
<li>loadFactor：加载因子，通常设为<strong><code>0.75</code></strong><br><br></li>
</ul>
<p><strong>hashcode</strong><br>考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）。</p>
<p>也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span>(Object key) {</div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">    <span class="keyword">int</span> index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) {</div><div class="line">        <span class="keyword">if</span> ((e.hash == hash) && e.key.equals(key)) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值(实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值)；</p>
<ul>
<li>if（table中没有该hashcode值），then → 直接存进去</li>
<li>if（存在该hashcode值），then → 调用equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址<br>所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：<strong>Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。</strong><br><br></li>
</ul>
<p><strong>addEntry</strong><br>addEntry方法实现向Hashtable中添加k-v值对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span>(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index) {</div><div class="line">    modCount++;</div><div class="line"> </div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">if</span> (count &gt;= threshold) {</div><div class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></div><div class="line">        rehash();</div><div class="line"> </div><div class="line">        tab = table;</div><div class="line">        hash = key.hashCode();</div><div class="line">        index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="comment">// Creates the new entry.</span></div><div class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; <span class="comment">// 旧有Entry</span></div><div class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e); <span class="comment">/* 旧有Entry成为了新增Entry的next */</span></div><div class="line">    count++;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当count大于阀值时，要重新进行hash，重新确定Hashtable的大小<br><br></p>
<p><strong>rehash</strong><br>rehash方法即再次hash，当Entry[]的实际存储数量占分配容量的约75%时，扩容并且重新计算各个对象的槽位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span>() {</div><div class="line">          <span class="keyword">int</span> oldCapacity = table.length;</div><div class="line">          Entry[] oldMap = table;</div><div class="line">          <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 2倍+1</span></div><div class="line">          Entry[] newMap = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">          threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</div><div class="line">          table = newMap;</div><div class="line"> </div><div class="line">          <span class="keyword">for</span>( <span class="keyword">int</span> i=oldCapacity; i-- &gt;<span class="number">0</span>;){ <span class="comment">//  i的取值范围为 [oldCapacity-1,0]</span></div><div class="line">               <span class="keyword">for</span> (Entry&lt;K,V&gt; old = oldMap[i]; old!=<span class="keyword">null</span>;){ <span class="comment">// 遍历旧Entry[]</span></div><div class="line">                    Entry&lt;K,V&gt; e = old;</div><div class="line">                    <span class="comment">//重新计算各个元素在新Entry[]中的槽位index。</span></div><div class="line">                    <span class="keyword">int</span> index = (e.hash & <span class="number">0x7FFFFFFF</span>) % newCapacity;     </div><div class="line">                    e.next = newMap[index]; <span class="comment">// 已经存在槽位中的Entry成为了新增Entry的next </span></div><div class="line">                    newMap[index]=e;     <span class="comment">// 放到槽位中</span></div><div class="line">                    old = old.next;</div><div class="line">               }</div><div class="line">          }</div><div class="line"> </div><div class="line">     }</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<h3 id="Hashtable源码总结">Hashtable源码总结</h3>
<p><strong>1</strong>. <strong>关于hashCode()和equals()方法</strong><br>下面这段话摘自Effective Java一书：</p>
<blockquote>
<ul>
<li>在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。</li>
<li>如果两个对象根据equals方法比较是相等的，那么调用两个对象的hashCode方法必须返回相同的整数结果。</li>
<li>如果两个对象根据equals方法比较是不等的，则hashCode方法不一定得返回不同的整数。</li>
</ul>
</blockquote>
<p>对于第二条和第三条很好理解，但是第一条，很多时候就会忽略。在《Java编程思想》一书中的P495页也有同第一条类似的一段话：</p>
<blockquote>
<p>设计hashCode()时最重要的因素就是：无论何时，对同一个对象调用hashCode()都应该产生同样的值。如果在讲一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。</p>
</blockquote>
<p><strong>所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码。</strong></p>
<p><br><br><strong>2</strong>. <strong>Hashtable中key和value都不允许为null</strong><br>而HashMap中key和value都允许为null（key只能有一个为null，而value则可以有多个为null）。但是如果在Hashtable中有类似put(null,null)的操作，编译同样可以通过，因为key和value都是Object类型，但运行时会抛出NullPointerException异常，这是JDK的规范规定的。<br><br><br><strong>3</strong>. <strong>Hashtable计算hash值</strong><br>直接用key的hashCode()，而HashMap重新计算了key的hash值，Hashtable在求hash值对应的位置索引时，用取模运算，而HashMap在求位置索引时，则用与运算，且这里一般先用hash&amp;0x7FFFFFFF后，再对length取模，&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，<strong>只有符号外改变，而后面的位都不变</strong> 。</p>
<p><br></p>
<hr>
<h3 id="链地址法性能分析">链地址法性能分析</h3>
<p>给定一个能存放n个元素，具有m个槽位的散列表T，定义T的装载因子$a=n/m$，即一个链中的平均元素数。假定可以在<code>O(1)</code>的时间内计算出散列值h(k)，即计算散列函数和寻址槽h(k)为<code>O(1)</code>时间。现查找元素k：</p>
<ul>
<li><p>一次不成功情况<br>在简单一致散列的假设下。一次不成功查找的<code>期望</code>时间为<code>0(1+a)</code><br>一次不成功即查找遍整个散列表<code>T[h(k)]</code>，平均每个链表查找元素为$a=n/m$，加上计算哈希h(k)的时间，总时间为<code>O(1+a)</code></p>
</li>
<li><p>一次成功情况<br>在简单一致散列的假设下。一次成功查找的期望时间为<code>0(1+a)</code><br><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/QQ图片20141215121340.png" alt=""> <center></center></center></p>
</li>
</ul>
<p>由于链表中新元素是在表头插入的，所以一次成功的查找中，所检查的元素数比x所在链表中出现在x前面的元素数多1<br>在hash值为index的槽位，一次成功的查找中，所检查元素的期望为：</p>
<p>$E\ [1/n·\sum_{i=1}^n(1+\sum_{j=i+1}^n X_{ij})]$</p>
<p>$=1/n·\sum_{i=1}^n(1+\sum_{j=i+1}^n E[X_{ij}])=1/n·\sum_{i=1}^n(1+\sum_{j=i+1}^n1/m)$</p>
<p>$=1+1/{mn}(\sum_{i=1}^nn-\sum_{i=1}^ni)=1+1/{mn}(n^2-n(n+1)/2)$</p>
<p>$=1+(n-1_/2m)=1+a/2-a/2n$</p>
<p>于是，一次成功的查找所需全部时间为<code>O(2+a/2-a/2n)</code>=<code>O(1+a)</code>.</p>
<p><strong>Conclusion</strong>：如果散列表中槽位数至少与表中的元素数成正比，则有n=O(m)，从而 $a=n/m=O(m)/m=O(1)$<br>所以平均查找操作需要常数量的时间，且已经知道插入操作最坏情况需要<code>O(1)</code>，删除操作最坏需要<code>O(1)</code>，因而全部字典操作可以在<code>O(1)</code>时间完成。</p>
<h2 id="开放寻址法">开放寻址法</h2>
<p>前面讲的方法主要基于用链表的方法解决哈希冲突，但元素数n大于槽位数m时，必然会导致至少一个槽位被多个元素hash到，因此链地址法的查询性能平均为<code>O(1+a)</code>，不能达到理想的<code>O(1)</code>。<br>开放寻址法中，所有的元素都存放在散列表里，即每个表项是动态集合中的一个元素，或者为NIL。当要插入一个元素时，可以连续的检查散列表的各项,直到找个一个空槽来存放待插入元素，整个数组必须支持<code>动态扩容</code>：当数组空闲节点低于一个阀值时，将扩展数组容量为原来的一倍。这个阀值通常是<code>0.72</code>。当然检查的顺序不一定是0,1,…,m-1，主要分为下面三种探查方法：</p>
<h3 id="线性探查">线性探查</h3>
<p>将散列表T[0,1,…,m-1]看成是一个循环向量，若初始探查的地址为d(即h(key)=d)，则最长的探查序列为：</p>
<p><center> $d，d+l，d+2，…，m-1，0，1，…，d-1$ <center></center></center></p>
<p>散列函数为</p>
<p><center> $h(k,i)=(h^*(k)+i) \ mod \ m \ , \ i=0,1,…,m-1$ <center></center></center></p>
<p>探查过程终止于三种情况：</p>
<ol>
<li>若当前探查的单元为空，则表示查找失败（若是插入则将key写入其中）；</li>
<li>若当前探查的单元中含有key，则查找成功，但对于插入意味着失败；</li>
<li>若探查到T[d-1]时仍未发现空单元也未找到key，则无论是查找还是插入均意味着失败(此时表满)。</li>
</ol>
<p><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/直接寻址.jpg" alt=""> <center> </center></center></p>
<p>用线性探测法处理冲突，思路清晰，算法简单，但存在下列缺点：</p>
<ul>
<li>处理溢出需另编程序。一般可另外设立一个溢出表，专门存放哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。</li>
<li>按上述算法建立起来的哈希表，删除工作非常困难。假如要从哈希表中删除一个记录，按理应将这个记录所在位置置为空，但我们不能这样做，而只能标上已被删除的标记<code>DELETE</code>，否则，将会影响以后的查找。</li>
<li>线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长（即不同关键字值的哈希地址相邻在一起愈长），则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。</li>
</ul>
<p><strong>线性补偿探测法</strong><br>线性补偿探测法的基本思想是：将线性探测的步长从 1 改为 Q ，即将上述算法中的 </p>
<p>$h(k,i)=(h^”(k)+1) \ mod \ m$ 改为 $h(k,i)=(h^”(k)+Q) \ mod \ m$ </p>
<p>而且要求 Q 与 m 是<code>互质</code>的，以便能探测到哈希表中的所有单元。<br><br></p>
<hr>
<h3 id="二次探查">二次探查</h3>
<p>二次探查采用如下形式的散列函数：</p>
<p><center> $h(k,i)=(h^*(k)+c_1i+c_2i^2) \ mod \ m \ , \ i=0,1,…,m-1, \ c_2\not=0$ <center></center></center></p>
<p>其中$h^*(k)$是一个辅助散列函数，$c_1$和 $c_2$为辅助常数。初始的探查位置为$T[h^*(k)]$，后续的探查位置要加上一个偏移量，该偏移量以二次的方式依赖于探查序号i。这种探查方法的效果要比线性探查好很多，但是，为了能够充分利用散列表，$c_1$，$c_2$和 $m$的值要受到限制。此外，如果两个关键字的初始探查位置相同，那么它们的探查序列也是相同的。这一性质可导致一种轻度的群集，称为二次群集。<br><br></p>
<hr>
<h3 id="双重散列">双重散列</h3>
<p>双重散列是用于开放寻址最好的方法之一，它采用如下形式的散列函数：</p>
<p><center> $h(k,i)=(h_1(k)+ih_2(k)) \ mod \ m$ <center></center></center></p>
<p>为了能查找整个散列表，值$h_2(k)$要与表的大小m<code>互质</code>，确保这一条件成立的方法有两种</p>
<ol>
<li>取m为2的幂，并设计一个总产生奇数的$h_2$</li>
<li>取m为质数，并设计一个总是产生较m小的正整数的$h_2$</li>
</ol>
<p>例如下图所示，散列表大小为 $m=13$，$h_1(k)=k \ mod \ 13$, $h_2(k)=1+(k \ mod \ 11)$，因为$14\equiv1\ (mod\ 13)$，$14\equiv3\ (mod\ 11)$，故在探查了槽1和槽5并发现被占用后，关键字14被插入到空槽9中。</p>
<p><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/QQ图片20141215204708.png" alt=""> <center></center></center></p>
<p>双重散列法中用了$O(m^2)$种探查序列，而线性探查或二次探查中用了$O(m)$种，所以是一种改进。<br><br></p>
<hr>
<h3 id="开放寻址散列性能分析">开放寻址散列性能分析</h3>
<p>在开放寻址法中，每个槽位至多只有一个元素，因而 $n\leq m$，这意味着 $n \leq 1$<br>下面分析在<code>一致散列</code>假设下，用开放寻址法进行散列时预期的探查数</p>
<ul>
<li>给定一个装载因子为$a=n/m&lt;1$的开放寻址散列表，在<code>一次不成功</code>的查找中，期望的探查数至多为：$\frac{1}{(1-a)}$</li>
<li>给定一个装载因子为$a&lt;1$的开放寻址散列表，<code>一次成功</code>查找中的期望探查数至多为：$\frac{1}{a}·ln\frac{1}{1-a}$</li>
</ul>
<h2 id="Java代码实现">Java代码实现</h2>
<h3 id="Hashtable链地址法">Hashtable链地址法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Practice;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Objects;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{</div><div class="line">	<span class="keyword">private</span> Entry&lt;K, V&gt;[] table;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> threhold;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{</div><div class="line">		<span class="keyword">int</span> hash;</div><div class="line">		K key;</div><div class="line">		V value;</div><div class="line">		Entry next;</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="title">Entry</span>() {</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="title">Entry</span>(<span class="keyword">int</span> hash, K key, V value, Entry next) {</div><div class="line">			<span class="keyword">this</span>.hash = hash;</div><div class="line">			<span class="keyword">this</span>.key = key;</div><div class="line">			<span class="keyword">this</span>.value = value;</div><div class="line">			<span class="keyword">this</span>.next = next;</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> K <span class="title">getKey</span>() {</div><div class="line">			<span class="keyword">return</span> key;</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> V <span class="title">getValue</span>() {</div><div class="line">			<span class="keyword">return</span> value;</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> V <span class="title">setValue</span>(V value) {</div><div class="line">			<span class="keyword">if</span> (value == <span class="keyword">null</span>) {</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">			}</div><div class="line">			V old = <span class="keyword">this</span>.value;</div><div class="line">			<span class="keyword">this</span>.value = value;</div><div class="line">			<span class="keyword">return</span> old;</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span>(Object o) {</div><div class="line">			<span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Entry)) {</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			}</div><div class="line">			Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</div><div class="line">			<span class="keyword">return</span> (key == <span class="keyword">null</span> ? e.getKey() == <span class="keyword">null</span> : key.equals(e.getKey()))</div><div class="line">					&& (value == <span class="keyword">null</span> ? e.getValue() == <span class="keyword">null</span> : value.equals(e</div><div class="line">							.getValue()));</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashcode</span>() {</div><div class="line">			<span class="keyword">return</span> hash ^ Objects.hashCode(value);</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">			<span class="keyword">return</span> key.toString() + <span class="string">"="</span> + value.toString();</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">Hashtable</span>(<span class="keyword">int</span> initCapacity, <span class="keyword">float</span> loadFactor) {</div><div class="line">		<span class="keyword">if</span> (initCapacity &lt; <span class="number">0</span>)</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity"</span></div><div class="line">					+ initCapacity);</div><div class="line">		<span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load"</span> + loadFactor);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (initCapacity == <span class="number">0</span>)</div><div class="line">			initCapacity = <span class="number">1</span>;</div><div class="line">		<span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">		table = <span class="keyword">new</span> Entry[initCapacity];</div><div class="line">		threhold = (<span class="keyword">int</span>) Math</div><div class="line">				.min(initCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">Hashtable</span>(<span class="keyword">int</span> initCapacity) {</div><div class="line">		<span class="keyword">this</span>(initCapacity, <span class="number">0.75</span>f);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">Hashtable</span>() {</div><div class="line">		<span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75</span>f);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span>() {</div><div class="line">		<span class="keyword">return</span> count;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span>(K key, V value) {</div><div class="line">		<span class="keyword">if</span> (value == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">		}</div><div class="line"></div><div class="line">		Entry&lt;?, ?&gt; tab[] = table;</div><div class="line">		<span class="keyword">int</span> hash = key.hashCode();</div><div class="line">		<span class="keyword">int</span> index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">		<span class="keyword">for</span> (Entry&lt;K, V&gt; entry = (Entry&lt;K, V&gt;) tab[index]; entry != <span class="keyword">null</span>; entry = entry.next) {</div><div class="line">			<span class="keyword">if</span> ((entry.hash == hash) && entry.key.equals(key)) {</div><div class="line">				V old = entry.value;</div><div class="line">				entry.value = value;</div><div class="line">				<span class="keyword">return</span> old;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (count &gt; threhold) {</div><div class="line">			rehash();</div><div class="line">			tab = table;</div><div class="line">			hash = key.hashCode();</div><div class="line">			index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">		Entry&lt;K, V&gt; entry = (Entry&lt;K, V&gt;) tab[index];</div><div class="line">		tab[index] = <span class="keyword">new</span> Entry&lt;K, V&gt;(hash, key, value, entry);</div><div class="line">		count ++;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span>(Object key){</div><div class="line">		Entry&lt;?, ?&gt; tab[] = table;</div><div class="line">		<span class="keyword">int</span> hash = key.hashCode();</div><div class="line">		<span class="keyword">int</span> index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">		<span class="keyword">for</span> (Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) tab[index]; e != <span class="keyword">null</span> ; e = e.next) {</div><div class="line">			<span class="keyword">if</span> (e.hash == hash && e.key.equals(key)) {</div><div class="line">				<span class="keyword">return</span> e.value;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span>(){</div><div class="line">		<span class="keyword">int</span> oldCapacity = table.length;</div><div class="line">		Entry&lt;?, ?&gt;[] oldEntry = table;</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line">		</div><div class="line">		Entry[]	newMap = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity; i &gt; <span class="number">0</span>; i--) {</div><div class="line">			<span class="keyword">for</span> (Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) oldEntry[i];  e != <span class="keyword">null</span>; e = e.next) {</div><div class="line">				<span class="keyword">int</span> index = (e.hash & <span class="number">0x7FFFFFFF</span>) % newCapacity;</div><div class="line">				e.next = newMap[index];</div><div class="line">				newMap[index] = e;</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String arg[]) {</div><div class="line">        Hashtable&lt;String, String&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;String, String&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) {</div><div class="line">            hashtable.put(<span class="string">"lyx"</span> + i, <span class="string">"lyx"</span> + i);</div><div class="line">        }</div><div class="line"> </div><div class="line">        hashtable.put(<span class="string">"lyx0"</span>, <span class="string">"aaaaaaaaaaaaaaaaaaaaa"</span>);</div><div class="line">        hashtable.put(<span class="string">"lyx0"</span>, <span class="string">"aaaaaaaaaaaaaaaaaaaaa"</span>);</div><div class="line">        hashtable.put(<span class="string">"lyx0"</span>, <span class="string">"aaaaaaaaaaaaaaaaaaaaa"</span>);</div><div class="line">        hashtable.put(<span class="string">"lyx0"</span>, <span class="string">"aabbccdd"</span>);</div><div class="line"> </div><div class="line">        System.out.println(hashtable.get(<span class="string">"lyx0"</span>));</div><div class="line">        System.out.println(hashtable.get(<span class="string">"lyx1"</span>));</div><div class="line">        System.out.println(hashtable.get(<span class="string">"lyx2"</span>));</div><div class="line">        System.out.println(hashtable.get(<span class="string">"lyx3"</span>));</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>


<h3 id="线性探查-1">线性探查</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Practice;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.nio.BufferOverflowException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHash</span>&lt;<span class="title">T</span>&gt; </span>{</div><div class="line">	<span class="keyword">private</span> T[] table;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tableCapacity;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">LinearProbingHash</span>(<span class="keyword">int</span> tableSize){</div><div class="line">		table = (T[]) <span class="keyword">new</span> Object[tableSize];</div><div class="line">		<span class="keyword">this</span>.tableCapacity = tableSize;</div><div class="line">		size = <span class="number">0</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(T item){</div><div class="line">		<span class="keyword">int</span> index, originIndex;</div><div class="line">		index = (item.hashCode() & <span class="number">0x7FFFFFFF</span>) % tableCapacity;</div><div class="line">		originIndex = index;</div><div class="line">		do {</div><div class="line">			<span class="keyword">if</span> (table[index] == <span class="keyword">null</span> || table[index].equals(<span class="string">"DELETE"</span>)) {</div><div class="line">				table[index] = item;</div><div class="line">				size++;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				index = (index + <span class="number">1</span>) % tableCapacity;</div><div class="line">			}</div><div class="line">		} <span class="keyword">while</span> (index != originIndex);</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span>(T item){</div><div class="line">		<span class="keyword">int</span> index, originIndex;</div><div class="line">		index = (item.hashCode() & <span class="number">0x7FFFFFFF</span>) % tableCapacity;</div><div class="line">		originIndex = index;</div><div class="line">		do {</div><div class="line">			<span class="keyword">if</span> (table[index].equals(item)) {</div><div class="line">				table[index] = (T) <span class="string">"DELETE"</span>;</div><div class="line">				size--;</div><div class="line">				<span class="keyword">return</span> index;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				index = (index & <span class="number">0x7FFFFFFF</span>) % tableCapacity;</div><div class="line">			}</div><div class="line">		} <span class="keyword">while</span> (index != originIndex);</div><div class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span>(T item){</div><div class="line">		<span class="keyword">return</span> (find(item) &lt; <span class="number">0</span>) ? <span class="keyword">false</span> : <span class="keyword">true</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>(){</div><div class="line">		<span class="keyword">return</span> size;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span>(T item){</div><div class="line">		<span class="keyword">int</span> index, originIndex;</div><div class="line">		index = (item.hashCode() & <span class="number">0x7FFFFFFF</span>) % tableCapacity;</div><div class="line">		originIndex = index;</div><div class="line">		do {</div><div class="line">			<span class="keyword">if</span> (table[index].equals(item)) {</div><div class="line">				<span class="keyword">return</span> index;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				index = (index + <span class="number">1</span>) % tableCapacity;</div><div class="line">			}</div><div class="line">		} <span class="keyword">while</span> (index != originIndex);</div><div class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> String <span class="title">toString</span>() {  </div><div class="line">        <span class="keyword">int</span> max = tableCapacity - <span class="number">1</span>;  </div><div class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer();  </div><div class="line">        buf.append(<span class="string">"["</span>);  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tableCapacity; i++) {  </div><div class="line">            <span class="keyword">if</span>(table[i] != <span class="keyword">null</span>) {  </div><div class="line">                buf.append(table[i]);  </div><div class="line">                <span class="keyword">if</span>(i &lt; max)  </div><div class="line">                    buf.append(<span class="string">", "</span>);  </div><div class="line">            }  </div><div class="line">        }  </div><div class="line">        buf.append(<span class="string">"]"</span>);  </div><div class="line">        <span class="keyword">return</span> buf.toString();  </div><div class="line">    }  </div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {  </div><div class="line">        LinearProbingHash&lt;Integer&gt; lp = <span class="keyword">new</span> LinearProbingHash&lt;Integer&gt;(<span class="number">10</span>);  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">54</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">77</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">94</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">89</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">14</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">45</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">35</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">76</span>));  </div><div class="line">          </div><div class="line">        System.out.println(lp); <span class="comment">// [35, 76, 54, 94, 14, 77, 45, 89]  </span></div><div class="line">        System.out.println(lp.contains(<span class="keyword">new</span> Integer(<span class="number">45</span>))); <span class="comment">// true  </span></div><div class="line">        System.out.println(lp.size()); <span class="comment">// 8  </span></div><div class="line">        </div><div class="line">        lp.delete(<span class="keyword">new</span> Integer(<span class="number">77</span>));</div><div class="line">        System.out.println(lp); <span class="comment">// [35, 76, 54, 94, 14, DELETE, 45, 89]</span></div><div class="line">        System.out.println(lp.size()); <span class="comment">// 7</span></div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">100</span>));</div><div class="line">        System.out.println(lp); <span class="comment">// [35, 76, 100, 54, 94, 14, DELETE, 45, 89]</span></div><div class="line">        System.out.println(lp.size()); <span class="comment">// 8</span></div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[当多个关键字映射到同一槽位时，便发生哈希碰撞。主要解决方案有两种，一种是基于链表的链地址法，另一种则是开放寻址法。]]>
    
    </summary>
    
      <category term="hash" scheme="http://alexyyek.github.io/tags/hash/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[散列函数]]></title>
    <link href="http://alexyyek.github.io/2014/12/11/hash/"/>
    <id>http://alexyyek.github.io/2014/12/11/hash/</id>
    <published>2014-12-11T14:12:51.000Z</published>
    <updated>2014-12-15T10:31:00.000Z</updated>
    <content type="html"><![CDATA[<p>一个好的散列函数应满足<code>简单一致</code>散列的假设：每个关键字都等可能的散列到m个槽位的任何一个之中，并与其它的关键字已被散列到哪个槽位无关。</p>
<h2 id="除法散列法">除法散列法</h2>
<p>在用来设计散列函数的除法散列法中，通过取k除以m的余数，将关键字k映射到m个槽中的某一个上，即散列函数为:</p>
<p><center> $$h(k)=k mod m$$ <center></center></center></p>
<p>当应用除法散列法时，要避免选择m的某些值，m常常选择与近2的整数幂的不太接近的<code>素数</code>。<br><strong>Explain</strong>：如果 $m=2^p$，二进制除法相当于右位移<code>&gt;&gt;</code>，例如<code>111010&gt;&gt;3</code>,即除以$2^3$，右移3位变为<code>111</code>，<code>010</code>则作为余数被移除，故在做取余操作时值为<code>010</code>,即为k的p个最低位数字。</p>
<h2 id="乘法散列法">乘法散列法</h2>
<p>乘法散列法整体包含两步：</p>
<ul>
<li>用关键字k乘上常数<code>A(0&lt;A&lt;1)</code>，并去除kA的小数部分</li>
<li>用m乘以这个值，再取结果的底<code>floor</code><br>公式：    <code>h(k)=Math.floor[m(kA mod 1)]</code><br><center><img src="http://alexyoung.qiniudn.com/26822401_1334109664MN4j.png" alt=""><center></center></center></li>
</ul>
<p><strong>STEP</strong>：</p>
<ul>
<li>假设某计算机的字长为 $w$ 位，而 $k$ 正好可容于一个字中（$k&lt;2^w$)</li>
<li>现在选取范围$[0，2^w]$内的任意数值 $s$，$k×s$ 即可用$R_1·2^w+R_0$来表示</li>
<li>因此$(k·A) mod 1=k·s/2^w$就是将$k×s$整体向右平移 $w$ 位，此时$R_0$即为小数部分</li>
<li>再乘以$2^m$相当于左移 $m$ 位，散列值 $h(k)$ 为$R_0$的前m位。</li>
</ul>
<h2 id="全域散列">全域散列</h2>
<p>如果让某个与你作对的人来选择要散列的关键字，那么他会选择全部散列到同一槽位的n个关键字，使得<code>平均检索时间</code>为<code>O(n)</code>，任何一个特定的散列函数都无法避免这种最坏情况的发生。唯一有效的改进方法是<code>随机的选择散列函数</code>，使之独立于要存储的关键字，这便是全域散列(universal hashing)，无论对手如何选择关键字，平均性态都很好。</p>
<p><strong>步骤</strong></p>
<ul>
<li>选择一个足够大的<code>质数</code>$p$，使得每个关键字都落在 $[0, p-1]$ 范围内；</li>
<li>集合$Z_p$ = $\{0,1,…,p-1\}$，集合$Z^*_p$= $\{1,2,…,p-1\}$，对于任何 $a \in Z^*_p$，$b \in Z_p$，定义散列函数 $h_{a,b}$：</li>
</ul>
<p><center> $h_{a,b}(k) = ((ak+b)\ mod \ p)\ mod \ m$ <center></center></center></p>
<p>假定关键字的范围大于散列表的槽位数，即 $p&gt;m$，对 $a$而言有<code>p</code>种选择，对 $b$ 而言有<code>p-1</code>种可能，所以 $H_{a,b}$有<code>p(p-1)</code>种可能性。当随机的选择关键字$k \not= l$，两者发生碰撞的概率不大于<code>1/m</code>。</p>
<p><strong>Proof</strong>：<br>考虑 $Z_p $ 中两个不同的关键字 $k$ 和 $l$，即 $k \not= l$，对某一给定的随机散列函数$h_{a,b}$</p>
<p><center> $r=(ak+b)\ mod\ p$         ,      $s=(al+b)\ mod \ p$ <center></center></center></p>
<p>此处必有 $ r\not= s$，因为 $r-s = a(k-l)\ mod\ p$</p>
<p><code>p</code>为质数，故<code>a</code>和<code>k-l</code>模<code>p</code>均不为0，因此在模<code>p</code>这一层次上，尚不出现冲突。</p>
<p>故对于某个给定的<code>r</code>值，<code>s</code>的可能取值为余下的<code>p-1</code>种，其中满足$s \not= r$且$r \equiv s(mod \ p)$的值的数目至多为$(p-1)/m$，所以<code>s</code>与<code>r</code>发生碰撞的概率至多为 $((p-1)/m)/(p-1)=1/m$</p>
<p>$H_{a,b}$是全域的。</p>
<h2 id="完美哈希">完美哈希</h2>
<p>当键值是<code>static</code>(即固定不变)的时候，我们可以涉及方案使得最差情况下的查询性能也很出色，这就是完美哈希。实际上，很多地方都会用到静态关键字集合。比如一种语言的保留字集合，一张CD-ROM里的文件名集合。而完美哈希可以在<code>最坏情况</code>下以<code>O(1)</code>复杂度查找，性能非常出色的。<br>完美哈希的思想就是采用两级的框架，每一级上都用全域哈希：</p>
<p><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/30143317-b1a1356610cb4d6eb8cda2a1e9f36eba.png" alt=""> <center></center></center></p>
<p>完美哈希的结构如上图。具体来说，第一级和带链表的哈希非常的相似，只是第一级发生冲突后后面接的不是链表，而是一个新的哈希表。后面那个哈希结构，我们可以看到前端存储了一些哈希表的基本性质：$m$ 是哈希表槽数；$a,b$ 全域哈希函数要确定的两个值(一般是随机选然后确定下来的)，后面跟着哈希表。</p>
<p>为了保证不冲突，<strong>每个二级哈希表的数量是第一级映射到这个槽中元素个数的平方</strong>，这样可以保证整个哈希表非常的稀疏。下面给出一个定理，能更清楚的看到设置 $m=n^2$的作用。</p>
<p><strong>定理</strong>：设$H$是一类全域哈希函数，哈希表的槽数 $m=n^2$。 那么，如果我们用一个随机函数 $h \in H$把 $n$ 个keys映射到表中。冲突次数的期望最多是1/2.</p>
<p><strong>Proof</strong>：根据全域哈希的定义，对任意选出的哈希函数h，表中2个给定keys冲突的概率是 $1/m$,即 $1/n^2$<br>且总共有$C_2^n$可能的键值对，那么冲突次数的期望就是：</p>
<p><center> $C_2^n/n^2=n(n−1)/2·n^2 &lt; 1/2$   <center></center></center></p>
<p>证毕！</p>
]]></content>
    <summary type="html">
    <![CDATA[一个好的散列函数应满足简单一致散列的假设：每个关键字都等可能的散列到m个槽位的任何一个之中，并与其它的关键字已被散列到哪个槽位无关。]]>
    
    </summary>
    
      <category term="hash" scheme="http://alexyyek.github.io/tags/hash/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[中位数和顺序统计学]]></title>
    <link href="http://alexyyek.github.io/2014/12/08/select/"/>
    <id>http://alexyyek.github.io/2014/12/08/select/</id>
    <published>2014-12-08T13:38:01.000Z</published>
    <updated>2014-12-08T14:09:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="期望线性时间选择问题">期望线性时间选择问题</h2>
<p>从集合中选出第N大的数，RANDOMIZED-SELECT算法与快速排序类似，对输入数组进行递归划分，但RANDOMIZED-SELECT只处理划分的一边，因此快排的期望运行时间是<code>O(nlgn)</code>，而RANDOMIZED-SELECT<code>期望运行时间</code>只需要<code>O(n)</code> </p>
<p><strong>伪代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">RANDOMIZED-SELECT(A,p,r,i)</div><div class="line"><span class="keyword">if</span> p==r</div><div class="line">    <span class="keyword">return</span> A[p]</div><div class="line">q = RANDOM-PARTITION(A,p,r)</div><div class="line">k = q - p + <span class="number">1</span></div><div class="line"><span class="keyword">if</span> i=k</div><div class="line">    <span class="keyword">return</span> A[q]</div><div class="line">elseif i &lt; k</div><div class="line">    <span class="keyword">return</span> RANDOMIZED-SELECT(A,p,q-q,i)</div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> RANDOMIZED-SELECT(A,q+<span class="number">1</span>,r,i-k)</div></pre></td></tr></table></figure>

<hr>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		<span class="keyword">int</span>[] data ={<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>};</div><div class="line">		RandomizedSelect select = <span class="keyword">new</span> RandomizedSelect();</div><div class="line">		<span class="keyword">int</span> rank = <span class="number">9</span>;</div><div class="line">		System.out.println(select.select(data, <span class="number">0</span>, data.length-<span class="number">1</span>, rank));</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> rank){</div><div class="line">		<span class="keyword">if</span> (start == end) {</div><div class="line">			<span class="keyword">return</span> data[start];</div><div class="line">		}</div><div class="line">		<span class="keyword">int</span> threshold = randonPartition(data, start, end);</div><div class="line">		<span class="keyword">int</span> k = threshold - start + <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span> (rank == k) { </div><div class="line">			<span class="keyword">return</span> data[threshold];</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (rank &lt; k) {</div><div class="line">			<span class="keyword">return</span> select(data, start, threshold-<span class="number">1</span>, rank);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> select(data, threshold+<span class="number">1</span>, end, rank-k);</div><div class="line">		}</div><div class="line">		</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randonPartition</span>(<span class="keyword">int</span>[] data,<span class="keyword">int</span> start,<span class="keyword">int</span> end){</div><div class="line"> 		<span class="keyword">int</span> q = start + (<span class="keyword">int</span>)Math.random()*(end - start + <span class="number">1</span>);</div><div class="line"> 		<span class="keyword">int</span> temp = data[q];</div><div class="line"> 		data[q] = data[end];</div><div class="line"> 		data[end] = temp;</div><div class="line">		<span class="keyword">return</span> partition(data, start, end);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end){</div><div class="line">		<span class="keyword">int</span> value = data[end];</div><div class="line">		<span class="keyword">int</span> init = start - <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) {</div><div class="line">			<span class="keyword">if</span> (data[i] &lt; value) {</div><div class="line">				init++;</div><div class="line">				<span class="keyword">int</span> temp = data[init];</div><div class="line">				data[init] = data[i];</div><div class="line">				data[i] = temp;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">int</span> temp = data[end];</div><div class="line">		data[end] = data[init+<span class="number">1</span>];</div><div class="line">		data[init+<span class="number">1</span>] = temp;</div><div class="line">		<span class="keyword">return</span> init+<span class="number">1</span>;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>在最坏的情况下，例如：总是找到最小元素时，总是在最大元素处划分，这是时间复杂度为<code>O(n^2)</code>。但平均时间复杂度与n呈线性关系，为<code>O(n)</code></p>
<h2 id="最坏线性时间选择算法">最坏线性时间选择算法</h2>
<p>该算法利用了RANDOMIZED-SELECT对输入数组进行划分的思维，但不同之处在于该算法保证了数组的划分是好的划分。SELECT算法最坏情况运行时间为<code>O(n)</code></p>
<p><center><img src="http://alexyoung.qiniudn.com/1357624243_8923.jpg" alt=""><center></center></center></p>
<p>算法思路：如果能在线性时间内找到一个划分基准使得按这个基准所划分出的2个子数组的长度都至少为原数组长度的<code>ε</code>倍<code>(0&lt;ε&lt;1)</code>,那么就可以在最坏情况下用<code>O(n)</code>时间完成选择任务。例如，当<code>ε=9/10</code>，算法递归调用所产生的子数组的长度至少缩短1/10。所以，在最坏情况下，算法所需的计算时间<code>T(n)</code>满足递推式<code>T(n)&lt;=T(9n/10)+O(n)</code>。由此可得<code>T(n)=O(n)</code></p>
<p><br></p>
<hr>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Select</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		<span class="keyword">int</span> length = <span class="number">37</span>; <span class="keyword">int</span> rank = <span class="number">10</span>;<span class="comment">/* 37个元素中找出第10小的元素 */</span>  </div><div class="line">		<span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[length];</div><div class="line">		Random rm = <span class="keyword">new</span> Random();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</div><div class="line">			data[i] = rm.nextInt(<span class="number">100</span>);</div><div class="line">		}</div><div class="line">		</div><div class="line">		Select select =  <span class="keyword">new</span> Select();</div><div class="line">		System.out.println(Arrays.toString(data));</div><div class="line">		System.out.println(select.select(data, <span class="number">0</span>, length-<span class="number">1</span>, rank));</div><div class="line">		Arrays.sort(data);</div><div class="line">		System.out.println(Arrays.toString(data));</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> <span class="title">select</span>(<span class="keyword">int</span>[] data,<span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> rank){</div><div class="line">		<span class="keyword">if</span> ((high-low)&lt;<span class="number">5</span>) {</div><div class="line">			insertSort(data, low, high);</div><div class="line">			<span class="keyword">return</span> data[low+rank-<span class="number">1</span>];</div><div class="line">		}</div><div class="line">		<span class="keyword">int</span> group = (high - low + <span class="number">5</span>) / <span class="number">5</span>;</div><div class="line">		<span class="comment">/* 第一步：将输入数组的n个元素划分为n/5组，每组5个元素，且至多只有一个组由剩下的n mod5个元素组成 */</span>  </div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group; i++) {</div><div class="line">			<span class="keyword">int</span> left = low + i*<span class="number">5</span>;</div><div class="line">			<span class="keyword">int</span> right = (low + i*<span class="number">5</span> + <span class="number">4</span>) &gt; high ? high : (low + i*<span class="number">5</span> + <span class="number">4</span>);</div><div class="line">			<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</div><div class="line">		<span class="comment">/* 第二步：寻找(n+4)/5个组中每一组的中位数。首先对每组中的元素（至多为5个）进行插入排序，然后从排序过的序列中选出中位数 */</span>  </div><div class="line">			insertSort(data, left, right);</div><div class="line">			swap(data, low+i, mid);<span class="comment">// 将中位数置前 </span></div><div class="line">		}</div><div class="line">		<span class="comment">/* 第三步：对第二步中找出的(n+4)/5个中位数，递归调用select以找出其中位数x*/</span>  </div><div class="line">		<span class="keyword">int</span> pivot = select(data, low, low+group-<span class="number">1</span>, (group+<span class="number">1</span>)/<span class="number">2</span>);</div><div class="line">		<span class="comment">/* 第四步：利用修改过的partition过程，按中位数的中位数x对输入数组进行划分 */</span></div><div class="line">		<span class="keyword">int</span> threshold = partition(data, low, high, pivot);</div><div class="line">		<span class="comment">/* 第五步：判断threshold位置是否为要找的数，若不是则在低区或者高区递归select*/</span> </div><div class="line">		<span class="keyword">int</span> k = threshold - low + <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span> (k == rank) {</div><div class="line">			<span class="keyword">return</span> data[threshold];</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (k &gt; rank) {</div><div class="line">			<span class="keyword">return</span> select(data, low, threshold-<span class="number">1</span>, rank);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> select(data, threshold+<span class="number">1</span>, high, rank-k);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> pivot){</div><div class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">		<span class="comment">/* 找到枢纽的位置index */</span>  </div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt;= high; i++) {</div><div class="line">			<span class="keyword">if</span> (data[i] == pivot) {</div><div class="line">				index = i;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		swap(data, index, high);</div><div class="line">		<span class="keyword">int</span> init = low - <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; i++) {</div><div class="line">			<span class="keyword">if</span> (data[i] &lt; pivot) {</div><div class="line">				init++;</div><div class="line">				swap(data, init, i);</div><div class="line">			}</div><div class="line">		}</div><div class="line">		swap(data, init+<span class="number">1</span>, high);</div><div class="line">		<span class="keyword">return</span> init+<span class="number">1</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> a, <span class="keyword">int</span> b){</div><div class="line">		<span class="keyword">int</span> temp = data[a];</div><div class="line">		data[a] = data[b];</div><div class="line">		data[b] = temp;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span>(<span class="keyword">int</span>[] data,<span class="keyword">int</span> low,<span class="keyword">int</span> high){</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = low+<span class="number">1</span>; i &lt;= high; i++) {</div><div class="line">			<span class="keyword">int</span> key = data[i];</div><div class="line">			<span class="keyword">int</span> k = i - <span class="number">1</span>;</div><div class="line">			<span class="keyword">while</span> (k &gt;= low && data[k] &gt; key) {</div><div class="line">				data[k+<span class="number">1</span>] = data[k];</div><div class="line">				k--;</div><div class="line">			}</div><div class="line">			data[k+<span class="number">1</span>] = key;</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[从一个由N个不同数值构成的集合中选择其第i个顺序统计量。]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线性时间排序]]></title>
    <link href="http://alexyyek.github.io/2014/12/07/lineSort/"/>
    <id>http://alexyyek.github.io/2014/12/07/lineSort/</id>
    <published>2014-12-07T13:43:08.000Z</published>
    <updated>2014-12-07T14:19:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="快速排序算法">快速排序算法</h2>
<ul>
<li>分解<br>数组<code>A[p..r]</code>被划分为两个子数组，<code>A[p..q-1]</code>和<code>A[q+1..r]</code>，使得<code>A[p..q-1]</code>中每个元素都小于等于<code>A(q)</code>，且小于等于<code>A[q+1..r]</code>中元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">QUICKSORT(A,p,r)</div><div class="line"><span class="comment">//正常方法</span></div><div class="line"><span class="keyword">if</span> (p &lt; r){</div><div class="line">    then q = PARTITION(A,p,r)</div><div class="line">    QUICKSORT(A,p,q-<span class="number">1</span>)</div><div class="line">    QUICKSORT(A,q+<span class="number">1</span>,r)</div><div class="line">}</div><div class="line"><span class="comment">//尾递归方法</span></div><div class="line"><span class="keyword">while</span> (start &lt; end) {</div><div class="line">	<span class="keyword">int</span> q = partition(data, start, end);</div><div class="line">	quickSort(data, start, q-<span class="number">1</span>);</div><div class="line">	start = q + <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>解决<br>通过递归调用，两个子数组各自内部排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PARTITION(A,p,r)</div><div class="line">x = A[r]</div><div class="line">i = p-<span class="number">1</span></div><div class="line"><span class="keyword">for</span> j=p to r-<span class="number">1</span></div><div class="line">    <span class="keyword">if</span> A[j] &lt; x</div><div class="line">    i++</div><div class="line">    A[j]=A[i]</div><div class="line">exchange A[i+<span class="number">1</span>] ↔ A[r]</div><div class="line"><span class="keyword">return</span> i+<span class="number">1</span></div></pre></td></tr></table></figure>

<p>因为子数组是内部排序，所以无需合并操作，平均时间复杂度<code>O(nlgn)</code></p>
<h2 id="线性时间排序">线性时间排序</h2>
<p>之前的排序算法都属于<code>比较排序</code>，任何比较排序在最坏的情况下都要做<code>Ω(nlgn)</code>次比较来进行排序，下面介绍三种线性时间运行的排序</p>
<h3 id="计数排序">计数排序</h3>
<p>计数排序的前提是确定输入范围大小为0～k。在这个前提下，我们可以使用计数的方法对数组进行排序，而不是使用比较。算法思想如下：因为输入数组A中的元素范围固定，因此可以使用一个大小为k的数组C对A中的元素进行映射。</p>
<p><center><img src="http://alexyoung.qiniudn.com/QQ图片201412007210801.png" alt=""><center></center></center></p>
<p><strong>伪代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">COUNTING-SORT(A,B,k)</div><div class="line"><span class="keyword">for</span> i←<span class="number">0</span> to k</div><div class="line">    do C[i] = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> j←<span class="number">1</span> to length[A]</div><div class="line">    do C[A[j]] = C[A[j]] + <span class="number">1</span></div><div class="line">    C[i]中包含等于i的元素个数</div><div class="line"><span class="keyword">for</span> i←<span class="number">1</span> to k</div><div class="line">    C[i] = C[i-<span class="number">1</span>] + C[i]</div><div class="line"><span class="keyword">for</span> j←<span class="number">1</span> to length[A]</div><div class="line">    do B[C[A[j]]] = A[j]</div><div class="line">    C[A[j]]--</div></pre></td></tr></table></figure>

<h3 id="基数排序">基数排序</h3>
<p>实现原理：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。给定n个d位数，每一个数位有k种可能取值，基数排序能以<code>O(d(n+k))</code>的时间正确排序。<br>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>
<p><center><img src="http://alexyoung.qiniudn.com/1338051031_6070.jpg" alt=""><center></center></center></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> radix){</div><div class="line">		<span class="keyword">int</span> queue = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> bit = <span class="number">1</span>; <span class="comment">//数位</span></div><div class="line">		<span class="keyword">int</span> position = <span class="number">1</span>;<span class="comment">//当前数位</span></div><div class="line">		<span class="keyword">int</span>[][] reminder = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][data.length];</div><div class="line">		<span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line">		</div><div class="line">		<span class="keyword">while</span> (position &lt;= radix) {</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) {</div><div class="line">				<span class="keyword">int</span> lsd = (data[i] / bit) % <span class="number">10</span>;</div><div class="line">				reminder[lsd][order[lsd]] = data[i];</div><div class="line">				order[lsd]++;</div><div class="line">			}</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</div><div class="line">				<span class="keyword">if</span> (order[i] != <span class="number">0</span>) {</div><div class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; order[i]; j++) {</div><div class="line">						data[queue++] = reminder[i][j];</div><div class="line">					}</div><div class="line">				}</div><div class="line">				order[i] = <span class="number">0</span>;</div><div class="line">			}</div><div class="line">			bit *= <span class="number">10</span>;</div><div class="line">			queue = <span class="number">0</span>;</div><div class="line">			position++;</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="桶排序">桶排序</h3>
<p>桶排序的思想是把区间[0,1)划分成n个相同大小的子区间，称为桶，然后将n个输入数分布到各个桶中去。因为输入数均匀且独立分布在[0,1)上，所以，一般不会有很多数落在一个桶中的情况。为了得到结果，先对各个桶中的数进行排序，然后按次序把各桶中的元素列出来。桶排序的时间复杂度为<code>O(n)</code></p>
<p><center><img src="http://alexyoung.qiniudn.com/bucket_sort.PNG" alt=""><center></center></center></p>
<p><strong>伪代码</strong></p>
<figure class="highlight JAVA"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BUCKET-SORT(A)</div><div class="line">n = length(A)</div><div class="line"><span class="keyword">for</span> i=<span class="number">1</span> to n</div><div class="line">    do insert A[i] to list Math.floor(B[n*A[i]])</div><div class="line"><span class="keyword">for</span> i=<span class="number">1</span> to n</div><div class="line">    do sort list B[i] (recommand Collections.sort)</div><div class="line">concatenate the list B[<span class="number">1</span>] to B[n] INTO A</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[不同于比较排序O(lgn)的时间复杂度，线性时间排序可以在O(n)的时间完成排序。]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HeapSort]]></title>
    <link href="http://alexyyek.github.io/2014/12/07/heap/"/>
    <id>http://alexyyek.github.io/2014/12/07/heap/</id>
    <published>2014-12-07T06:52:35.000Z</published>
    <updated>2014-12-07T07:00:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="堆排序">堆排序</h2>
<p>堆数据结构是一种数组对象，它可以被视为一颗完全二叉树，树中每个节点与数组中存放该节点值的元素对应。堆分为大根堆和小根堆；大根堆是指除根节点以外每个节点<code>i</code>都有<code>A[parent(i)]&gt;=A[i]</code>，即每个节点的值最多和父节点的值一样大，这样堆中的最大值就在根节点中，且以某个节点为根的子树中，各个节点的值都不大于该子树根节点的值，图1就是一个大根堆。小根堆的刚好相反，每个节点的值都不小于其父节点。</p>
<center><img src="http://alexyoung.qiniudn.com/B44BD10DE99C61C6E965337C8EFFBE6A_B500_900_392_301.PNG" alt=""></center>

<h3 id="保持堆的性质">保持堆的性质</h3>
<p><strong>maxHeapify</strong>是对大根堆进行操作的重要子程序，其输入为一个数组A和一个下标i，maxHeapify被调用时假定left(i)和right(i)都满足大根堆的性质，但是A[i]有可能小于其子女而违反了大根堆性质，maxHeapify使A[i]下降，使以A[i]为根的堆成为大根堆。其过程如图 2所示：<br><img src="http://alexyoung.qiniudn.com/CBDE478800037BD91BF72E29598EFEBD_B500_900_500_341.PNG" alt=""><br><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> length, <span class="keyword">int</span> index){</div><div class="line">		<span class="keyword">int</span> left = getLeftChildIndex(index);</div><div class="line">		<span class="keyword">int</span> right = getRightChildIndex(index);</div><div class="line">		<span class="keyword">int</span> largest = index;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (left &lt; length && data[left] &gt; data[index]) {</div><div class="line">			largest = left;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (right &lt; length && data[right] &gt; data[largest]) {</div><div class="line">			largest = right;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (largest != index) {</div><div class="line">			<span class="keyword">int</span> temp = data[index];</div><div class="line">			data[index] = data[largest];</div><div class="line">			data[largest] = temp;</div><div class="line">			maxHeapify(data, length, largest);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="建堆">建堆</h3>
<p><strong>buildMaxHeap</strong>算法是利用maxHeapify算法来进行的。用数组存储一个有n个元素堆时，叶节点的下标是n/2+1、n/2+2……n（这里就不做证明了，有兴趣可以自己证明），建立大根堆就是利用这个性质。叶节点可以看做只有一个元素的堆，只有一个元素也就自然满足大根堆的性质，所以以叶节点为根的堆都是大根堆。但是以其它节点为根的堆就不一定是大根堆，为了使他们满足大根堆的性质，就在节点上调用maxHeapify（叶节点是大根堆就满足了函数输入时的条件）。所以建立大根堆的过程就是在除叶节点以为的节点上调用maxHeapify。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span>(<span class="keyword">int</span>[] data){</div><div class="line">		<span class="keyword">int</span> start = getParentIndex(data.length);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &gt;= <span class="number">0</span>; i--) {</div><div class="line">			maxHeapify(data, data.length, i);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="堆排序-1">堆排序</h3>
<p><strong>heapSort</strong>也是利用maxHeapify算法来进行的。在一个大根堆中，最大元素就是堆的根。堆排序就是利用的这个性质。在一个含有n个元素的数组上调用buildMaxHeap，就能得到最大的元素，然后将最大的元素和数组的尾部，再将最大元素从堆中除去，此时堆的元素为n-1个，但是不满足大根堆的性质，就在根节点上调用maxHeapify使其成为大根堆。不断重复这个过程直到堆中只剩下一个元素，就完成了排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span>(<span class="keyword">int</span>[] data){</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = data.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) {</div><div class="line">			<span class="keyword">int</span> temp = data[<span class="number">0</span>];</div><div class="line">			data[<span class="number">0</span>]	= data[i];</div><div class="line">			data[i] = temp;</div><div class="line">			maxHeapify(data, i, <span class="number">0</span>);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h2 id="优先级队列">优先级队列</h2>
<p>优先级队列是一种用来维护由一组数组元素构成集合S的数据结构，每个元素都有一个关键字key。</p>
<ul>
<li>INSERT(S,x)：元素x插入集合S</li>
<li>MAXIMUN(S)：返回S中具有最大key的元素</li>
<li>EXTRACT-MAX(S)：去掉并返回S中具有最大key的元素</li>
<li>INCREASE-KEY(S,x,k)：将元素x的key值增加到k，k&gt;=key</li>
</ul>
<h3 id="伪代码">伪代码</h3>
<p>HEAP-MAXIMUN(A)，时间复杂度<code>O(1)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> A[<span class="number">1</span>];</div></pre></td></tr></table></figure>

<p>HEAP-EXTRACT-MAX(A)，时间复杂度<code>O(lgn)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> heap-size[A]&lt;<span class="number">1</span></div><div class="line">    then error <span class="string">"heap underflow"</span></div><div class="line">max ← A[<span class="number">1</span>]</div><div class="line">A[<span class="number">1</span>] ← A[heap-size[A]]</div><div class="line">heap-size[A] ← heap-size[A]-<span class="number">1</span></div><div class="line">MAX-HEAPIFY(A,<span class="number">1</span>)</div><div class="line"><span class="keyword">return</span> max</div></pre></td></tr></table></figure>

<p>HEAP-INCREASE-KEY(A,i,key)，时间复杂度<code>O(lgn)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> key&lt;A[i]</div><div class="line">    then error <span class="string">"new key is smaller than the current key"</span></div><div class="line">A[i] ← key</div><div class="line"><span class="keyword">while</span> i&gt;<span class="number">1</span> && A[parent[i]]&lt;A[i]</div><div class="line">    do exchange A[i] ↔ A[parent[i]]</div><div class="line">    i ← parent(i)</div></pre></td></tr></table></figure>

<p>HEAP-INSERT(A,key)，时间复杂度<code>O(lgn)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">heap-size[A] ← heap-size[A]+<span class="number">1</span></div><div class="line">A[heap-size[A]] ← -∞</div><div class="line">HEAP-INCREASE-KEY(A,heap-size[A],key)</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[堆数据结构是一种数组对象，它可以被视为一颗完全二叉树，树中每个节点与数组中存放该节点值的元素对应。]]>
    
    </summary>
    
      <category term="heap" scheme="http://alexyyek.github.io/tags/heap/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Count And Say]]></title>
    <link href="http://alexyyek.github.io/2014/12/06/CountAndSay/"/>
    <id>http://alexyyek.github.io/2014/12/06/CountAndSay/</id>
    <published>2014-12-06T09:31:42.000Z</published>
    <updated>2014-12-06T09:46:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Count_and_Say">Count and Say</h2>
<p>Question : The count-and-say sequence is the sequence of integers beginning as follows:<br><code>1, 11, 21, 1211, 111221, ...</code></p>
<p><code>1</code> is read off as <code>one 1</code> or <code>11</code>.<br><code>11</code> is read off as <code>two 1s</code> or <code>21</code>.<br><code>21</code> is read off as <code>one 2, then one 1</code> or <code>1211</code>.<br>Given an integer <code>n</code>, generate the nth sequence.<br><a id="more"></a> </p>
<h3 id="Best_solution">Best solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">countAndSay</span>(<span class="keyword">int</span> n) {</div><div class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line"></div><div class="line">	String first = <span class="string">"1"</span>;</div><div class="line">	<span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; first.length(); j++) {</div><div class="line">			<span class="keyword">if</span> (j &lt; first.length() - <span class="number">1</span></div><div class="line">					&& (first.charAt(j) == first.charAt(j + <span class="number">1</span>))) {</div><div class="line">				count++;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				sb.append(count + <span class="string">""</span> + first.charAt(j));</div><div class="line">				count = <span class="number">1</span>;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		first = sb.toString();</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> first;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>Analyze</strong> : 题目非常简单，序列迭代规则已经列出，求第n次迭代的值。基本方法判断相邻两个字符是否一样，算出每一次的序列值，迭代到n次为止。其实也可以用递归的方法来做，给出第n-1次的规则，求第n次的值。<br><br></p>
<hr>
<p>比较有意思的是用DFS的思想来解决此题，代码如下：</p>
<h3 id="DFS">DFS</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> String s = <span class="string">"1"</span>;</div><div class="line"><span class="keyword">public</span> String <span class="title">countSay</span>(<span class="keyword">int</span> n) {</div><div class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</div><div class="line">        dfs(s.length());</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span>(<span class="keyword">int</span> length) {</div><div class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">1</span>, i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (i &lt; length - <span class="number">1</span> && s.charAt(i) == s.charAt(<span class="number">1</span> + i)) {</div><div class="line">        count++;</div><div class="line">        i++;</div><div class="line">    }</div><div class="line">    s = s.substring(i + <span class="number">1</span>) + count + s.charAt(i);</div><div class="line">    dfs(length - count);</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>Analyze</strong> : 深度优先算法的思路也很简单，比如第4次迭代结果为1211，现在进行第5次迭代</p>
<ul>
<li>树<code>1-2-1-1</code>根节点为<code>1</code>，出现一次所以值变成<code>11</code>,树变成<code>2-1-1</code>，所以整体值为<code>21111</code>；</li>
<li>第二次运算<code>2</code>出现一次，值为<code>12</code>，树还剩<code>1-1</code>，所以整体值为<code>111112</code>，注意这里前面11是待统计的树<code>1-1</code>,中间的11是第一次的运算值，最后的12是第二次的运算值；</li>
<li>由于树<code>1-1</code>中<code>1</code>出现了两次，所以值为<code>21</code>，s = s.substring(i + 1) + count + s.charAt(i) = 111221</li>
</ul>
<h3 id="More">More</h3>
<p>这道题在leetcode上的表述略有不清，我第一次就把此题误解为给定任意整数n，去求此整数的第n次迭代值<br>比如5-&gt;15-&gt;1115-&gt;3115-&gt;132115-&gt;1113122115，结果发现高估此题了…<br>既然都写了就列在下面吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">countAndSay</span>(<span class="keyword">int</span> n) {</div><div class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>) {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	String word = String.valueOf(n);</div><div class="line">	<span class="keyword">while</span> (n &gt; <span class="number">0</span>) {</div><div class="line">		<span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">		StringBuffer sBuffer = <span class="keyword">new</span> StringBuffer();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) {</div><div class="line">			<span class="keyword">if</span> (i &lt; word.length() - <span class="number">1</span></div><div class="line">					&& word.charAt(i) == word.charAt(i + <span class="number">1</span>)) {</div><div class="line">				count++;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				sBuffer.append(count).append(word.charAt(i));</div><div class="line">				count = <span class="number">1</span>;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		word = sBuffer.toString();</div><div class="line">		n--;</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> word;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[The count-and-say sequence is the sequence of integers beginning as follows 1, 11, 21, 1211, 111221, ... , Given an integer n, generate the nth sequence.]]>
    
    </summary>
    
      <category term="dfs" scheme="http://alexyyek.github.io/tags/dfs/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Trapping Rain Water]]></title>
    <link href="http://alexyyek.github.io/2014/12/04/TrappingRainWater/"/>
    <id>http://alexyyek.github.io/2014/12/04/TrappingRainWater/</id>
    <published>2014-12-04T07:17:18.000Z</published>
    <updated>2014-12-04T07:49:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Trapping_Rain_Water">Trapping Rain Water</h2>
<p>Question : Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br><a id="more"></a><br>For example:<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><img src="http://leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png" alt=""></p>
<h3 id="Best_Solution">Best Solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span>(<span class="keyword">int</span>[] A) {</div><div class="line">		<span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> b = A.length - <span class="number">1</span>;</div><div class="line">		<span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> leftmax = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> rightmax = <span class="number">0</span>;</div><div class="line">		<span class="keyword">while</span> (a &lt;= b) {</div><div class="line">			leftmax = Math.max(leftmax, A[a]);</div><div class="line">			rightmax = Math.max(rightmax, A[b]);</div><div class="line">			<span class="keyword">if</span> (leftmax &lt; rightmax) {</div><div class="line">				max += (leftmax - A[a]); </div><div class="line">				a++;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				max += (rightmax - A[b]);</div><div class="line">				b--;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> max;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>Analyze</strong> : I calculated the stored water at each index a and b in my code. At the start of every loop, I update the current maximum height from left side (that is from A[0,1…a]) and the maximum height from right side(from A[b,b+1…n-1]). if(leftmax &lt; rightmax) then, at least (leftmax-A[a]) water can definitely be stored no matter what happens between [a,b] since we know there is a barrier at the rightside(rightmax &gt; leftmax).</p>
]]></content>
    <summary type="html">
    <![CDATA[Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.]]>
    
    </summary>
    
      <category term="Arrays" scheme="http://alexyyek.github.io/tags/Arrays/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
</feed>
