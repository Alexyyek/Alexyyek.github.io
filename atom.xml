<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[AlexYoung's blog]]></title>
  <subtitle><![CDATA[Do Not Go Gentle Into Life]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://alexyyek.github.io/"/>
  <updated>2014-12-07T14:19:27.615Z</updated>
  <id>http://alexyyek.github.io/</id>
  
  <author>
    <name><![CDATA[AlexYoung]]></name>
    <email><![CDATA[alexyyek@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[线性时间排序]]></title>
    <link href="http://alexyyek.github.io/2014/12/07/lineSort/"/>
    <id>http://alexyyek.github.io/2014/12/07/lineSort/</id>
    <published>2014-12-07T13:43:08.000Z</published>
    <updated>2014-12-07T14:19:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="快速排序算法">快速排序算法</h2>
<ul>
<li>分解<br>数组<code>A[p..r]</code>被划分为两个子数组，<code>A[p..q-1]</code>和<code>A[q+1..r]</code>，使得<code>A[p..q-1]</code>中每个元素都小于等于<code>A(q)</code>，且小于等于<code>A[q+1..r]</code>中元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">QUICKSORT(A,p,r)</div><div class="line"><span class="comment">//正常方法</span></div><div class="line"><span class="keyword">if</span> (p &lt; r){</div><div class="line">    then q = PARTITION(A,p,r)</div><div class="line">    QUICKSORT(A,p,q-<span class="number">1</span>)</div><div class="line">    QUICKSORT(A,q+<span class="number">1</span>,r)</div><div class="line">}</div><div class="line"><span class="comment">//尾递归方法</span></div><div class="line"><span class="keyword">while</span> (start &lt; end) {</div><div class="line">	<span class="keyword">int</span> q = partition(data, start, end);</div><div class="line">	quickSort(data, start, q-<span class="number">1</span>);</div><div class="line">	start = q + <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>解决<br>通过递归调用，两个子数组各自内部排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PARTITION(A,p,r)</div><div class="line">x = A[r]</div><div class="line">i = p-<span class="number">1</span></div><div class="line"><span class="keyword">for</span> j=p to r-<span class="number">1</span></div><div class="line">    <span class="keyword">if</span> A[j] &lt; x</div><div class="line">    i++</div><div class="line">    A[j]=A[i]</div><div class="line">exchange A[i+<span class="number">1</span>] ↔ A[r]</div><div class="line"><span class="keyword">return</span> i+<span class="number">1</span></div></pre></td></tr></table></figure>

<p>因为子数组是内部排序，所以无需合并操作，平均时间复杂度<code>O(nlgn)</code></p>
<h2 id="线性时间排序">线性时间排序</h2>
<p>之前的排序算法都属于<code>比较排序</code>，任何比较排序在最坏的情况下都要做<code>Ω(nlgn)</code>次比较来进行排序，下面介绍三种线性时间运行的排序</p>
<h3 id="计数排序">计数排序</h3>
<p>计数排序的前提是确定输入范围大小为0～k。在这个前提下，我们可以使用计数的方法对数组进行排序，而不是使用比较。算法思想如下：因为输入数组A中的元素范围固定，因此可以使用一个大小为k的数组C对A中的元素进行映射。</p>
<p><center><img src="http://alexyoung.qiniudn.com/QQ图片201412007210801.png" alt=""><center></center></center></p>
<p><strong>伪代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">COUNTING-SORT(A,B,k)</div><div class="line"><span class="keyword">for</span> i←<span class="number">0</span> to k</div><div class="line">    do C[i] = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> j←<span class="number">1</span> to length[A]</div><div class="line">    do C[A[j]] = C[A[j]] + <span class="number">1</span></div><div class="line">    C[i]中包含等于i的元素个数</div><div class="line"><span class="keyword">for</span> i←<span class="number">1</span> to k</div><div class="line">    C[i] = C[i-<span class="number">1</span>] + C[i]</div><div class="line"><span class="keyword">for</span> j←<span class="number">1</span> to length[A]</div><div class="line">    do B[C[A[j]]] = A[j]</div><div class="line">    C[A[j]]--</div></pre></td></tr></table></figure>

<h3 id="基数排序">基数排序</h3>
<p>实现原理：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。给定n个d位数，每一个数位有k种可能取值，基数排序能以<code>O(d(n+k))</code>的时间正确排序。<br>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>
<p><center><img src="http://alexyoung.qiniudn.com/1338051031_6070.jpg" alt=""><center></center></center></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> radix){</div><div class="line">		<span class="keyword">int</span> queue = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> bit = <span class="number">1</span>; <span class="comment">//数位</span></div><div class="line">		<span class="keyword">int</span> position = <span class="number">1</span>;<span class="comment">//当前数位</span></div><div class="line">		<span class="keyword">int</span>[][] reminder = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][data.length];</div><div class="line">		<span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line">		</div><div class="line">		<span class="keyword">while</span> (position &lt;= radix) {</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) {</div><div class="line">				<span class="keyword">int</span> lsd = (data[i] / bit) % <span class="number">10</span>;</div><div class="line">				reminder[lsd][order[lsd]] = data[i];</div><div class="line">				order[lsd]++;</div><div class="line">			}</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</div><div class="line">				<span class="keyword">if</span> (order[i] != <span class="number">0</span>) {</div><div class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; order[i]; j++) {</div><div class="line">						data[queue++] = reminder[i][j];</div><div class="line">					}</div><div class="line">				}</div><div class="line">				order[i] = <span class="number">0</span>;</div><div class="line">			}</div><div class="line">			bit *= <span class="number">10</span>;</div><div class="line">			queue = <span class="number">0</span>;</div><div class="line">			position++;</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="桶排序">桶排序</h3>
<p>桶排序的思想是把区间[0,1)划分成n个相同大小的子区间，称为桶，然后将n个输入数分布到各个桶中去。因为输入数均匀且独立分布在[0,1)上，所以，一般不会有很多数落在一个桶中的情况。为了得到结果，先对各个桶中的数进行排序，然后按次序把各桶中的元素列出来。桶排序的时间复杂度为<code>O(n)</code></p>
<p><center><img src="http://alexyoung.qiniudn.com/bucket_sort.PNG" alt=""><center></center></center></p>
<p><strong>伪代码</strong></p>
<figure class="highlight JAVA"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BUCKET-SORT(A)</div><div class="line">n = length(A)</div><div class="line"><span class="keyword">for</span> i=<span class="number">1</span> to n</div><div class="line">    do insert A[i] to list Math.floor(B[n*A[i]])</div><div class="line"><span class="keyword">for</span> i=<span class="number">1</span> to n</div><div class="line">    do sort list B[i] (recommand Collections.sort)</div><div class="line">concatenate the list B[<span class="number">1</span>] to B[n] INTO A</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[不同于比较排序O(lgn)的时间复杂度，线性时间排序可以在O(n)的时间完成排序。]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HeapSort]]></title>
    <link href="http://alexyyek.github.io/2014/12/07/heap/"/>
    <id>http://alexyyek.github.io/2014/12/07/heap/</id>
    <published>2014-12-07T06:52:35.000Z</published>
    <updated>2014-12-07T07:00:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="堆排序">堆排序</h2>
<p>堆数据结构是一种数组对象，它可以被视为一颗完全二叉树，树中每个节点与数组中存放该节点值的元素对应。堆分为大根堆和小根堆；大根堆是指除根节点以外每个节点<code>i</code>都有<code>A[parent(i)]&gt;=A[i]</code>，即每个节点的值最多和父节点的值一样大，这样堆中的最大值就在根节点中，且以某个节点为根的子树中，各个节点的值都不大于该子树根节点的值，图1就是一个大根堆。小根堆的刚好相反，每个节点的值都不小于其父节点。</p>
<center><img src="http://alexyoung.qiniudn.com/B44BD10DE99C61C6E965337C8EFFBE6A_B500_900_392_301.PNG" alt=""></center>

<h3 id="保持堆的性质">保持堆的性质</h3>
<p><strong>maxHeapify</strong>是对大根堆进行操作的重要子程序，其输入为一个数组A和一个下标i，maxHeapify被调用时假定left(i)和right(i)都满足大根堆的性质，但是A[i]有可能小于其子女而违反了大根堆性质，maxHeapify使A[i]下降，使以A[i]为根的堆成为大根堆。其过程如图 2所示：<br><img src="http://alexyoung.qiniudn.com/CBDE478800037BD91BF72E29598EFEBD_B500_900_500_341.PNG" alt=""><br><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> length, <span class="keyword">int</span> index){</div><div class="line">		<span class="keyword">int</span> left = getLeftChildIndex(index);</div><div class="line">		<span class="keyword">int</span> right = getRightChildIndex(index);</div><div class="line">		<span class="keyword">int</span> largest = index;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (left &lt; length && data[left] &gt; data[index]) {</div><div class="line">			largest = left;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (right &lt; length && data[right] &gt; data[largest]) {</div><div class="line">			largest = right;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (largest != index) {</div><div class="line">			<span class="keyword">int</span> temp = data[index];</div><div class="line">			data[index] = data[largest];</div><div class="line">			data[largest] = temp;</div><div class="line">			maxHeapify(data, length, largest);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="建堆">建堆</h3>
<p><strong>buildMaxHeap</strong>算法是利用maxHeapify算法来进行的。用数组存储一个有n个元素堆时，叶节点的下标是n/2+1、n/2+2……n（这里就不做证明了，有兴趣可以自己证明），建立大根堆就是利用这个性质。叶节点可以看做只有一个元素的堆，只有一个元素也就自然满足大根堆的性质，所以以叶节点为根的堆都是大根堆。但是以其它节点为根的堆就不一定是大根堆，为了使他们满足大根堆的性质，就在节点上调用maxHeapify（叶节点是大根堆就满足了函数输入时的条件）。所以建立大根堆的过程就是在除叶节点以为的节点上调用maxHeapify。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span>(<span class="keyword">int</span>[] data){</div><div class="line">		<span class="keyword">int</span> start = getParentIndex(data.length);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &gt;= <span class="number">0</span>; i--) {</div><div class="line">			maxHeapify(data, data.length, i);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="堆排序-1">堆排序</h3>
<p><strong>heapSort</strong>也是利用maxHeapify算法来进行的。在一个大根堆中，最大元素就是堆的根。堆排序就是利用的这个性质。在一个含有n个元素的数组上调用buildMaxHeap，就能得到最大的元素，然后将最大的元素和数组的尾部，再将最大元素从堆中除去，此时堆的元素为n-1个，但是不满足大根堆的性质，就在根节点上调用maxHeapify使其成为大根堆。不断重复这个过程直到堆中只剩下一个元素，就完成了排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span>(<span class="keyword">int</span>[] data){</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = data.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) {</div><div class="line">			<span class="keyword">int</span> temp = data[<span class="number">0</span>];</div><div class="line">			data[<span class="number">0</span>]	= data[i];</div><div class="line">			data[i] = temp;</div><div class="line">			maxHeapify(data, i, <span class="number">0</span>);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h2 id="优先级队列">优先级队列</h2>
<p>优先级队列是一种用来维护由一组数组元素构成集合S的数据结构，每个元素都有一个关键字key。</p>
<ul>
<li>INSERT(S,x)：元素x插入集合S</li>
<li>MAXIMUN(S)：返回S中具有最大key的元素</li>
<li>EXTRACT-MAX(S)：去掉并返回S中具有最大key的元素</li>
<li>INCREASE-KEY(S,x,k)：将元素x的key值增加到k，k&gt;=key</li>
</ul>
<h3 id="伪代码">伪代码</h3>
<p>HEAP-MAXIMUN(A)，时间复杂度<code>O(1)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> A[<span class="number">1</span>];</div></pre></td></tr></table></figure>

<p>HEAP-EXTRACT-MAX(A)，时间复杂度<code>O(lgn)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> heap-size[A]&lt;<span class="number">1</span></div><div class="line">    then error <span class="string">"heap underflow"</span></div><div class="line">max ← A[<span class="number">1</span>]</div><div class="line">A[<span class="number">1</span>] ← A[heap-size[A]]</div><div class="line">heap-size[A] ← heap-size[A]-<span class="number">1</span></div><div class="line">MAX-HEAPIFY(A,<span class="number">1</span>)</div><div class="line"><span class="keyword">return</span> max</div></pre></td></tr></table></figure>

<p>HEAP-INCREASE-KEY(A,i,key)，时间复杂度<code>O(lgn)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> key&lt;A[i]</div><div class="line">    then error <span class="string">"new key is smaller than the current key"</span></div><div class="line">A[i] ← key</div><div class="line"><span class="keyword">while</span> i&gt;<span class="number">1</span> && A[parent[i]]&lt;A[i]</div><div class="line">    do exchange A[i] ↔ A[parent[i]]</div><div class="line">    i ← parent(i)</div></pre></td></tr></table></figure>

<p>HEAP-INSERT(A,key)，时间复杂度<code>O(lgn)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">heap-size[A] ← heap-size[A]+<span class="number">1</span></div><div class="line">A[heap-size[A]] ← -∞</div><div class="line">HEAP-INCREASE-KEY(A,heap-size[A],key)</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[堆数据结构是一种数组对象，它可以被视为一颗完全二叉树，树中每个节点与数组中存放该节点值的元素对应。]]>
    
    </summary>
    
      <category term="heap" scheme="http://alexyyek.github.io/tags/heap/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Count And Say]]></title>
    <link href="http://alexyyek.github.io/2014/12/06/CountAndSay/"/>
    <id>http://alexyyek.github.io/2014/12/06/CountAndSay/</id>
    <published>2014-12-06T09:31:42.000Z</published>
    <updated>2014-12-06T09:46:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Count_and_Say">Count and Say</h2>
<p>Question : The count-and-say sequence is the sequence of integers beginning as follows:<br><code>1, 11, 21, 1211, 111221, ...</code></p>
<p><code>1</code> is read off as <code>one 1</code> or <code>11</code>.<br><code>11</code> is read off as <code>two 1s</code> or <code>21</code>.<br><code>21</code> is read off as <code>one 2, then one 1</code> or <code>1211</code>.<br>Given an integer <code>n</code>, generate the nth sequence.<br><a id="more"></a> </p>
<h3 id="Best_solution">Best solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">countAndSay</span>(<span class="keyword">int</span> n) {</div><div class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line"></div><div class="line">	String first = <span class="string">"1"</span>;</div><div class="line">	<span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; first.length(); j++) {</div><div class="line">			<span class="keyword">if</span> (j &lt; first.length() - <span class="number">1</span></div><div class="line">					&& (first.charAt(j) == first.charAt(j + <span class="number">1</span>))) {</div><div class="line">				count++;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				sb.append(count + <span class="string">""</span> + first.charAt(j));</div><div class="line">				count = <span class="number">1</span>;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		first = sb.toString();</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> first;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>Analyze</strong> : 题目非常简单，序列迭代规则已经列出，求第n次迭代的值。基本方法判断相邻两个字符是否一样，算出每一次的序列值，迭代到n次为止。其实也可以用递归的方法来做，给出第n-1次的规则，求第n次的值。<br><br></p>
<hr>
<p>比较有意思的是用DFS的思想来解决此题，代码如下：</p>
<h3 id="DFS">DFS</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> String s = <span class="string">"1"</span>;</div><div class="line"><span class="keyword">public</span> String <span class="title">countSay</span>(<span class="keyword">int</span> n) {</div><div class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</div><div class="line">        dfs(s.length());</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span>(<span class="keyword">int</span> length) {</div><div class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">1</span>, i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (i &lt; length - <span class="number">1</span> && s.charAt(i) == s.charAt(<span class="number">1</span> + i)) {</div><div class="line">        count++;</div><div class="line">        i++;</div><div class="line">    }</div><div class="line">    s = s.substring(i + <span class="number">1</span>) + count + s.charAt(i);</div><div class="line">    dfs(length - count);</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>Analyze</strong> : 深度优先算法的思路也很简单，比如第4次迭代结果为1211，现在进行第5次迭代</p>
<ul>
<li>树<code>1-2-1-1</code>根节点为<code>1</code>，出现一次所以值变成<code>11</code>,树变成<code>2-1-1</code>，所以整体值为<code>21111</code>；</li>
<li>第二次运算<code>2</code>出现一次，值为<code>12</code>，树还剩<code>1-1</code>，所以整体值为<code>111112</code>，注意这里前面11是待统计的树<code>1-1</code>,中间的11是第一次的运算值，最后的12是第二次的运算值；</li>
<li>由于树<code>1-1</code>中<code>1</code>出现了两次，所以值为<code>21</code>，s = s.substring(i + 1) + count + s.charAt(i) = 111221</li>
</ul>
<h3 id="More">More</h3>
<p>这道题在leetcode上的表述略有不清，我第一次就把此题误解为给定任意整数n，去求此整数的第n次迭代值<br>比如5-&gt;15-&gt;1115-&gt;3115-&gt;132115-&gt;1113122115，结果发现高估此题了…<br>既然都写了就列在下面吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">countAndSay</span>(<span class="keyword">int</span> n) {</div><div class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>) {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	String word = String.valueOf(n);</div><div class="line">	<span class="keyword">while</span> (n &gt; <span class="number">0</span>) {</div><div class="line">		<span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">		StringBuffer sBuffer = <span class="keyword">new</span> StringBuffer();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) {</div><div class="line">			<span class="keyword">if</span> (i &lt; word.length() - <span class="number">1</span></div><div class="line">					&& word.charAt(i) == word.charAt(i + <span class="number">1</span>)) {</div><div class="line">				count++;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				sBuffer.append(count).append(word.charAt(i));</div><div class="line">				count = <span class="number">1</span>;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		word = sBuffer.toString();</div><div class="line">		n--;</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> word;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[The count-and-say sequence is the sequence of integers beginning as follows 1, 11, 21, 1211, 111221, ... , Given an integer n, generate the nth sequence.]]>
    
    </summary>
    
      <category term="dfs" scheme="http://alexyyek.github.io/tags/dfs/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Trapping Rain Water]]></title>
    <link href="http://alexyyek.github.io/2014/12/04/TrappingRainWater/"/>
    <id>http://alexyyek.github.io/2014/12/04/TrappingRainWater/</id>
    <published>2014-12-04T07:17:18.000Z</published>
    <updated>2014-12-04T07:49:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Trapping_Rain_Water">Trapping Rain Water</h2>
<p>Question : Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br><a id="more"></a><br>For example:<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><img src="http://leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png" alt=""></p>
<h3 id="Best_Solution">Best Solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span>(<span class="keyword">int</span>[] A) {</div><div class="line">		<span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> b = A.length - <span class="number">1</span>;</div><div class="line">		<span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> leftmax = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> rightmax = <span class="number">0</span>;</div><div class="line">		<span class="keyword">while</span> (a &lt;= b) {</div><div class="line">			leftmax = Math.max(leftmax, A[a]);</div><div class="line">			rightmax = Math.max(rightmax, A[b]);</div><div class="line">			<span class="keyword">if</span> (leftmax &lt; rightmax) {</div><div class="line">				max += (leftmax - A[a]); </div><div class="line">				a++;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				max += (rightmax - A[b]);</div><div class="line">				b--;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> max;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>Analyze</strong> : I calculated the stored water at each index a and b in my code. At the start of every loop, I update the current maximum height from left side (that is from A[0,1…a]) and the maximum height from right side(from A[b,b+1…n-1]). if(leftmax &lt; rightmax) then, at least (leftmax-A[a]) water can definitely be stored no matter what happens between [a,b] since we know there is a barrier at the rightside(rightmax &gt; leftmax).</p>
]]></content>
    <summary type="html">
    <![CDATA[Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.]]>
    
    </summary>
    
      <category term="Arrays" scheme="http://alexyyek.github.io/tags/Arrays/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Simplify Path]]></title>
    <link href="http://alexyyek.github.io/2014/11/30/SimplifyPath/"/>
    <id>http://alexyyek.github.io/2014/11/30/SimplifyPath/</id>
    <published>2014-11-30T13:13:12.000Z</published>
    <updated>2014-12-01T05:04:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Simplify_Path">Simplify Path</h2>
<p>Question:Given an absolute path for a file (Unix-style), simplify it.<br><a id="more"></a></p>
<p>For example,<br>path = <code>/home/</code> =&gt; <code>/home</code><br>path = <code>/a/./b/../../c/</code> =&gt; <code>/c</code><br><br></p>
<table>
<thead>
<tr>
<th>Situation</th>
<th style="text-align:center">Meaning</th>
<th style="text-align:center">Solution</th>
</tr>
</thead>
<tbody>
<tr>
<td>/..</td>
<td style="text-align:center">返回上级目录</td>
<td style="text-align:center">若stack不空，stack.pop()</td>
</tr>
<tr>
<td>/.</td>
<td style="text-align:center">留在本目录</td>
<td style="text-align:center">无操作</td>
</tr>
<tr>
<td>/</td>
<td style="text-align:center">多余的slash</td>
<td style="text-align:center">无操作</td>
</tr>
<tr>
<td>other</td>
<td style="text-align:center">有效目录名</td>
<td style="text-align:center">入栈</td>
</tr>
</tbody>
</table>
<h3 id="My_solution">My solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">soluition</span>(String path) {</div><div class="line">        String[] unit = path.split(<span class="string">"/"</span>);</div><div class="line">        StringBuffer line = <span class="keyword">new</span> StringBuffer();</div><div class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unit.length; i++) {</div><div class="line">        	<span class="keyword">if</span> (!unit[i].equals(<span class="string">""</span>)) {</div><div class="line">        		<span class="keyword">if</span> (unit[i].equals(<span class="string">"."</span>)) {</div><div class="line">    				<span class="keyword">continue</span>;</div><div class="line">    			}<span class="keyword">else</span> <span class="keyword">if</span> (unit[i].equals(<span class="string">".."</span>)) {</div><div class="line">    				<span class="keyword">if</span> (!stack.isEmpty()) {</div><div class="line">    					stack.pop();</div><div class="line">        				stack.pop();</div><div class="line">					}</div><div class="line">    			}<span class="keyword">else</span> {</div><div class="line">    				stack.push(<span class="string">"/"</span>);</div><div class="line">    				stack.push(unit[i]);</div><div class="line">    			}</div><div class="line">			}</div><div class="line">		}</div><div class="line">        <span class="keyword">if</span> (stack.isEmpty()) {</div><div class="line">			<span class="keyword">return</span> <span class="string">"/"</span>;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">while</span> (!stack.isEmpty()) {</div><div class="line">				line.insert(<span class="number">0</span>, stack.pop());</div><div class="line">			}</div><div class="line">			<span class="keyword">return</span> line.toString();</div><div class="line">		}</div><div class="line">    }</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[Question:Given an absolute path for a file (Unix-style), simplify it.]]>
    
    </summary>
    
      <category term="stack" scheme="http://alexyyek.github.io/tags/stack/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Valid Parentheses]]></title>
    <link href="http://alexyyek.github.io/2014/11/28/valid-parentheses/"/>
    <id>http://alexyyek.github.io/2014/11/28/valid-parentheses/</id>
    <published>2014-11-28T14:42:18.000Z</published>
    <updated>2014-11-29T06:16:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Valid_Parentheses">Valid Parentheses</h2>
<p>Question：Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.<br>The brackets must close in the correct order, <code>()</code> and <code>()[]{}</code> are all valid but <code>(]</code> and <code>([)]</code> are not.<br><a id="more"></a>  </p>
<h3 id="Best_Solution">Best Solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span>(String s){</div><div class="line">		HashMap&lt;Character, Character&gt;map = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</div><div class="line">		map.put(<span class="string">'('</span>, <span class="string">')'</span>);</div><div class="line">		map.put(<span class="string">'['</span>, <span class="string">']'</span>);</div><div class="line">		map.put(<span class="string">'{'</span>, <span class="string">'}'</span>);</div><div class="line">		</div><div class="line">		Stack&lt;Character&gt;stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) {</div><div class="line">			<span class="keyword">char</span> head = s.charAt(i);</div><div class="line">			</div><div class="line">			<span class="keyword">if</span> (map.containsKey(head)) {</div><div class="line">				stack.push(head);</div><div class="line">			}<span class="keyword">else</span> <span class="keyword">if</span> (map.values().contains(head)) {</div><div class="line">				<span class="keyword">if</span> (!stack.isEmpty() && map.get(stack.peek()).equals(head)) {</div><div class="line">					stack.pop();</div><div class="line">				}<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> stack.isEmpty();</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><strong>Analyze</strong>：思想非常简单，当看到左括号的时候就push入栈，看到右括号时与stack.peek相匹配，匹配成功则pop，如果字符串valid，则stack.isEmpty会为true，即所有左括号都匹配到对应的右括号。<br>PS. 一定要在else if内加栈空判断，防止字符串以右括号开始，如<code>}[()]</code><br><br></p>
<h3 id="My_Solution">My Solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span>(String s){</div><div class="line">		HashMap&lt;String, String&gt;map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">		map.put(<span class="string">"("</span>, <span class="string">")"</span>);</div><div class="line">		map.put(<span class="string">"["</span>, <span class="string">"]"</span>);</div><div class="line">		map.put(<span class="string">"{"</span>, <span class="string">"}"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (s.length()%<span class="number">2</span> != <span class="number">0</span>) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		}</div><div class="line">		</div><div class="line">		Stack&lt;String&gt;stack = <span class="keyword">new</span> Stack&lt;String&gt;();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = s.length(); i &gt; <span class="number">0</span>; i--) {</div><div class="line">			stack.push(s.substring(i-<span class="number">1</span>, i));</div><div class="line">		}</div><div class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (!map.containsKey(stack.peek())) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">while</span> (!stack.isEmpty()) {</div><div class="line">			String head = stack.pop();</div><div class="line">			<span class="keyword">if</span> (map.containsKey(head)) {</div><div class="line">				list.add(head);</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				<span class="keyword">if</span> (head.equals(map.get(list.get(list.size() - <span class="number">1</span>)))) {</div><div class="line">					list.remove(list.size() - <span class="number">1</span>);</div><div class="line">				}<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (!list.isEmpty()) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. The brackets must close in the correct order, `()` and `()[]{}` are all valid but `(]` and `([)]` are not.]]>
    
    </summary>
    
      <category term="stack" scheme="http://alexyyek.github.io/tags/stack/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Min Stack]]></title>
    <link href="http://alexyyek.github.io/2014/11/19/Stack/"/>
    <id>http://alexyyek.github.io/2014/11/19/Stack/</id>
    <published>2014-11-19T12:54:53.000Z</published>
    <updated>2014-11-28T14:50:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Min_Stack">Min Stack</h2>
<p>Question : Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.<br><a id="more"></a>   </p>
<ul>
<li>push(x) — Push element x onto stack.</li>
<li>pop() — Removes the element on top of the stack.</li>
<li>top() — Get the top element.</li>
<li>getMin() — Retrieve the minimum element in the stack.<br><br></li>
</ul>
<hr>
<h3 id="Best_solution">Best solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStackBest</span> </span>{</div><div class="line">	Stack&lt;Long&gt; stack;</div><div class="line">	<span class="keyword">long</span> min = <span class="number">0</span>;</div><div class="line">	<span class="keyword">public</span> <span class="title">MinStackBest</span>() {</div><div class="line">		stack = <span class="keyword">new</span> Stack&lt;Long&gt;();</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(<span class="keyword">int</span> x) {</div><div class="line">		<span class="keyword">if</span> (stack.isEmpty()) {</div><div class="line">			stack.push(<span class="number">0</span>L);</div><div class="line">			min = x;</div><div class="line">		} <span class="keyword">else</span> {</div><div class="line">			stack.push(x - min);</div><div class="line">			<span class="keyword">if</span> (x &lt; min) {</div><div class="line">				min = x;</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span>() {</div><div class="line">		<span class="keyword">if</span> (stack.isEmpty()) {</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		}</div><div class="line">		<span class="keyword">long</span> pop = stack.pop();</div><div class="line">		<span class="keyword">if</span> (pop &lt; <span class="number">0</span>) {</div><div class="line">			min = min - pop;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span>() {</div><div class="line">		<span class="keyword">long</span> top = stack.peek();</div><div class="line">		<span class="keyword">if</span> (top &gt; <span class="number">0</span>) {</div><div class="line">			<span class="keyword">return</span> (<span class="keyword">int</span>) (min + top);</div><div class="line">		} <span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> (<span class="keyword">int</span>) min;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span>() {</div><div class="line">		<span class="keyword">return</span> (<span class="keyword">int</span>) min;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>The thought is to store the gap between the current value and min value, while the only problem is int is 4 bit<br>so the Max gap = Integer.MAXVALUE - Integer.MINVALUE, and that value beyond int, so the author init the min value as long.</p>
<p><br></p>
<h3 id="Another_solution">Another solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>{</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> class Element{</div><div class="line">		<span class="keyword">final</span> <span class="keyword">int</span> value;</div><div class="line">		<span class="keyword">final</span> <span class="keyword">int</span> min;</div><div class="line">		Element(<span class="keyword">int</span> value, <span class="keyword">int</span> min){</div><div class="line">			<span class="keyword">this</span>.value = value;</div><div class="line">			<span class="keyword">this</span>.min = min;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	Stack&lt;Element&gt;stack = <span class="keyword">new</span> Stack&lt;Element&gt;();</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(<span class="keyword">int</span> x) {</div><div class="line">		<span class="keyword">int</span> min = (stack.isEmpty()) ? x : Math.min(x, stack.peek().min);</div><div class="line">		stack.push(<span class="keyword">new</span> Element(x, min));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span>() {</div><div class="line">    	stack.pop();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span>() {</div><div class="line">    	<span class="keyword">return</span> stack.peek().value;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span>() {</div><div class="line">        <span class="keyword">return</span> stack.peek().min;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><br></p>
<h2 id="Review_Stack">Review Stack</h2>
<p>Here’s the source code, compose by one Constructor and five Method</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line">	 * 构造函数</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="title">Stack</span>() {</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * push函数：将元素存入栈顶</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> E <span class="title">push</span>(E item) {</div><div class="line">		<span class="comment">// 将元素存入栈顶。</span></div><div class="line">		<span class="comment">// addElement()的实现在Vector.java中</span></div><div class="line">		addElement(item);</div><div class="line"></div><div class="line">		<span class="keyword">return</span> item;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * pop函数：返回栈顶元素，并将其从栈中删除</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span>() {</div><div class="line">		E obj;</div><div class="line">		<span class="keyword">int</span> len = size();</div><div class="line"></div><div class="line">		obj = peek();</div><div class="line">		<span class="comment">// 删除栈顶元素，removeElementAt()的实现在Vector.java中</span></div><div class="line">		removeElementAt(len - <span class="number">1</span>);</div><div class="line"></div><div class="line">		<span class="keyword">return</span> obj;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * peek函数：返回栈顶元素，不执行删除操作</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span>() {</div><div class="line">		<span class="keyword">int</span> len = size();</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (len == <span class="number">0</span>)</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</div><div class="line">		<span class="comment">// 返回栈顶元素，elementAt()具体实现在Vector.java中</span></div><div class="line">		<span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 栈是否为空</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span>() {</div><div class="line">		<span class="keyword">return</span> size() == <span class="number">0</span>;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 查找“元素o”在栈中的位置：由栈底向栈顶方向数</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span>(Object o) {</div><div class="line">		<span class="comment">// 获取元素索引，elementAt()具体实现在Vector.java中</span></div><div class="line">		<span class="keyword">int</span> i = lastIndexOf(o);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) {</div><div class="line">			<span class="keyword">return</span> size() - i;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">	}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Min_Stack">Min Stack</h2>
<p>Question : Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.<br>]]>
    
    </summary>
    
      <category term="stack" scheme="http://alexyyek.github.io/tags/stack/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Single Number]]></title>
    <link href="http://alexyyek.github.io/2014/11/17/Single-Number/"/>
    <id>http://alexyyek.github.io/2014/11/17/Single-Number/</id>
    <published>2014-11-17T08:30:25.000Z</published>
    <updated>2014-11-28T14:45:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Single_Number">Single Number</h2>
<p>Question : Given an array of integers, every element appears <code>twice</code> except for one. Find that single one.<br><a id="more"></a><br><br></p>
<h3 id="Best_solution">Best solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span>(<span class="keyword">int</span>[] A) {</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) {</div><div class="line">			result ^= A[i];</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="My_solution">My solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span>(<span class="keyword">int</span>[] A) {</div><div class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) {</div><div class="line">			<span class="keyword">int</span> key = A[i];</div><div class="line">			<span class="keyword">if</span> (map.containsKey(key)) {</div><div class="line">				map.put(key, map.get(key) + <span class="number">1</span>);</div><div class="line">				<span class="keyword">if</span> (map.get(key) == <span class="number">2</span>) {</div><div class="line">					map.remove(key);</div><div class="line">				}</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				map.put(key, <span class="number">1</span>);</div><div class="line">			}</div><div class="line">		}</div><div class="line">		String result = map.keySet().toString();</div><div class="line">		<span class="keyword">int</span> out = Integer.parseInt(result.substring(<span class="number">1</span>, result.length()-<span class="number">1</span>));</div><div class="line">		<span class="keyword">return</span> out;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>从性能上来评判用XOR无疑使最好的，复杂度只有O(N)。</p>
<p>我个人的方法略显笨拙，复杂度虽然也是O(N), 但开辟的多余的内存空间，不过当element出现的次数改变时，反而有更好的鲁棒性.<br><br></p>
<h3 id="change_question">change question</h3>
<p>Given an array of integers, every element appears <code>three</code> times except for one. Find that single one.<br><br></p>
<h4 id="best_answer">best answer</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span>(<span class="keyword">int</span>[] A) {</div><div class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++){</div><div class="line">        ones = (ones ^ A[i]) & ~twos;</div><div class="line">        twos = (twos ^ A[i]) & ~ones;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> ones;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><br></p>
<h4 id="Inference">Inference</h4>
<p>题目中改变了element的出现次数，变成了出现三次，当然用我之前的程序改个数字就能搞定，但仍需要分析一下最优的解法<br>best answer思路：出现三次，可以用2个bit来表征这三个状态，分别是00→10→01→00<br>ones和twos分别承担了这两个bit位<br>如果推理一下可以发现</p>
<blockquote>
<p>ones = ones ^ A[i]; if (twos == 1) then ones = 0, that can be tansformed to ones = (ones ^ &gt;A[i]) &amp; ~twos.</p>
<p>twos = twos ^ A[i]; if (ones == 1) then twos = 0 and twos = (twos ^ A[i]) &amp; ~ones.</p>
</blockquote>
<p><br></p>
<h2 id="回顾">回顾</h2>
<p><br></p>
<h3 id="位移动运算符:">位移动运算符:</h3>
<p><strong>&lt;&lt;</strong>表示左移, 左移一位表示原来的值乘2.</p>
<p>例如：3 &lt;&lt;2(3为int型) </p>
<blockquote>
<ol>
<li>把3转换为二进制数字0000 0000 0000 0000 0000 0000 0000 0011， </li>
<li>把该数字高位(左侧)的两个零移出，其他的数字都朝左平移2位， </li>
<li>在低位(右侧)的两个空位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100. 转换为十进制是12。</li>
</ol>
</blockquote>
<p>同理<strong>&gt;&gt;</strong>表示右移. 右移一位表示除2. </p>
<p>低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1 </p>
<p><br></p>
<h3 id="位运算:">位运算:</h3>
<p>位运算符包括:　与（&amp;）、非（~）、或（|）、异或（^）</p>
<blockquote>
<p>&amp;：当两边操作数的位同时为1时，结果为1，否则为0。如1100&amp;1010=1000 　</p>
<p>| ：当两边操作数的位有一边为1时，结果为1，否则为0。如1100|1010=1110 　</p>
<p>~：0变1,1变0 　　</p>
<p>^：两边的位不同时，结果为1，否则为0.如1100^1010=0110</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Single_Number">Single Number</h2>
<p>Question : Given an array of integers, every element appears <code>twice</code> except for one. Find that single one.<br>]]>
    
    </summary>
    
      <category term="Bit Manipulation" scheme="http://alexyyek.github.io/tags/Bit-Manipulation/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java处理字符串-删除所有标点]]></title>
    <link href="http://alexyyek.github.io/2014/11/15/new/"/>
    <id>http://alexyyek.github.io/2014/11/15/new/</id>
    <published>2014-11-15T06:45:40.000Z</published>
    <updated>2014-11-28T14:44:06.000Z</updated>
    <content type="html"><![CDATA[<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str = str.replaceAll(<span class="string">"[\\pP‘’“”]"</span>, <span class="string">""</span>);</div></pre></td></tr></table></figure>

<p>在这里利用的是Unicode编码，Unicode 编码并不只是为某个字符简单定义了一个编码，而且还将其进行了归类。</p>
<p><a id="more"></a><br>\pP 其中的小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。</p>
<p>大写 P 表示 Unicode 字符集七个字符属性之一：标点字符。其他六个包括：</p>
<ul>
<li>L：字母 </li>
<li>M：标记符号（一般不会单独出现）</li>
<li>Z：分隔符（比如空格、换行等）      </li>
<li>S：符号（比如数学符号、货币符号等）</li>
<li>N：数字（比如阿拉伯数字、罗马数字等）</li>
<li>C：其他字符</li>
</ul>
<p>Java 中用于 Unicode 的正则表达式数据都是由 Unicode 组织提供的。<br>Unicode 正则表达式<a href="http://www.unicode.org/reports/tr18/" target="_blank" rel="external">标准</a>（可以找到所有的子属性）<br>这个<a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt" target="_blank" rel="external">文本文档</a>一行是一个字符，第一列是 Unicode 编码，第二列是字符名，第三列是 Unicode 属性，以及其他一些字符信息。</p>
<h3 id="实例">实例</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span> str = <span class="string">",.!，，D_NAME。！；‘’”“《》**dfs  #$%^&()-+1431221中国123漢字かどうかのjavaを決定"</span>;  </div><div class="line">str = str.replaceAll(<span class="string">"[\\pP‘’“”]"</span>, <span class="string">""</span>);  </div><div class="line">System.out.println(str);</div></pre></td></tr></table></figure>

<p>输出结果: DNAMEdfs  $^+1431221中国123漢字かどうかのjavaを決定</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str = str.replaceAll(<span class="string">"[\\pP‘’“”]"</span>, <span class="string">""</span>);</div></pre></td></tr></table></figure>

<p>在这里利用的是Unicode编码，Unicode 编码并不只是为某个字符简单定义了一个编码，而且还将其进行了归类。</p>
<p>]]>
    
    </summary>
    
      <category term="skill" scheme="http://alexyyek.github.io/tags/skill/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
</feed>
