<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[AlexYoung's blog]]></title>
  <subtitle><![CDATA[Do Not Go Gentle Into Life]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://alexyyek.github.io/"/>
  <updated>2014-12-15T10:26:58.193Z</updated>
  <id>http://alexyyek.github.io/</id>
  
  <author>
    <name><![CDATA[AlexYoung]]></name>
    <email><![CDATA[alexyyek@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[哈希碰撞]]></title>
    <link href="http://alexyyek.github.io/2014/12/14/hashCollapse/"/>
    <id>http://alexyyek.github.io/2014/12/14/hashCollapse/</id>
    <published>2014-12-14T11:46:07.000Z</published>
    <updated>2014-12-15T10:26:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="链地址法">链地址法</h2>
<p>Java.util.Hashtable类实现了JAVA中的哈希表，内部采用Entry[]数组，每个Entry均可作为链表的头，用来解决哈希碰撞。</p>
<h3 id="Hashtable特点"><strong>Hashtable特点</strong></h3>
<ul>
<li>线程安全。</li>
<li>Key、Value均不能为null。</li>
<li>包含了一个Entry[]数组，而Entry又是一个链表，用来处理冲突。</li>
<li>每个Key对应了Entry数组中固定的位置（记为index），称为槽位（Slot）。槽位计算公式为：<pre><code>       (key.hash<span class="variable">Code</span>() &amp; <span class="number">0</span>x7<span class="variable">FFFFFFF</span>) <span class="comment">% Entry[].length() </span>
</code></pre></li>
<li>当Entry[]的实际元素数量（Count）超过了分配容量（Capacity）的75%时，新建一个Entry[]是原先的2倍，重新Hash（rehash）。</li>
<li>rehash的核心思路是，将旧Entry[]数组的元素重新计算槽位，散列到新Entry[]中。<br><br></li>
</ul>
<hr>
<h3 id="Hashtable源码分析"><strong>Hashtable源码分析</strong></h3>
<p><strong>Entry类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Entry&lt;K,V&gt; <span class="comment">// Entry&lt;K,V&gt;是槽中的元素，可做链表，解决散列冲突。</span></div><div class="line">{</div><div class="line">     <span class="keyword">int</span> hash; <span class="comment">// 即key.hashCode()</span></div><div class="line">     K key;</div><div class="line">     V value;</div><div class="line">     Entry&lt;K,V&gt; next; <span class="comment">// 用来实现链表结构。同一链表中的key的hash是相同的。</span></div><div class="line">     <span class="keyword">protected</span> <span class="title">Entry</span>(<span class="keyword">int</span> hash, K key, V value, Entry&lt;K,V&gt; next) {</div><div class="line">          <span class="keyword">this</span>.hash=hash;<span class="keyword">this</span>.key=key;<span class="keyword">this</span>.value=value;<span class="keyword">this</span>.next=next;</div><div class="line">     }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><br><br><strong>构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">Hashtable</span>(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor) {</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                initialCapacity);</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</div><div class="line">        initialCapacity = <span class="number">1</span>;</div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity];</div><div class="line">    threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Constructs a new, empty hashtable with the specified initial capacity</div><div class="line"> * and default load factor (0.75).</div><div class="line"> *<span class="javadoctag"> @param</span>     initialCapacity   the initial capacity of the hashtable.</div><div class="line"> *<span class="javadoctag"> @exception</span> IllegalArgumentException if the initial capacity is less</div><div class="line"> *              than zero.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="title">Hashtable</span>(<span class="keyword">int</span> initialCapacity) {</div><div class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75</span>f);</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Constructs a new, empty hashtable with a default initial capacity (11)</div><div class="line"> * and load factor (0.75).</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="title">Hashtable</span>() {</div><div class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75</span>f);</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>threshold：Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”</li>
<li>loadFactor：加载因子，通常设为<strong><code>0.75</code></strong><br><br></li>
</ul>
<p><strong>hashcode</strong><br>考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）。</p>
<p>也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span>(Object key) {</div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">    <span class="keyword">int</span> index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) {</div><div class="line">        <span class="keyword">if</span> ((e.hash == hash) && e.key.equals(key)) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值(实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值)；</p>
<ul>
<li>if（table中没有该hashcode值），then → 直接存进去</li>
<li>if（存在该hashcode值），then → 调用equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址<br>所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：<strong>Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。</strong><br><br></li>
</ul>
<p><strong>addEntry</strong><br>addEntry方法实现向Hashtable中添加k-v值对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span>(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index) {</div><div class="line">    modCount++;</div><div class="line"> </div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">if</span> (count &gt;= threshold) {</div><div class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></div><div class="line">        rehash();</div><div class="line"> </div><div class="line">        tab = table;</div><div class="line">        hash = key.hashCode();</div><div class="line">        index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="comment">// Creates the new entry.</span></div><div class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; <span class="comment">// 旧有Entry</span></div><div class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e); <span class="comment">/* 旧有Entry成为了新增Entry的next */</span></div><div class="line">    count++;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当count大于阀值时，要重新进行hash，重新确定Hashtable的大小<br><br></p>
<p><strong>rehash</strong><br>rehash方法即再次hash，当Entry[]的实际存储数量占分配容量的约75%时，扩容并且重新计算各个对象的槽位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span>() {</div><div class="line">          <span class="keyword">int</span> oldCapacity = table.length;</div><div class="line">          Entry[] oldMap = table;</div><div class="line">          <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 2倍+1</span></div><div class="line">          Entry[] newMap = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">          threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</div><div class="line">          table = newMap;</div><div class="line"> </div><div class="line">          <span class="keyword">for</span>( <span class="keyword">int</span> i=oldCapacity; i-- &gt;<span class="number">0</span>;){ <span class="comment">//  i的取值范围为 [oldCapacity-1,0]</span></div><div class="line">               <span class="keyword">for</span> (Entry&lt;K,V&gt; old = oldMap[i]; old!=<span class="keyword">null</span>;){ <span class="comment">// 遍历旧Entry[]</span></div><div class="line">                    Entry&lt;K,V&gt; e = old;</div><div class="line">                    <span class="comment">//重新计算各个元素在新Entry[]中的槽位index。</span></div><div class="line">                    <span class="keyword">int</span> index = (e.hash & <span class="number">0x7FFFFFFF</span>) % newCapacity;     </div><div class="line">                    e.next = newMap[index]; <span class="comment">// 已经存在槽位中的Entry成为了新增Entry的next </span></div><div class="line">                    newMap[index]=e;     <span class="comment">// 放到槽位中</span></div><div class="line">                    old = old.next;</div><div class="line">               }</div><div class="line">          }</div><div class="line"> </div><div class="line">     }</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<h3 id="关于hashCode()和equals()方法"><strong>关于hashCode()和equals()方法</strong></h3>
<p>下面这段话摘自Effective Java一书：</p>
<blockquote>
<ul>
<li>在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。</li>
<li>如果两个对象根据equals方法比较是相等的，那么调用两个对象的hashCode方法必须返回相同的整数结果。</li>
<li>如果两个对象根据equals方法比较是不等的，则hashCode方法不一定得返回不同的整数。</li>
</ul>
</blockquote>
<p>对于第二条和第三条很好理解，但是第一条，很多时候就会忽略。在《Java编程思想》一书中的P495页也有同第一条类似的一段话：</p>
<blockquote>
<p>设计hashCode()时最重要的因素就是：无论何时，对同一个对象调用hashCode()都应该产生同样的值。如果在讲一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。</p>
</blockquote>
<p><strong>所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码。</strong></p>
<h3 id="链地址法性能分析">链地址法性能分析</h3>
<p>给定一个能存放n个元素，具有m个槽位的散列表T，定义T的装载因子$a=n/m$，即一个链中的平均元素数。假定可以在<code>O(1)</code>的时间内计算出散列值h(k)，即计算散列函数和寻址槽h(k)为<code>O(1)</code>时间。现查找元素k：</p>
<ul>
<li><p>一次不成功情况<br>在简单一致散列的假设下。一次不成功查找的<code>期望</code>时间为<code>0(1+a)</code><br>一次不成功即查找遍整个散列表<code>T[h(k)]</code>，平均每个链表查找元素为$a=n/m$，加上计算哈希h(k)的时间，总时间为<code>O(1+a)</code></p>
</li>
<li><p>一次成功情况<br>在简单一致散列的假设下。一次成功查找的期望时间为<code>0(1+a)</code><br><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/QQ图片20141215121340.png" alt=""> <center></center></center></p>
</li>
</ul>
<p>由于链表中新元素是在表头插入的，所以一次成功的查找中，所检查的元素数比x所在链表中出现在x前面的元素数多1<br>在hash值为index的槽位，一次成功的查找中，所检查元素的期望为：</p>
<p>$E\ [1/n·\sum_{i=1}^n(1+\sum_{j=i+1}^n X_{ij})]$</p>
<p>$=1/n·\sum_{i=1}^n(1+\sum_{j=i+1}^n E[X_{ij}])=1/n·\sum_{i=1}^n(1+\sum_{j=i+1}^n1/m)$</p>
<p>$=1+1/{mn}(\sum_{i=1}^nn-\sum_{i=1}^ni)=1+1/{mn}(n^2-n(n+1)/2)$</p>
<p>$=1+(n-1_/2m)=1+a/2-a/2n$</p>
<p>于是，一次成功的查找所需全部时间为<code>O(2+a/2-a/2n)</code>=<code>O(1+a)</code>.</p>
<p><strong>Conclusion</strong>：如果散列表中槽位数至少与表中的元素数成正比，则有n=O(m)，从而 $a=n/m=O(m)/m=O(1)$<br>所以平均查找操作需要常数量的时间，且已经知道插入操作最坏情况需要<code>O(1)</code>，删除操作最坏需要<code>O(1)</code>，因而全部字典操作可以在<code>O(1)</code>时间完成。</p>
]]></content>
    <summary type="html">
    <![CDATA[当多个关键字映射到同一槽位时，便发生哈希碰撞。主要解决方案有两种，一种是基于链表的链地址法，另一种则是开放寻址法。]]>
    
    </summary>
    
      <category term="hash" scheme="http://alexyyek.github.io/tags/hash/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[散列函数]]></title>
    <link href="http://alexyyek.github.io/2014/12/11/hash/"/>
    <id>http://alexyyek.github.io/2014/12/11/hash/</id>
    <published>2014-12-11T14:12:51.000Z</published>
    <updated>2014-12-14T07:08:05.000Z</updated>
    <content type="html"><![CDATA[<p>一个好的散列函数应满足<code>简单一致</code>散列的假设：每个关键字都等可能的散列到m个槽位的任何一个之中，并与其它的关键字已被散列到哪个槽位无关。</p>
<h2 id="除法散列法">除法散列法</h2>
<p>在用来设计散列函数的除法散列法中，通过取k除以m的余数，将关键字k映射到m个槽中的某一个上，即散列函数为:</p>
<p><center> $$h(k)=k mod m$$ <center></center></center></p>
<p>当应用除法散列法时，要避免选择m的某些值，m常常选择与近2的整数幂的不太接近的<code>素数</code>。<br><strong>Explain</strong>：如果 $m=2^p$，二进制除法相当于右位移<code>&gt;&gt;</code>，例如<code>111010&gt;&gt;3</code>,即除以$2^3$，右移3位变为<code>111</code>，<code>010</code>则作为余数被移除，故在做取余操作时值为<code>010</code>,即为k的p个最低位数字。</p>
<h2 id="乘法散列法">乘法散列法</h2>
<p>乘法散列法整体包含两步：</p>
<ul>
<li>用关键字k乘上常数<code>A(0&lt;A&lt;1)</code>，并去除kA的小数部分</li>
<li>用m乘以这个值，再取结果的底<code>floor</code><br>公式：    <code>h(k)=Math.floor[m(kA mod 1)]</code><br><center><img src="http://alexyoung.qiniudn.com/26822401_1334109664MN4j.png" alt=""><center></center></center></li>
</ul>
<p><strong>STEP</strong>：</p>
<ul>
<li>假设某计算机的字长为 $w$ 位，而 $k$ 正好可容于一个字中（$k&lt;2^w$)</li>
<li>现在选取范围$[0，2^w]$内的任意数值 $s$，$k×s$ 即可用$R_1·2^w+R_0$来表示</li>
<li>因此$(k·A) mod 1=k·s/2^w$就是将$k×s$整体向右平移 $w$ 位，此时$R_0$即为小数部分</li>
<li>再乘以$2^m$相当于左移 $m$ 位，散列值 $h(k)$ 为$R_0$的前m位。</li>
</ul>
<h2 id="全域散列">全域散列</h2>
<p>如果让某个与你作对的人来选择要散列的关键字，那么他会选择全部散列到同一槽位的n个关键字，使得平均检索时间为<code>O(n)</code>，任何一个特定的散列函数都无法避免这种最坏情况的发生。唯一有效的改进方法是<code>随机的选择散列函数</code>，使之独立于要存储的关键字，这便是全域散列(universal hashing)，无论对手如何选择关键字，平均性态都很好。</p>
<p><strong>步骤</strong></p>
<ul>
<li>选择一个足够大的<code>质数</code>$p$，使得每个关键字都落在 $[0, p-1]$ 范围内；</li>
<li>集合$Z_p$ = $\{0,1,…,p-1\}$，集合$Z^*_p$= $\{1,2,…,p-1\}$，对于任何 $a \in Z^*_p$，$b \in Z_p$，定义散列函数 $h_{a,b}$：</li>
</ul>
<p><center> $h_{a,b}(k) = ((ak+b)\ mod \ p)\ mod \ m$ <center></center></center></p>
<p>假定关键字的范围大于散列表的槽位数，即 $p&gt;m$，对 $a$而言有<code>p</code>种选择，对 $b$ 而言有<code>p-1</code>种可能，所以 $H_{a,b}$有<code>p(p-1)</code>种可能性。当随机的选择关键字$k \not= l$，两者发生碰撞的概率不大于<code>1/m</code>。</p>
<p><strong>Proof</strong>：<br>考虑 $Z_p $ 中两个不同的关键字 $k$ 和 $l$，即 $k \not= l$，对某一给定的随机散列函数$h_{a,b}$</p>
<p><center> $r=(ak+b)\ mod\ p$         ,      $s=(al+b)\ mod \ p$ <center></center></center></p>
<p>此处必有 $ r\not= s$，因为 $r-s = a(k-l)\ mod\ p$</p>
<p><code>p</code>为质数，故<code>a</code>和<code>k-l</code>模<code>p</code>均不为0，因此在模<code>p</code>这一层次上，尚不出现冲突。</p>
<p>故对于某个给定的<code>r</code>值，<code>s</code>的可能取值为余下的<code>p-1</code>种，其中满足$s \not= r$且$r \equiv s(mod \ p)$的值的数目至多为$(p-1)/m$，所以<code>s</code>与<code>r</code>发生碰撞的概率至多为 $((p-1)/m)/(p-1)=1/m$</p>
<p>$H_{a,b}$是全域的。</p>
<h2 id="完美哈希">完美哈希</h2>
<p>当键值是<code>static</code>(即固定不变)的时候，我们可以涉及方案使得最差情况下的查询性能也很出色，这就是完美哈希。实际上，很多地方都会用到静态关键字集合。比如一种语言的保留字集合，一张CD-ROM里的文件名集合。而完美哈希可以在最坏情况下以<code>O(1)</code>复杂度查找，性能非常出色的。<br>完美哈希的思想就是采用两级的框架，每一级上都用全域哈希：</p>
<p><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/30143317-b1a1356610cb4d6eb8cda2a1e9f36eba.png" alt=""> <center></center></center></p>
<p>完美哈希的结构如上图。具体来说，第一级和带链表的哈希非常的相似，只是第一级发生冲突后后面接的不是链表，而是一个新的哈希表。后面那个哈希结构，我们可以看到前端存储了一些哈希表的基本性质：$m$ 是哈希表槽数；$a,b$ 全域哈希函数要确定的两个值(一般是随机选然后确定下来的)，后面跟着哈希表。</p>
<p>为了保证不冲突，<strong>每个二级哈希表的数量是第一级映射到这个槽中元素个数的平方</strong>，这样可以保证整个哈希表非常的稀疏。下面给出一个定理，能更清楚的看到设置 $m=n^2$的作用。</p>
<p><strong>定理</strong>：设$H$是一类全域哈希函数，哈希表的槽数 $m=n^2$。 那么，如果我们用一个随机函数 $h \in H$把 $n$ 个keys映射到表中。冲突次数的期望最多是1/2.</p>
<p><strong>Proof</strong>：根据全域哈希的定义，对任意选出的哈希函数h，表中2个给定keys冲突的概率是 $1/m$,即 $1/n^2$<br>且总共有$C_2^n$可能的键值对，那么冲突次数的期望就是：</p>
<p><center> $C_2^n/n^2=n(n−1)/2·n^2 &lt; 1/2$   <center></center></center></p>
<p>证毕！</p>
]]></content>
    <summary type="html">
    <![CDATA[一个好的散列函数应满足简单一致散列的假设：每个关键字都等可能的散列到m个槽位的任何一个之中，并与其它的关键字已被散列到哪个槽位无关。]]>
    
    </summary>
    
      <category term="hash" scheme="http://alexyyek.github.io/tags/hash/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[中位数和顺序统计学]]></title>
    <link href="http://alexyyek.github.io/2014/12/08/select/"/>
    <id>http://alexyyek.github.io/2014/12/08/select/</id>
    <published>2014-12-08T13:38:01.000Z</published>
    <updated>2014-12-08T14:09:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="期望线性时间选择问题">期望线性时间选择问题</h2>
<p>从集合中选出第N大的数，RANDOMIZED-SELECT算法与快速排序类似，对输入数组进行递归划分，但RANDOMIZED-SELECT只处理划分的一边，因此快排的期望运行时间是<code>O(nlgn)</code>，而RANDOMIZED-SELECT<code>期望运行时间</code>只需要<code>O(n)</code> </p>
<p><strong>伪代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">RANDOMIZED-SELECT(A,p,r,i)</div><div class="line"><span class="keyword">if</span> p==r</div><div class="line">    <span class="keyword">return</span> A[p]</div><div class="line">q = RANDOM-PARTITION(A,p,r)</div><div class="line">k = q - p + <span class="number">1</span></div><div class="line"><span class="keyword">if</span> i=k</div><div class="line">    <span class="keyword">return</span> A[q]</div><div class="line">elseif i &lt; k</div><div class="line">    <span class="keyword">return</span> RANDOMIZED-SELECT(A,p,q-q,i)</div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> RANDOMIZED-SELECT(A,q+<span class="number">1</span>,r,i-k)</div></pre></td></tr></table></figure>

<hr>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		<span class="keyword">int</span>[] data ={<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>};</div><div class="line">		RandomizedSelect select = <span class="keyword">new</span> RandomizedSelect();</div><div class="line">		<span class="keyword">int</span> rank = <span class="number">9</span>;</div><div class="line">		System.out.println(select.select(data, <span class="number">0</span>, data.length-<span class="number">1</span>, rank));</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> rank){</div><div class="line">		<span class="keyword">if</span> (start == end) {</div><div class="line">			<span class="keyword">return</span> data[start];</div><div class="line">		}</div><div class="line">		<span class="keyword">int</span> threshold = randonPartition(data, start, end);</div><div class="line">		<span class="keyword">int</span> k = threshold - start + <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span> (rank == k) { </div><div class="line">			<span class="keyword">return</span> data[threshold];</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (rank &lt; k) {</div><div class="line">			<span class="keyword">return</span> select(data, start, threshold-<span class="number">1</span>, rank);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> select(data, threshold+<span class="number">1</span>, end, rank-k);</div><div class="line">		}</div><div class="line">		</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randonPartition</span>(<span class="keyword">int</span>[] data,<span class="keyword">int</span> start,<span class="keyword">int</span> end){</div><div class="line"> 		<span class="keyword">int</span> q = start + (<span class="keyword">int</span>)Math.random()*(end - start + <span class="number">1</span>);</div><div class="line"> 		<span class="keyword">int</span> temp = data[q];</div><div class="line"> 		data[q] = data[end];</div><div class="line"> 		data[end] = temp;</div><div class="line">		<span class="keyword">return</span> partition(data, start, end);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end){</div><div class="line">		<span class="keyword">int</span> value = data[end];</div><div class="line">		<span class="keyword">int</span> init = start - <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) {</div><div class="line">			<span class="keyword">if</span> (data[i] &lt; value) {</div><div class="line">				init++;</div><div class="line">				<span class="keyword">int</span> temp = data[init];</div><div class="line">				data[init] = data[i];</div><div class="line">				data[i] = temp;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">int</span> temp = data[end];</div><div class="line">		data[end] = data[init+<span class="number">1</span>];</div><div class="line">		data[init+<span class="number">1</span>] = temp;</div><div class="line">		<span class="keyword">return</span> init+<span class="number">1</span>;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>在最坏的情况下，例如：总是找到最小元素时，总是在最大元素处划分，这是时间复杂度为<code>O(n^2)</code>。但平均时间复杂度与n呈线性关系，为<code>O(n)</code></p>
<h2 id="最坏线性时间选择算法">最坏线性时间选择算法</h2>
<p>该算法利用了RANDOMIZED-SELECT对输入数组进行划分的思维，但不同之处在于该算法保证了数组的划分是好的划分。SELECT算法最坏情况运行时间为<code>O(n)</code></p>
<p><center><img src="http://alexyoung.qiniudn.com/1357624243_8923.jpg" alt=""><center></center></center></p>
<p>算法思路：如果能在线性时间内找到一个划分基准使得按这个基准所划分出的2个子数组的长度都至少为原数组长度的<code>ε</code>倍<code>(0&lt;ε&lt;1)</code>,那么就可以在最坏情况下用<code>O(n)</code>时间完成选择任务。例如，当<code>ε=9/10</code>，算法递归调用所产生的子数组的长度至少缩短1/10。所以，在最坏情况下，算法所需的计算时间<code>T(n)</code>满足递推式<code>T(n)&lt;=T(9n/10)+O(n)</code>。由此可得<code>T(n)=O(n)</code></p>
<p><br></p>
<hr>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Select</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		<span class="keyword">int</span> length = <span class="number">37</span>; <span class="keyword">int</span> rank = <span class="number">10</span>;<span class="comment">/* 37个元素中找出第10小的元素 */</span>  </div><div class="line">		<span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[length];</div><div class="line">		Random rm = <span class="keyword">new</span> Random();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</div><div class="line">			data[i] = rm.nextInt(<span class="number">100</span>);</div><div class="line">		}</div><div class="line">		</div><div class="line">		Select select =  <span class="keyword">new</span> Select();</div><div class="line">		System.out.println(Arrays.toString(data));</div><div class="line">		System.out.println(select.select(data, <span class="number">0</span>, length-<span class="number">1</span>, rank));</div><div class="line">		Arrays.sort(data);</div><div class="line">		System.out.println(Arrays.toString(data));</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> <span class="title">select</span>(<span class="keyword">int</span>[] data,<span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> rank){</div><div class="line">		<span class="keyword">if</span> ((high-low)&lt;<span class="number">5</span>) {</div><div class="line">			insertSort(data, low, high);</div><div class="line">			<span class="keyword">return</span> data[low+rank-<span class="number">1</span>];</div><div class="line">		}</div><div class="line">		<span class="keyword">int</span> group = (high - low + <span class="number">5</span>) / <span class="number">5</span>;</div><div class="line">		<span class="comment">/* 第一步：将输入数组的n个元素划分为n/5组，每组5个元素，且至多只有一个组由剩下的n mod5个元素组成 */</span>  </div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group; i++) {</div><div class="line">			<span class="keyword">int</span> left = low + i*<span class="number">5</span>;</div><div class="line">			<span class="keyword">int</span> right = (low + i*<span class="number">5</span> + <span class="number">4</span>) &gt; high ? high : (low + i*<span class="number">5</span> + <span class="number">4</span>);</div><div class="line">			<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</div><div class="line">		<span class="comment">/* 第二步：寻找(n+4)/5个组中每一组的中位数。首先对每组中的元素（至多为5个）进行插入排序，然后从排序过的序列中选出中位数 */</span>  </div><div class="line">			insertSort(data, left, right);</div><div class="line">			swap(data, low+i, mid);<span class="comment">// 将中位数置前 </span></div><div class="line">		}</div><div class="line">		<span class="comment">/* 第三步：对第二步中找出的(n+4)/5个中位数，递归调用select以找出其中位数x*/</span>  </div><div class="line">		<span class="keyword">int</span> pivot = select(data, low, low+group-<span class="number">1</span>, (group+<span class="number">1</span>)/<span class="number">2</span>);</div><div class="line">		<span class="comment">/* 第四步：利用修改过的partition过程，按中位数的中位数x对输入数组进行划分 */</span></div><div class="line">		<span class="keyword">int</span> threshold = partition(data, low, high, pivot);</div><div class="line">		<span class="comment">/* 第五步：判断threshold位置是否为要找的数，若不是则在低区或者高区递归select*/</span> </div><div class="line">		<span class="keyword">int</span> k = threshold - low + <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span> (k == rank) {</div><div class="line">			<span class="keyword">return</span> data[threshold];</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (k &gt; rank) {</div><div class="line">			<span class="keyword">return</span> select(data, low, threshold-<span class="number">1</span>, rank);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> select(data, threshold+<span class="number">1</span>, high, rank-k);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> pivot){</div><div class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">		<span class="comment">/* 找到枢纽的位置index */</span>  </div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt;= high; i++) {</div><div class="line">			<span class="keyword">if</span> (data[i] == pivot) {</div><div class="line">				index = i;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		swap(data, index, high);</div><div class="line">		<span class="keyword">int</span> init = low - <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; i++) {</div><div class="line">			<span class="keyword">if</span> (data[i] &lt; pivot) {</div><div class="line">				init++;</div><div class="line">				swap(data, init, i);</div><div class="line">			}</div><div class="line">		}</div><div class="line">		swap(data, init+<span class="number">1</span>, high);</div><div class="line">		<span class="keyword">return</span> init+<span class="number">1</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> a, <span class="keyword">int</span> b){</div><div class="line">		<span class="keyword">int</span> temp = data[a];</div><div class="line">		data[a] = data[b];</div><div class="line">		data[b] = temp;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span>(<span class="keyword">int</span>[] data,<span class="keyword">int</span> low,<span class="keyword">int</span> high){</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = low+<span class="number">1</span>; i &lt;= high; i++) {</div><div class="line">			<span class="keyword">int</span> key = data[i];</div><div class="line">			<span class="keyword">int</span> k = i - <span class="number">1</span>;</div><div class="line">			<span class="keyword">while</span> (k &gt;= low && data[k] &gt; key) {</div><div class="line">				data[k+<span class="number">1</span>] = data[k];</div><div class="line">				k--;</div><div class="line">			}</div><div class="line">			data[k+<span class="number">1</span>] = key;</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[从一个由N个不同数值构成的集合中选择其第i个顺序统计量。]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线性时间排序]]></title>
    <link href="http://alexyyek.github.io/2014/12/07/lineSort/"/>
    <id>http://alexyyek.github.io/2014/12/07/lineSort/</id>
    <published>2014-12-07T13:43:08.000Z</published>
    <updated>2014-12-07T14:19:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="快速排序算法">快速排序算法</h2>
<ul>
<li>分解<br>数组<code>A[p..r]</code>被划分为两个子数组，<code>A[p..q-1]</code>和<code>A[q+1..r]</code>，使得<code>A[p..q-1]</code>中每个元素都小于等于<code>A(q)</code>，且小于等于<code>A[q+1..r]</code>中元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">QUICKSORT(A,p,r)</div><div class="line"><span class="comment">//正常方法</span></div><div class="line"><span class="keyword">if</span> (p &lt; r){</div><div class="line">    then q = PARTITION(A,p,r)</div><div class="line">    QUICKSORT(A,p,q-<span class="number">1</span>)</div><div class="line">    QUICKSORT(A,q+<span class="number">1</span>,r)</div><div class="line">}</div><div class="line"><span class="comment">//尾递归方法</span></div><div class="line"><span class="keyword">while</span> (start &lt; end) {</div><div class="line">	<span class="keyword">int</span> q = partition(data, start, end);</div><div class="line">	quickSort(data, start, q-<span class="number">1</span>);</div><div class="line">	start = q + <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>解决<br>通过递归调用，两个子数组各自内部排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PARTITION(A,p,r)</div><div class="line">x = A[r]</div><div class="line">i = p-<span class="number">1</span></div><div class="line"><span class="keyword">for</span> j=p to r-<span class="number">1</span></div><div class="line">    <span class="keyword">if</span> A[j] &lt; x</div><div class="line">    i++</div><div class="line">    A[j]=A[i]</div><div class="line">exchange A[i+<span class="number">1</span>] ↔ A[r]</div><div class="line"><span class="keyword">return</span> i+<span class="number">1</span></div></pre></td></tr></table></figure>

<p>因为子数组是内部排序，所以无需合并操作，平均时间复杂度<code>O(nlgn)</code></p>
<h2 id="线性时间排序">线性时间排序</h2>
<p>之前的排序算法都属于<code>比较排序</code>，任何比较排序在最坏的情况下都要做<code>Ω(nlgn)</code>次比较来进行排序，下面介绍三种线性时间运行的排序</p>
<h3 id="计数排序">计数排序</h3>
<p>计数排序的前提是确定输入范围大小为0～k。在这个前提下，我们可以使用计数的方法对数组进行排序，而不是使用比较。算法思想如下：因为输入数组A中的元素范围固定，因此可以使用一个大小为k的数组C对A中的元素进行映射。</p>
<p><center><img src="http://alexyoung.qiniudn.com/QQ图片201412007210801.png" alt=""><center></center></center></p>
<p><strong>伪代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">COUNTING-SORT(A,B,k)</div><div class="line"><span class="keyword">for</span> i←<span class="number">0</span> to k</div><div class="line">    do C[i] = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> j←<span class="number">1</span> to length[A]</div><div class="line">    do C[A[j]] = C[A[j]] + <span class="number">1</span></div><div class="line">    C[i]中包含等于i的元素个数</div><div class="line"><span class="keyword">for</span> i←<span class="number">1</span> to k</div><div class="line">    C[i] = C[i-<span class="number">1</span>] + C[i]</div><div class="line"><span class="keyword">for</span> j←<span class="number">1</span> to length[A]</div><div class="line">    do B[C[A[j]]] = A[j]</div><div class="line">    C[A[j]]--</div></pre></td></tr></table></figure>

<h3 id="基数排序">基数排序</h3>
<p>实现原理：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。给定n个d位数，每一个数位有k种可能取值，基数排序能以<code>O(d(n+k))</code>的时间正确排序。<br>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>
<p><center><img src="http://alexyoung.qiniudn.com/1338051031_6070.jpg" alt=""><center></center></center></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> radix){</div><div class="line">		<span class="keyword">int</span> queue = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> bit = <span class="number">1</span>; <span class="comment">//数位</span></div><div class="line">		<span class="keyword">int</span> position = <span class="number">1</span>;<span class="comment">//当前数位</span></div><div class="line">		<span class="keyword">int</span>[][] reminder = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][data.length];</div><div class="line">		<span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line">		</div><div class="line">		<span class="keyword">while</span> (position &lt;= radix) {</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) {</div><div class="line">				<span class="keyword">int</span> lsd = (data[i] / bit) % <span class="number">10</span>;</div><div class="line">				reminder[lsd][order[lsd]] = data[i];</div><div class="line">				order[lsd]++;</div><div class="line">			}</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</div><div class="line">				<span class="keyword">if</span> (order[i] != <span class="number">0</span>) {</div><div class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; order[i]; j++) {</div><div class="line">						data[queue++] = reminder[i][j];</div><div class="line">					}</div><div class="line">				}</div><div class="line">				order[i] = <span class="number">0</span>;</div><div class="line">			}</div><div class="line">			bit *= <span class="number">10</span>;</div><div class="line">			queue = <span class="number">0</span>;</div><div class="line">			position++;</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="桶排序">桶排序</h3>
<p>桶排序的思想是把区间[0,1)划分成n个相同大小的子区间，称为桶，然后将n个输入数分布到各个桶中去。因为输入数均匀且独立分布在[0,1)上，所以，一般不会有很多数落在一个桶中的情况。为了得到结果，先对各个桶中的数进行排序，然后按次序把各桶中的元素列出来。桶排序的时间复杂度为<code>O(n)</code></p>
<p><center><img src="http://alexyoung.qiniudn.com/bucket_sort.PNG" alt=""><center></center></center></p>
<p><strong>伪代码</strong></p>
<figure class="highlight JAVA"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BUCKET-SORT(A)</div><div class="line">n = length(A)</div><div class="line"><span class="keyword">for</span> i=<span class="number">1</span> to n</div><div class="line">    do insert A[i] to list Math.floor(B[n*A[i]])</div><div class="line"><span class="keyword">for</span> i=<span class="number">1</span> to n</div><div class="line">    do sort list B[i] (recommand Collections.sort)</div><div class="line">concatenate the list B[<span class="number">1</span>] to B[n] INTO A</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[不同于比较排序O(lgn)的时间复杂度，线性时间排序可以在O(n)的时间完成排序。]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HeapSort]]></title>
    <link href="http://alexyyek.github.io/2014/12/07/heap/"/>
    <id>http://alexyyek.github.io/2014/12/07/heap/</id>
    <published>2014-12-07T06:52:35.000Z</published>
    <updated>2014-12-07T07:00:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="堆排序">堆排序</h2>
<p>堆数据结构是一种数组对象，它可以被视为一颗完全二叉树，树中每个节点与数组中存放该节点值的元素对应。堆分为大根堆和小根堆；大根堆是指除根节点以外每个节点<code>i</code>都有<code>A[parent(i)]&gt;=A[i]</code>，即每个节点的值最多和父节点的值一样大，这样堆中的最大值就在根节点中，且以某个节点为根的子树中，各个节点的值都不大于该子树根节点的值，图1就是一个大根堆。小根堆的刚好相反，每个节点的值都不小于其父节点。</p>
<center><img src="http://alexyoung.qiniudn.com/B44BD10DE99C61C6E965337C8EFFBE6A_B500_900_392_301.PNG" alt=""></center>

<h3 id="保持堆的性质">保持堆的性质</h3>
<p><strong>maxHeapify</strong>是对大根堆进行操作的重要子程序，其输入为一个数组A和一个下标i，maxHeapify被调用时假定left(i)和right(i)都满足大根堆的性质，但是A[i]有可能小于其子女而违反了大根堆性质，maxHeapify使A[i]下降，使以A[i]为根的堆成为大根堆。其过程如图 2所示：<br><img src="http://alexyoung.qiniudn.com/CBDE478800037BD91BF72E29598EFEBD_B500_900_500_341.PNG" alt=""><br><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> length, <span class="keyword">int</span> index){</div><div class="line">		<span class="keyword">int</span> left = getLeftChildIndex(index);</div><div class="line">		<span class="keyword">int</span> right = getRightChildIndex(index);</div><div class="line">		<span class="keyword">int</span> largest = index;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (left &lt; length && data[left] &gt; data[index]) {</div><div class="line">			largest = left;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (right &lt; length && data[right] &gt; data[largest]) {</div><div class="line">			largest = right;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (largest != index) {</div><div class="line">			<span class="keyword">int</span> temp = data[index];</div><div class="line">			data[index] = data[largest];</div><div class="line">			data[largest] = temp;</div><div class="line">			maxHeapify(data, length, largest);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="建堆">建堆</h3>
<p><strong>buildMaxHeap</strong>算法是利用maxHeapify算法来进行的。用数组存储一个有n个元素堆时，叶节点的下标是n/2+1、n/2+2……n（这里就不做证明了，有兴趣可以自己证明），建立大根堆就是利用这个性质。叶节点可以看做只有一个元素的堆，只有一个元素也就自然满足大根堆的性质，所以以叶节点为根的堆都是大根堆。但是以其它节点为根的堆就不一定是大根堆，为了使他们满足大根堆的性质，就在节点上调用maxHeapify（叶节点是大根堆就满足了函数输入时的条件）。所以建立大根堆的过程就是在除叶节点以为的节点上调用maxHeapify。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span>(<span class="keyword">int</span>[] data){</div><div class="line">		<span class="keyword">int</span> start = getParentIndex(data.length);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &gt;= <span class="number">0</span>; i--) {</div><div class="line">			maxHeapify(data, data.length, i);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="堆排序-1">堆排序</h3>
<p><strong>heapSort</strong>也是利用maxHeapify算法来进行的。在一个大根堆中，最大元素就是堆的根。堆排序就是利用的这个性质。在一个含有n个元素的数组上调用buildMaxHeap，就能得到最大的元素，然后将最大的元素和数组的尾部，再将最大元素从堆中除去，此时堆的元素为n-1个，但是不满足大根堆的性质，就在根节点上调用maxHeapify使其成为大根堆。不断重复这个过程直到堆中只剩下一个元素，就完成了排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span>(<span class="keyword">int</span>[] data){</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = data.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) {</div><div class="line">			<span class="keyword">int</span> temp = data[<span class="number">0</span>];</div><div class="line">			data[<span class="number">0</span>]	= data[i];</div><div class="line">			data[i] = temp;</div><div class="line">			maxHeapify(data, i, <span class="number">0</span>);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h2 id="优先级队列">优先级队列</h2>
<p>优先级队列是一种用来维护由一组数组元素构成集合S的数据结构，每个元素都有一个关键字key。</p>
<ul>
<li>INSERT(S,x)：元素x插入集合S</li>
<li>MAXIMUN(S)：返回S中具有最大key的元素</li>
<li>EXTRACT-MAX(S)：去掉并返回S中具有最大key的元素</li>
<li>INCREASE-KEY(S,x,k)：将元素x的key值增加到k，k&gt;=key</li>
</ul>
<h3 id="伪代码">伪代码</h3>
<p>HEAP-MAXIMUN(A)，时间复杂度<code>O(1)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> A[<span class="number">1</span>];</div></pre></td></tr></table></figure>

<p>HEAP-EXTRACT-MAX(A)，时间复杂度<code>O(lgn)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> heap-size[A]&lt;<span class="number">1</span></div><div class="line">    then error <span class="string">"heap underflow"</span></div><div class="line">max ← A[<span class="number">1</span>]</div><div class="line">A[<span class="number">1</span>] ← A[heap-size[A]]</div><div class="line">heap-size[A] ← heap-size[A]-<span class="number">1</span></div><div class="line">MAX-HEAPIFY(A,<span class="number">1</span>)</div><div class="line"><span class="keyword">return</span> max</div></pre></td></tr></table></figure>

<p>HEAP-INCREASE-KEY(A,i,key)，时间复杂度<code>O(lgn)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> key&lt;A[i]</div><div class="line">    then error <span class="string">"new key is smaller than the current key"</span></div><div class="line">A[i] ← key</div><div class="line"><span class="keyword">while</span> i&gt;<span class="number">1</span> && A[parent[i]]&lt;A[i]</div><div class="line">    do exchange A[i] ↔ A[parent[i]]</div><div class="line">    i ← parent(i)</div></pre></td></tr></table></figure>

<p>HEAP-INSERT(A,key)，时间复杂度<code>O(lgn)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">heap-size[A] ← heap-size[A]+<span class="number">1</span></div><div class="line">A[heap-size[A]] ← -∞</div><div class="line">HEAP-INCREASE-KEY(A,heap-size[A],key)</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[堆数据结构是一种数组对象，它可以被视为一颗完全二叉树，树中每个节点与数组中存放该节点值的元素对应。]]>
    
    </summary>
    
      <category term="heap" scheme="http://alexyyek.github.io/tags/heap/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Count And Say]]></title>
    <link href="http://alexyyek.github.io/2014/12/06/CountAndSay/"/>
    <id>http://alexyyek.github.io/2014/12/06/CountAndSay/</id>
    <published>2014-12-06T09:31:42.000Z</published>
    <updated>2014-12-06T09:46:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Count_and_Say">Count and Say</h2>
<p>Question : The count-and-say sequence is the sequence of integers beginning as follows:<br><code>1, 11, 21, 1211, 111221, ...</code></p>
<p><code>1</code> is read off as <code>one 1</code> or <code>11</code>.<br><code>11</code> is read off as <code>two 1s</code> or <code>21</code>.<br><code>21</code> is read off as <code>one 2, then one 1</code> or <code>1211</code>.<br>Given an integer <code>n</code>, generate the nth sequence.<br><a id="more"></a> </p>
<h3 id="Best_solution">Best solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">countAndSay</span>(<span class="keyword">int</span> n) {</div><div class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line"></div><div class="line">	String first = <span class="string">"1"</span>;</div><div class="line">	<span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; first.length(); j++) {</div><div class="line">			<span class="keyword">if</span> (j &lt; first.length() - <span class="number">1</span></div><div class="line">					&& (first.charAt(j) == first.charAt(j + <span class="number">1</span>))) {</div><div class="line">				count++;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				sb.append(count + <span class="string">""</span> + first.charAt(j));</div><div class="line">				count = <span class="number">1</span>;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		first = sb.toString();</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> first;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>Analyze</strong> : 题目非常简单，序列迭代规则已经列出，求第n次迭代的值。基本方法判断相邻两个字符是否一样，算出每一次的序列值，迭代到n次为止。其实也可以用递归的方法来做，给出第n-1次的规则，求第n次的值。<br><br></p>
<hr>
<p>比较有意思的是用DFS的思想来解决此题，代码如下：</p>
<h3 id="DFS">DFS</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> String s = <span class="string">"1"</span>;</div><div class="line"><span class="keyword">public</span> String <span class="title">countSay</span>(<span class="keyword">int</span> n) {</div><div class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</div><div class="line">        dfs(s.length());</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span>(<span class="keyword">int</span> length) {</div><div class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">1</span>, i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (i &lt; length - <span class="number">1</span> && s.charAt(i) == s.charAt(<span class="number">1</span> + i)) {</div><div class="line">        count++;</div><div class="line">        i++;</div><div class="line">    }</div><div class="line">    s = s.substring(i + <span class="number">1</span>) + count + s.charAt(i);</div><div class="line">    dfs(length - count);</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>Analyze</strong> : 深度优先算法的思路也很简单，比如第4次迭代结果为1211，现在进行第5次迭代</p>
<ul>
<li>树<code>1-2-1-1</code>根节点为<code>1</code>，出现一次所以值变成<code>11</code>,树变成<code>2-1-1</code>，所以整体值为<code>21111</code>；</li>
<li>第二次运算<code>2</code>出现一次，值为<code>12</code>，树还剩<code>1-1</code>，所以整体值为<code>111112</code>，注意这里前面11是待统计的树<code>1-1</code>,中间的11是第一次的运算值，最后的12是第二次的运算值；</li>
<li>由于树<code>1-1</code>中<code>1</code>出现了两次，所以值为<code>21</code>，s = s.substring(i + 1) + count + s.charAt(i) = 111221</li>
</ul>
<h3 id="More">More</h3>
<p>这道题在leetcode上的表述略有不清，我第一次就把此题误解为给定任意整数n，去求此整数的第n次迭代值<br>比如5-&gt;15-&gt;1115-&gt;3115-&gt;132115-&gt;1113122115，结果发现高估此题了…<br>既然都写了就列在下面吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">countAndSay</span>(<span class="keyword">int</span> n) {</div><div class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>) {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	String word = String.valueOf(n);</div><div class="line">	<span class="keyword">while</span> (n &gt; <span class="number">0</span>) {</div><div class="line">		<span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">		StringBuffer sBuffer = <span class="keyword">new</span> StringBuffer();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) {</div><div class="line">			<span class="keyword">if</span> (i &lt; word.length() - <span class="number">1</span></div><div class="line">					&& word.charAt(i) == word.charAt(i + <span class="number">1</span>)) {</div><div class="line">				count++;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				sBuffer.append(count).append(word.charAt(i));</div><div class="line">				count = <span class="number">1</span>;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		word = sBuffer.toString();</div><div class="line">		n--;</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> word;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[The count-and-say sequence is the sequence of integers beginning as follows 1, 11, 21, 1211, 111221, ... , Given an integer n, generate the nth sequence.]]>
    
    </summary>
    
      <category term="dfs" scheme="http://alexyyek.github.io/tags/dfs/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Trapping Rain Water]]></title>
    <link href="http://alexyyek.github.io/2014/12/04/TrappingRainWater/"/>
    <id>http://alexyyek.github.io/2014/12/04/TrappingRainWater/</id>
    <published>2014-12-04T07:17:18.000Z</published>
    <updated>2014-12-04T07:49:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Trapping_Rain_Water">Trapping Rain Water</h2>
<p>Question : Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br><a id="more"></a><br>For example:<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><img src="http://leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png" alt=""></p>
<h3 id="Best_Solution">Best Solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span>(<span class="keyword">int</span>[] A) {</div><div class="line">		<span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> b = A.length - <span class="number">1</span>;</div><div class="line">		<span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> leftmax = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> rightmax = <span class="number">0</span>;</div><div class="line">		<span class="keyword">while</span> (a &lt;= b) {</div><div class="line">			leftmax = Math.max(leftmax, A[a]);</div><div class="line">			rightmax = Math.max(rightmax, A[b]);</div><div class="line">			<span class="keyword">if</span> (leftmax &lt; rightmax) {</div><div class="line">				max += (leftmax - A[a]); </div><div class="line">				a++;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				max += (rightmax - A[b]);</div><div class="line">				b--;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> max;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>Analyze</strong> : I calculated the stored water at each index a and b in my code. At the start of every loop, I update the current maximum height from left side (that is from A[0,1…a]) and the maximum height from right side(from A[b,b+1…n-1]). if(leftmax &lt; rightmax) then, at least (leftmax-A[a]) water can definitely be stored no matter what happens between [a,b] since we know there is a barrier at the rightside(rightmax &gt; leftmax).</p>
]]></content>
    <summary type="html">
    <![CDATA[Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.]]>
    
    </summary>
    
      <category term="Arrays" scheme="http://alexyyek.github.io/tags/Arrays/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Simplify Path]]></title>
    <link href="http://alexyyek.github.io/2014/11/30/SimplifyPath/"/>
    <id>http://alexyyek.github.io/2014/11/30/SimplifyPath/</id>
    <published>2014-11-30T13:13:12.000Z</published>
    <updated>2014-12-01T05:04:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Simplify_Path">Simplify Path</h2>
<p>Question:Given an absolute path for a file (Unix-style), simplify it.<br><a id="more"></a></p>
<p>For example,<br>path = <code>/home/</code> =&gt; <code>/home</code><br>path = <code>/a/./b/../../c/</code> =&gt; <code>/c</code><br><br></p>
<table>
<thead>
<tr>
<th>Situation</th>
<th style="text-align:center">Meaning</th>
<th style="text-align:center">Solution</th>
</tr>
</thead>
<tbody>
<tr>
<td>/..</td>
<td style="text-align:center">返回上级目录</td>
<td style="text-align:center">若stack不空，stack.pop()</td>
</tr>
<tr>
<td>/.</td>
<td style="text-align:center">留在本目录</td>
<td style="text-align:center">无操作</td>
</tr>
<tr>
<td>/</td>
<td style="text-align:center">多余的slash</td>
<td style="text-align:center">无操作</td>
</tr>
<tr>
<td>other</td>
<td style="text-align:center">有效目录名</td>
<td style="text-align:center">入栈</td>
</tr>
</tbody>
</table>
<h3 id="My_solution">My solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">soluition</span>(String path) {</div><div class="line">        String[] unit = path.split(<span class="string">"/"</span>);</div><div class="line">        StringBuffer line = <span class="keyword">new</span> StringBuffer();</div><div class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unit.length; i++) {</div><div class="line">        	<span class="keyword">if</span> (!unit[i].equals(<span class="string">""</span>)) {</div><div class="line">        		<span class="keyword">if</span> (unit[i].equals(<span class="string">"."</span>)) {</div><div class="line">    				<span class="keyword">continue</span>;</div><div class="line">    			}<span class="keyword">else</span> <span class="keyword">if</span> (unit[i].equals(<span class="string">".."</span>)) {</div><div class="line">    				<span class="keyword">if</span> (!stack.isEmpty()) {</div><div class="line">    					stack.pop();</div><div class="line">        				stack.pop();</div><div class="line">					}</div><div class="line">    			}<span class="keyword">else</span> {</div><div class="line">    				stack.push(<span class="string">"/"</span>);</div><div class="line">    				stack.push(unit[i]);</div><div class="line">    			}</div><div class="line">			}</div><div class="line">		}</div><div class="line">        <span class="keyword">if</span> (stack.isEmpty()) {</div><div class="line">			<span class="keyword">return</span> <span class="string">"/"</span>;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">while</span> (!stack.isEmpty()) {</div><div class="line">				line.insert(<span class="number">0</span>, stack.pop());</div><div class="line">			}</div><div class="line">			<span class="keyword">return</span> line.toString();</div><div class="line">		}</div><div class="line">    }</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[Question:Given an absolute path for a file (Unix-style), simplify it.]]>
    
    </summary>
    
      <category term="stack" scheme="http://alexyyek.github.io/tags/stack/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Valid Parentheses]]></title>
    <link href="http://alexyyek.github.io/2014/11/28/valid-parentheses/"/>
    <id>http://alexyyek.github.io/2014/11/28/valid-parentheses/</id>
    <published>2014-11-28T14:42:18.000Z</published>
    <updated>2014-11-29T06:16:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Valid_Parentheses">Valid Parentheses</h2>
<p>Question：Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.<br>The brackets must close in the correct order, <code>()</code> and <code>()[]{}</code> are all valid but <code>(]</code> and <code>([)]</code> are not.<br><a id="more"></a>  </p>
<h3 id="Best_Solution">Best Solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span>(String s){</div><div class="line">		HashMap&lt;Character, Character&gt;map = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</div><div class="line">		map.put(<span class="string">'('</span>, <span class="string">')'</span>);</div><div class="line">		map.put(<span class="string">'['</span>, <span class="string">']'</span>);</div><div class="line">		map.put(<span class="string">'{'</span>, <span class="string">'}'</span>);</div><div class="line">		</div><div class="line">		Stack&lt;Character&gt;stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) {</div><div class="line">			<span class="keyword">char</span> head = s.charAt(i);</div><div class="line">			</div><div class="line">			<span class="keyword">if</span> (map.containsKey(head)) {</div><div class="line">				stack.push(head);</div><div class="line">			}<span class="keyword">else</span> <span class="keyword">if</span> (map.values().contains(head)) {</div><div class="line">				<span class="keyword">if</span> (!stack.isEmpty() && map.get(stack.peek()).equals(head)) {</div><div class="line">					stack.pop();</div><div class="line">				}<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> stack.isEmpty();</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><strong>Analyze</strong>：思想非常简单，当看到左括号的时候就push入栈，看到右括号时与stack.peek相匹配，匹配成功则pop，如果字符串valid，则stack.isEmpty会为true，即所有左括号都匹配到对应的右括号。<br>PS. 一定要在else if内加栈空判断，防止字符串以右括号开始，如<code>}[()]</code><br><br></p>
<h3 id="My_Solution">My Solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span>(String s){</div><div class="line">		HashMap&lt;String, String&gt;map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">		map.put(<span class="string">"("</span>, <span class="string">")"</span>);</div><div class="line">		map.put(<span class="string">"["</span>, <span class="string">"]"</span>);</div><div class="line">		map.put(<span class="string">"{"</span>, <span class="string">"}"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (s.length()%<span class="number">2</span> != <span class="number">0</span>) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		}</div><div class="line">		</div><div class="line">		Stack&lt;String&gt;stack = <span class="keyword">new</span> Stack&lt;String&gt;();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = s.length(); i &gt; <span class="number">0</span>; i--) {</div><div class="line">			stack.push(s.substring(i-<span class="number">1</span>, i));</div><div class="line">		}</div><div class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (!map.containsKey(stack.peek())) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">while</span> (!stack.isEmpty()) {</div><div class="line">			String head = stack.pop();</div><div class="line">			<span class="keyword">if</span> (map.containsKey(head)) {</div><div class="line">				list.add(head);</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				<span class="keyword">if</span> (head.equals(map.get(list.get(list.size() - <span class="number">1</span>)))) {</div><div class="line">					list.remove(list.size() - <span class="number">1</span>);</div><div class="line">				}<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (!list.isEmpty()) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. The brackets must close in the correct order, `()` and `()[]{}` are all valid but `(]` and `([)]` are not.]]>
    
    </summary>
    
      <category term="stack" scheme="http://alexyyek.github.io/tags/stack/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Min Stack]]></title>
    <link href="http://alexyyek.github.io/2014/11/19/Stack/"/>
    <id>http://alexyyek.github.io/2014/11/19/Stack/</id>
    <published>2014-11-19T12:54:53.000Z</published>
    <updated>2014-11-28T14:50:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Min_Stack">Min Stack</h2>
<p>Question : Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.<br><a id="more"></a>   </p>
<ul>
<li>push(x) — Push element x onto stack.</li>
<li>pop() — Removes the element on top of the stack.</li>
<li>top() — Get the top element.</li>
<li>getMin() — Retrieve the minimum element in the stack.<br><br></li>
</ul>
<hr>
<h3 id="Best_solution">Best solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStackBest</span> </span>{</div><div class="line">	Stack&lt;Long&gt; stack;</div><div class="line">	<span class="keyword">long</span> min = <span class="number">0</span>;</div><div class="line">	<span class="keyword">public</span> <span class="title">MinStackBest</span>() {</div><div class="line">		stack = <span class="keyword">new</span> Stack&lt;Long&gt;();</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(<span class="keyword">int</span> x) {</div><div class="line">		<span class="keyword">if</span> (stack.isEmpty()) {</div><div class="line">			stack.push(<span class="number">0</span>L);</div><div class="line">			min = x;</div><div class="line">		} <span class="keyword">else</span> {</div><div class="line">			stack.push(x - min);</div><div class="line">			<span class="keyword">if</span> (x &lt; min) {</div><div class="line">				min = x;</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span>() {</div><div class="line">		<span class="keyword">if</span> (stack.isEmpty()) {</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		}</div><div class="line">		<span class="keyword">long</span> pop = stack.pop();</div><div class="line">		<span class="keyword">if</span> (pop &lt; <span class="number">0</span>) {</div><div class="line">			min = min - pop;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span>() {</div><div class="line">		<span class="keyword">long</span> top = stack.peek();</div><div class="line">		<span class="keyword">if</span> (top &gt; <span class="number">0</span>) {</div><div class="line">			<span class="keyword">return</span> (<span class="keyword">int</span>) (min + top);</div><div class="line">		} <span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> (<span class="keyword">int</span>) min;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span>() {</div><div class="line">		<span class="keyword">return</span> (<span class="keyword">int</span>) min;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>The thought is to store the gap between the current value and min value, while the only problem is int is 4 bit<br>so the Max gap = Integer.MAXVALUE - Integer.MINVALUE, and that value beyond int, so the author init the min value as long.</p>
<p><br></p>
<h3 id="Another_solution">Another solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>{</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> class Element{</div><div class="line">		<span class="keyword">final</span> <span class="keyword">int</span> value;</div><div class="line">		<span class="keyword">final</span> <span class="keyword">int</span> min;</div><div class="line">		Element(<span class="keyword">int</span> value, <span class="keyword">int</span> min){</div><div class="line">			<span class="keyword">this</span>.value = value;</div><div class="line">			<span class="keyword">this</span>.min = min;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	Stack&lt;Element&gt;stack = <span class="keyword">new</span> Stack&lt;Element&gt;();</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(<span class="keyword">int</span> x) {</div><div class="line">		<span class="keyword">int</span> min = (stack.isEmpty()) ? x : Math.min(x, stack.peek().min);</div><div class="line">		stack.push(<span class="keyword">new</span> Element(x, min));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span>() {</div><div class="line">    	stack.pop();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span>() {</div><div class="line">    	<span class="keyword">return</span> stack.peek().value;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span>() {</div><div class="line">        <span class="keyword">return</span> stack.peek().min;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><br></p>
<h2 id="Review_Stack">Review Stack</h2>
<p>Here’s the source code, compose by one Constructor and five Method</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line">	 * 构造函数</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="title">Stack</span>() {</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * push函数：将元素存入栈顶</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> E <span class="title">push</span>(E item) {</div><div class="line">		<span class="comment">// 将元素存入栈顶。</span></div><div class="line">		<span class="comment">// addElement()的实现在Vector.java中</span></div><div class="line">		addElement(item);</div><div class="line"></div><div class="line">		<span class="keyword">return</span> item;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * pop函数：返回栈顶元素，并将其从栈中删除</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span>() {</div><div class="line">		E obj;</div><div class="line">		<span class="keyword">int</span> len = size();</div><div class="line"></div><div class="line">		obj = peek();</div><div class="line">		<span class="comment">// 删除栈顶元素，removeElementAt()的实现在Vector.java中</span></div><div class="line">		removeElementAt(len - <span class="number">1</span>);</div><div class="line"></div><div class="line">		<span class="keyword">return</span> obj;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * peek函数：返回栈顶元素，不执行删除操作</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span>() {</div><div class="line">		<span class="keyword">int</span> len = size();</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (len == <span class="number">0</span>)</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</div><div class="line">		<span class="comment">// 返回栈顶元素，elementAt()具体实现在Vector.java中</span></div><div class="line">		<span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 栈是否为空</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span>() {</div><div class="line">		<span class="keyword">return</span> size() == <span class="number">0</span>;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 查找“元素o”在栈中的位置：由栈底向栈顶方向数</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span>(Object o) {</div><div class="line">		<span class="comment">// 获取元素索引，elementAt()具体实现在Vector.java中</span></div><div class="line">		<span class="keyword">int</span> i = lastIndexOf(o);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) {</div><div class="line">			<span class="keyword">return</span> size() - i;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">	}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Min_Stack">Min Stack</h2>
<p>Question : Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.<br>]]>
    
    </summary>
    
      <category term="stack" scheme="http://alexyyek.github.io/tags/stack/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Single Number]]></title>
    <link href="http://alexyyek.github.io/2014/11/17/Single-Number/"/>
    <id>http://alexyyek.github.io/2014/11/17/Single-Number/</id>
    <published>2014-11-17T08:30:25.000Z</published>
    <updated>2014-11-28T14:45:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Single_Number">Single Number</h2>
<p>Question : Given an array of integers, every element appears <code>twice</code> except for one. Find that single one.<br><a id="more"></a><br><br></p>
<h3 id="Best_solution">Best solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span>(<span class="keyword">int</span>[] A) {</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) {</div><div class="line">			result ^= A[i];</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="My_solution">My solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span>(<span class="keyword">int</span>[] A) {</div><div class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) {</div><div class="line">			<span class="keyword">int</span> key = A[i];</div><div class="line">			<span class="keyword">if</span> (map.containsKey(key)) {</div><div class="line">				map.put(key, map.get(key) + <span class="number">1</span>);</div><div class="line">				<span class="keyword">if</span> (map.get(key) == <span class="number">2</span>) {</div><div class="line">					map.remove(key);</div><div class="line">				}</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				map.put(key, <span class="number">1</span>);</div><div class="line">			}</div><div class="line">		}</div><div class="line">		String result = map.keySet().toString();</div><div class="line">		<span class="keyword">int</span> out = Integer.parseInt(result.substring(<span class="number">1</span>, result.length()-<span class="number">1</span>));</div><div class="line">		<span class="keyword">return</span> out;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>从性能上来评判用XOR无疑使最好的，复杂度只有O(N)。</p>
<p>我个人的方法略显笨拙，复杂度虽然也是O(N), 但开辟的多余的内存空间，不过当element出现的次数改变时，反而有更好的鲁棒性.<br><br></p>
<h3 id="change_question">change question</h3>
<p>Given an array of integers, every element appears <code>three</code> times except for one. Find that single one.<br><br></p>
<h4 id="best_answer">best answer</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span>(<span class="keyword">int</span>[] A) {</div><div class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++){</div><div class="line">        ones = (ones ^ A[i]) & ~twos;</div><div class="line">        twos = (twos ^ A[i]) & ~ones;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> ones;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><br></p>
<h4 id="Inference">Inference</h4>
<p>题目中改变了element的出现次数，变成了出现三次，当然用我之前的程序改个数字就能搞定，但仍需要分析一下最优的解法<br>best answer思路：出现三次，可以用2个bit来表征这三个状态，分别是00→10→01→00<br>ones和twos分别承担了这两个bit位<br>如果推理一下可以发现</p>
<blockquote>
<p>ones = ones ^ A[i]; if (twos == 1) then ones = 0, that can be tansformed to ones = (ones ^ &gt;A[i]) &amp; ~twos.</p>
<p>twos = twos ^ A[i]; if (ones == 1) then twos = 0 and twos = (twos ^ A[i]) &amp; ~ones.</p>
</blockquote>
<p><br></p>
<h2 id="回顾">回顾</h2>
<p><br></p>
<h3 id="位移动运算符:">位移动运算符:</h3>
<p><strong>&lt;&lt;</strong>表示左移, 左移一位表示原来的值乘2.</p>
<p>例如：3 &lt;&lt;2(3为int型) </p>
<blockquote>
<ol>
<li>把3转换为二进制数字0000 0000 0000 0000 0000 0000 0000 0011， </li>
<li>把该数字高位(左侧)的两个零移出，其他的数字都朝左平移2位， </li>
<li>在低位(右侧)的两个空位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100. 转换为十进制是12。</li>
</ol>
</blockquote>
<p>同理<strong>&gt;&gt;</strong>表示右移. 右移一位表示除2. </p>
<p>低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1 </p>
<p><br></p>
<h3 id="位运算:">位运算:</h3>
<p>位运算符包括:　与（&amp;）、非（~）、或（|）、异或（^）</p>
<blockquote>
<p>&amp;：当两边操作数的位同时为1时，结果为1，否则为0。如1100&amp;1010=1000 　</p>
<p>| ：当两边操作数的位有一边为1时，结果为1，否则为0。如1100|1010=1110 　</p>
<p>~：0变1,1变0 　　</p>
<p>^：两边的位不同时，结果为1，否则为0.如1100^1010=0110</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Single_Number">Single Number</h2>
<p>Question : Given an array of integers, every element appears <code>twice</code> except for one. Find that single one.<br>]]>
    
    </summary>
    
      <category term="Bit Manipulation" scheme="http://alexyyek.github.io/tags/Bit-Manipulation/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java处理字符串-删除所有标点]]></title>
    <link href="http://alexyyek.github.io/2014/11/15/new/"/>
    <id>http://alexyyek.github.io/2014/11/15/new/</id>
    <published>2014-11-15T06:45:40.000Z</published>
    <updated>2014-11-28T14:44:06.000Z</updated>
    <content type="html"><![CDATA[<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str = str.replaceAll(<span class="string">"[\\pP‘’“”]"</span>, <span class="string">""</span>);</div></pre></td></tr></table></figure>

<p>在这里利用的是Unicode编码，Unicode 编码并不只是为某个字符简单定义了一个编码，而且还将其进行了归类。</p>
<p><a id="more"></a><br>\pP 其中的小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。</p>
<p>大写 P 表示 Unicode 字符集七个字符属性之一：标点字符。其他六个包括：</p>
<ul>
<li>L：字母 </li>
<li>M：标记符号（一般不会单独出现）</li>
<li>Z：分隔符（比如空格、换行等）      </li>
<li>S：符号（比如数学符号、货币符号等）</li>
<li>N：数字（比如阿拉伯数字、罗马数字等）</li>
<li>C：其他字符</li>
</ul>
<p>Java 中用于 Unicode 的正则表达式数据都是由 Unicode 组织提供的。<br>Unicode 正则表达式<a href="http://www.unicode.org/reports/tr18/" target="_blank" rel="external">标准</a>（可以找到所有的子属性）<br>这个<a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt" target="_blank" rel="external">文本文档</a>一行是一个字符，第一列是 Unicode 编码，第二列是字符名，第三列是 Unicode 属性，以及其他一些字符信息。</p>
<h3 id="实例">实例</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span> str = <span class="string">",.!，，D_NAME。！；‘’”“《》**dfs  #$%^&()-+1431221中国123漢字かどうかのjavaを決定"</span>;  </div><div class="line">str = str.replaceAll(<span class="string">"[\\pP‘’“”]"</span>, <span class="string">""</span>);  </div><div class="line">System.out.println(str);</div></pre></td></tr></table></figure>

<p>输出结果: DNAMEdfs  $^+1431221中国123漢字かどうかのjavaを決定</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str = str.replaceAll(<span class="string">"[\\pP‘’“”]"</span>, <span class="string">""</span>);</div></pre></td></tr></table></figure>

<p>在这里利用的是Unicode编码，Unicode 编码并不只是为某个字符简单定义了一个编码，而且还将其进行了归类。</p>
<p>]]>
    
    </summary>
    
      <category term="skill" scheme="http://alexyyek.github.io/tags/skill/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
</feed>
