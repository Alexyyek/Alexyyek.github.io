<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[AlexYoung's blog]]></title>
  <subtitle><![CDATA[当你的才华还撑不起你的野心时，你就应该静下心来学习。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://alexyyek.github.io/"/>
  <updated>2014-12-31T15:55:24.592Z</updated>
  <id>http://alexyyek.github.io/</id>
  
  <author>
    <name><![CDATA[AlexYoung]]></name>
    <email><![CDATA[alexyyek@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[写在2014边上]]></title>
    <link href="http://alexyyek.github.io/2014/12/31/2014/"/>
    <id>http://alexyyek.github.io/2014/12/31/2014/</id>
    <published>2014-12-31T13:46:08.000Z</published>
    <updated>2014-12-31T15:55:18.000Z</updated>
    <content type="html"><![CDATA[<h2 id="2014总结">2014总结</h2>
<p>2014年对我来说是过得非常快的一年，这种快不是由于过于重复单调而产生的那种令人忘却的快，而是因为在这一年我遇见了很多有趣的人，走遍了很多有趣的地方，激发了很多想要列上Todo List的想法，也更加坚定了自己前进的方向后，那种突然将未来的所有可能性放在眼前让人应接不暇的快。</p>
<h3 id="实习">实习</h3>
<p>2013年研究生刚刚入学，十一月份便跑去参加了百度的实习面试，现在回想起来当初其实并不是非常想要实习，只是想试试自己能不能获得某种程度的认可。一共面了两家公司，搜狗和百度，搜狗的面试让我充分意识到了机器学习中人工标注和预处理的重要性，但并不是非常符合我的预期，所以委婉拒绝了搜狗的实习。第二天面百度，两轮下来就两个小时没了，虽然有的问题没有回答上来，但给出了基本的思路和尝试方法，一周内便接到了入职的电话。</p>
<p>一实习便是半年，从最初的很多东西都不懂，通过不断的请教各位大神，自己查资料想解决办法，到能独立的完成每天的Job，再开始略加指导新来的同事，这半年见证了我的成长。当然实习有利有弊，在获得实习能力提升的时候，往往很难顾及实验室的工作，这是我比较遗憾的地方，人的精力还是有限的，需要合理分配。</p>
<p>这里想说一下百度给我个人的印象，也方便想去实习的同学有个参考吧。首先百度的公司氛围非常好，有很浓厚的技术气息，因为基本上都是三十岁以下的年轻人，讨论或者咨询问题都非常舒服，可以充分开发你的脑洞，提出不同的想法和思路。其次百度的作息时间也比较合理，早上十点上班，下午六点下班，周末放假。最后也是最幸福的一点便是每个季度都可以免费向公司买书，这对于实习生有莫大的价值。</p>
<h3 id="生活">生活</h3>
<p>五月末辞了实习，便和妹子去杭州玩了一趟，至于为什么选择杭州，当然是有阿里的成分在里面，相比帝都的房价和雾霾，我可能更偏向选择较为舒适的南方城市。</p>
<p>杭州的景色并没有辜负我的期望，想去游玩的同学不要错过，土豪记得带上你们的单反，出片率高到飞起。杭州的美食也非常可口，虽然饮食口味偏于清淡，但灵活多变的美食做法也不会让你厌倦。</p>
<p>唯一可惜的就是阿里上市了，就这么在我还没毕业之前上市了…</p>
<h3 id="感悟">感悟</h3>
<p>常常和别人谈论到一个很土的话题，成功与失败。</p>
<p>聪明的人告诉我你应该理性分析，合理投资，回避风险，最大化收益。话并没有错，但如果你是一个程序猿，请听下面的建议：</p>
<p>我觉得你应该尝试经历失败。</p>
<p>常常让我感触比较深的是在学习一种新的技术时，明明有网上的教程指导，但还是出现了各种奇怪的问题，按理说不应该发生的问题。于是我不断的寻找解决方案，对比不同的解决方法，分析他们的原理，最后选择合适的方案继续下一步，然后再遇到突发问题，再解决掉，如此不断反复，总算是亦趋亦步的走了过来。</p>
<p>然后回头再看那个教程，你应该会有这样一种感觉，我可以针对你这个教程专门再写一个教程来纠正和补充你，并且解释其中的原理。并且无论以后面试中问到这方面的问题，还是实际工作中遇到这方面的问题，我相信都能理性的分析，并快速定位问题源头，最终合理的解决。</p>
<p>而如果我当初按照那个教程傻傻的一遍成功了，可能我并不会了解这么深。</p>
<p>所以想说的本质其实就是一句话：<strong>一定要重视理解的深度。</strong></p>
<p>我相信这便是人与人的区别。</p>
<h2 id="2015_Todo_List">2015 Todo List</h2>
<ul>
<li>一两个拿得出手的项目</li>
<li>实习经验，创业公司为先，有项目可参与</li>
<li>刷面试书籍 </li>
<li>学习一门动态语言</li>
<li>论文中稿，求过！！！ </li>
<li>五月去内蒙古</li>
<li>拿到理想中的offer好养活妹纸</li>
</ul>
<p>最后祝大家元旦快乐~单身狗早日脱单，找到想要的实习和工作~~<br>请接收我最真诚的祝福。</p>
]]></content>
    <summary type="html">
    <![CDATA[You do what you love, and fuck the rest.]]>
    
    </summary>
    
      <category term="life" scheme="http://alexyyek.github.io/tags/life/"/>
    
      <category term="生活感悟" scheme="http://alexyyek.github.io/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[免费且使用便捷的翻墙方案]]></title>
    <link href="http://alexyyek.github.io/2014/12/31/GFW/"/>
    <id>http://alexyyek.github.io/2014/12/31/GFW/</id>
    <published>2014-12-31T09:55:42.000Z</published>
    <updated>2014-12-31T10:52:41.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录">目录</h2>
<p>翻墙方法多如牛毛，但都因为自身的因素而各有利弊。Freegate使用简单，适合初学者，但开启后访问国内网站将出现问题；VPN有的收费有的免费，免费的VPN由于使用者众多网速low的一比，收费的能够提供更好的服务，但需要为之买单。而且从技术角度分析VPN加密流程会发现：你的机子-&gt;(加密)-&gt;VPN-&gt;(解密后的)-&gt;访问目标机子，就算你的机子和VPN之间怎么加密，在最终发给目标机子都会还原成没加密的。这并不是吓唬大家，只是万事有利有弊，自行取舍罢了。而上一篇<a href="http://alexyyek.github.io/2014/12/27/ipv6/" target="_blank" rel="external">改Hosts</a>的办法虽然简单，但能翻的网站有限，而且需要不断更新。</p>
<p>下面推荐的是一种基于GAE（Google App Engine）+ goagent + switchysharp + chrome的翻墙之法，相对刚才介绍的方案，此方法上手较易，使用体验也非常不错（当你配置完后便能充分的感受到），并且完全免费。所以请不要害怕这过长的篇幅，按部就班10分钟左右搞定。</p>
<p>那么让我们一起迎接2015这新世界吧。</p>
<p><center> <img src="http://alexyoung.qiniudn.com/464564.jpg" alt=""> <center><br><br></center></center></p>
<hr>
<h3 id="入门介绍">入门介绍</h3>
<ol>
<li>GAE（Google App Engine）是一个开发、托管网络应用程序的平台；</li>
<li>goagent是一个使用Python和Google Appengine SDK编写的代理软件；</li>
<li>switch sharp是一个chrome插件，具体功能类似于Firefox的AutoProxy.</li>
</ol>
<h3 id="申请Google_App_Engine并创建app">申请Google App Engine并创建app</h3>
<ul>
<li>首先去注册一个google账户，没有绑定手机号码的建议<a href="https://security.google.com/settings/security/signinoptions/rescuephone" target="_blank" rel="external">绑定</a>。</li>
<li>创建属于你的<a href="https://appengine.google.com/start/createapp" target="_blank" rel="external"><strong>Application</strong></a>，填写你的APP ID，</li>
</ul>
<p><strong>错误体位</strong>：</p>
<p><center> <img src="http://alexyoung.qiniudn.com/GAE1.png" alt=""> <center></center></center></p>
<p><strong>正确体位</strong></p>
<p><center> <img src="http://alexyoung.qiniudn.com/GAE2.png" alt=""> <center></center></center></p>
<p><strong>填写方式</strong></p>
<p><center> <img src="http://alexyoung.qiniudn.com/GAE3.png" alt=""> <center></center></center></p>
<ul>
<li>一切正常的话就会看到下面的界面（告诉你App已经申请成功了）<br><center> <img src="http://alexyoung.qiniudn.com/GAE4.png" alt=""> <center></center></center></li>
</ul>
<p><br><br><strong>注意</strong>：GAE的check不一定可靠，可能出现提示available但是commit后提示<code>This application ID or version is already in use</code>的情况，所以请另换ID。现在每个用户可以创建25个APP，每个应用每天有1GB的免费流量。如果你经常下载或者观看视频建议多创建几个Google App Engine应用。<br><br></p>
<hr>
<h3 id="下载_goagent_并上传至_Google_App_Engine">下载 goagent 并上传至 Google App Engine</h3>
<ul>
<li>去Github下载 <a href="https://github.com/goagent/goagent" target="_blank" rel="external"><strong>goagent客户端</strong></a> 并解压，目前是3.2.3版</li>
<li>修改<code>\local\proxy.ini</code>，把其中 appid = goagent 中的 goagent 改成你之前申请的应用的 appid 后保存。<br><center> <img src="http://alexyoung.qiniudn.com/GFW9.jpg" alt=""> <center></center></center></li>
</ul>
<p>如果要使用多个appid，appid之间用<code>|</code>隔开，如：<code>appid1|appid2|appid3</code>，每个 appid 必须确认上传成功才能使用</p>
<blockquote>
<p>[gae]<br>appid = appid1|appid2|appid3</p>
</blockquote>
<ul>
<li>双击 server 文件夹下的 uploader.bat， 依次输入你的Application ID，邮箱地址和密码（如果设置了Gmail的两步验证请输入两步验证中生成的16位密码，即为独立应用单独生成的随机16位字符，而不是你的邮箱密码，Gmail两步验证在这里<a href="http://www.cooear.com/archives/168.htm" target="_blank" rel="external">详细介绍</a>）<br><center> <img src="http://alexyoung.qiniudn.com/GFW10.jpg" alt=""> <center></center></center></li>
</ul>
<p><br></p>
<ul>
<li>看到下面的提示便上传成功。<br><center> <img src="http://alexyoung.qiniudn.com/GFW6.jpg" alt=""> <center></center></center></li>
</ul>
<p><strong>注意</strong>：如果输完账户密码后出现：<code>AttributeError: can’t set attribute</code> 的问题，可尝试进入 <a href="https://www.google.com/settings/security" target="_blank" rel="external"><strong>Google 安全性</strong></a> 页面里看到了『帐户所授权限』 中的『不够安全的应用的访问权限』，进入设置之后，点击『启用』即可。<br><br></p>
<hr>
<h3 id="Chrome下安装Switchysharp">Chrome下安装Switchysharp</h3>
<ul>
<li>去chrome的<a href="https://chrome.google.com/webstore/category/home" target="_blank" rel="external">应用商店</a>安装Switchysharp</li>
<li><p>下载好后Switchysharp图标会出现在chrome的右上角，点击选项<br><center> <img src="http://alexyoung.qiniudn.com/GFW11.jpg" alt=""> <center></center></center></p>
</li>
<li><p>在导入/导出界面，选择从文件恢复，选中<code>\local\SwitchyOptions.bak</code>确认导入<br><center> <img src="http://alexyoung.qiniudn.com/GFW8.jpg" alt=""> <center></center></center></p>
</li>
<li><p>成功导入后，想去外网时选择自动切换模式即可，不访问时便选择直接连接<br><center> <img src="http://alexyoung.qiniudn.com/GFW12.jpg" alt=""> <center></center></center></p>
</li>
</ul>
<p><strong>注意</strong>：使用Firefox浏览器和opera浏览器的同学去<a href="https://github.com/goagent/goagent/blob/wiki/InstallGuide.md" target="_blank" rel="external"><strong>这里</strong></a>看配置插件教程。<br><br></p>
<hr>
<h3 id="最后">最后</h3>
<p>恭喜你已经成功配置好了插件，想去外网时记得先打开<code>local\goagent.exe</code>，最好管理员权限打开，如果嫌每次都打开麻烦，设置开机自动启动也OK，浏览器会根据你浏览的具体界面选择代理方式，一键都不用便可翻墙，这便是此方案便捷的地方。</p>
<p>有兴趣的同学可以研究研究<a href="http://shadowsocks.cn/" target="_blank" rel="external">ShadowSocks</a>，ShadowSocks服务器端提供了各种版本，如Python、Nodejs、Go、C libev等等，安装配置过程极其简单。而用户端则可以在windows、mac、iOS和android上轻松运行。首先，当然你需要有一个shadowsocks账号。(￣∇￣;)</p>
]]></content>
    <summary type="html">
    <![CDATA[不要问我为什么翻墙，因为墙就在那里。]]>
    
    </summary>
    
      <category term="skill" scheme="http://alexyyek.github.io/tags/skill/"/>
    
      <category term="黑科技" scheme="http://alexyyek.github.io/categories/%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对象和引用]]></title>
    <link href="http://alexyyek.github.io/2014/12/29/Reference/"/>
    <id>http://alexyyek.github.io/2014/12/29/Reference/</id>
    <published>2014-12-29T13:43:15.000Z</published>
    <updated>2014-12-30T13:08:38.000Z</updated>
    <content type="html"><![CDATA[<p>Java中对象和引用的东西之前看了不少，但一方面因为网上知识过于繁杂，不能很好的梳理，另一方面不同的博客讲解专业程度不一样，可能会导致一定的误解。此篇博客争取以最精炼，最具条理的方式理清其中的难点和疑点。</p>
<h2 id="对象和引用">对象和引用</h2>
<h3 id="对象">对象</h3>
<blockquote>
<p>《Java编程思想》：按照通俗的说法，每个对象都是某个类（class）的一个实例（instance），这里，‘类’就是‘类型’的同义词。</p>
</blockquote>
<p><strong>理解本质</strong>：对象是类的实例。例如<a href="http://ww2.sinaimg.cn/bmiddle/53539f83jw1emh2fiopjtj20u01hc4qp.jpg" target="_blank" rel="external">Alex</a>是人类，Alex是对象，就是“人类”的实例。对象一般存储在堆中。</p>
<h3 id="引用">引用</h3>
<blockquote>
<p>《Java编程思想》： 每种编程语言都有自己的数据处理方式。有些时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（例如C/C++里的指针）来操作对象。所有这些在 Java 里都得到了简化，一切都被视为对象。因此，我们可采用一种统一的语法。尽管将一切都“看作”对象，但操纵的标识符实际是指向一个对象的“引用”（reference）。</p>
</blockquote>
<p><strong>理解本质</strong>：引用是指向对象的标识符。可以理解对象是一个个气球，我们通过引用这条绳子和它链接。引用存储在速度更快的堆栈中。 </p>
<h3 id="实例讲解">实例讲解</h3>
<p>首先看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>{</div><div class="line">	String name;</div><div class="line">	String sex;</div><div class="line">	<span class="keyword">int</span> age;</div><div class="line">	</div><div class="line">	<span class="comment">//构造函数</span></div><div class="line">	<span class="keyword">public</span> <span class="title">People</span>(){</div><div class="line">	</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">People</span>(String name, String sex, <span class="keyword">int</span> age){</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.sex = sex;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>people是一个类，包含属性 name、sex、age，有了这个类，我们创建对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">People one = <span class="keyword">new</span> People();</div></pre></td></tr></table></figure>

<p>这条语句的动作称为创建一个对象，它包含了四个动作:</p>
<ol>
<li>右边的new People，是以Pelple类为模板，在堆空间中创建一个People类对象</li>
<li>结尾的()，在对象创建后，立刻调用People类的构造函数，对刚生成的对象初始化。这个例子中包含了构造函数，如果没写，java会自动帮你补上。</li>
<li>左侧的People one创建了一个People类的引用变量。即one是指向People对象的引用。</li>
<li>“=”操作符使对象引用<strong>指向</strong>刚创建的People对象。注意是指向，不是赋值。</li>
</ol>
<p>可以将上面的话拆成两句，效果一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">People one;</div><div class="line">one = <span class="keyword">new</span> People();</div></pre></td></tr></table></figure>

<p>如果只执行了第一条语句，还没执行第二条，此时创建的引用变量one还没指向任何一个对象，它的值是null。引用变量可以指向某个对象，或者为null。然后看下面这段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">People two;</div><div class="line">two = one;</div></pre></td></tr></table></figure>

<p>首先又创建了一个引用two，此时two指向null，第二句将one指向的地址传给two，发生了复制行为，注意这里复制的是<code>对象引用</code>，此时two也指向one所指的对象，具体如何传递后面会讲。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">two = <span class="keyword">new</span> People();</div></pre></td></tr></table></figure>

<p>这句将two指向了一个新的对象，所以可以分析如下两条性质：</p>
<ol>
<li>一个引用可以指向0个或1个对象（一根绳子可以不系汽球，也可以系一个汽球）；</li>
<li>一个对象可以有N个引用指向它（可以有N条绳子系住一个汽球）。 </li>
</ol>
<p>如果发生这样的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">People one = <span class="keyword">new</span> People(<span class="string">"张三"</span>);</div><div class="line">People two = <span class="keyword">new</span> People(<span class="string">"李四"</span>);</div><div class="line">one = two;</div></pre></td></tr></table></figure>

<p>按上面的逻辑，引用one先指向对象“张三”，然后又指向了引用two指向的“李四”，所以最后one和two都指向对象“李四”，问题是之前的对象“张三”呢？还在堆里么？</p>
<p>多数书里说，它被Java的垃圾回收机制回收了。这不确切。</p>
<blockquote>
<p>正确地说，它已成为垃圾回收机制的处理对象。至于什么时候真正被回收，那要看垃圾回收机制的心情了。 </p>
</blockquote>
<p><br></p>
<hr>
<h3 id="参数传递">参数传递</h3>
<p>参数传递是个大坑，面试时常常会被问及，但其实并不难，看透本质即可。</p>
<blockquote>
<p>《thinking in Java》：When you’re passing primitives into a method，you get a distinct copy of the primitive. When you’re passing a reference into a method, you get a copy of the reference.</p>
</blockquote>
<p><strong>本质</strong>：不管JAVA参数类型是什么，一律传递参数的<strong><code>副本</code></strong></p>
<p><br></p>
<h4 id="例一">例一</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		<span class="keyword">boolean</span> test = <span class="keyword">true</span>;</div><div class="line">		System.out.println(<span class="string">"before test() :"</span> + test);</div><div class="line">		test(test);</div><div class="line">		System.out.println(<span class="string">"after test() :"</span> + test);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="keyword">boolean</span> test){</div><div class="line">		test = !test;</div><div class="line">		System.out.println(<span class="string">"In test() :"</span> + test);</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><strong>分析</strong>：首先声明一个基本类型为boolean的对象true，并用test指向它，在函数test内，引用test将值的副本传递进去，所以原本的test不改变，在test内输出false，而after test仍然还是true。<br><strong>注意</strong>：基本类型传值的副本，对象变量传引用的副本<br><br></p>
<h4 id="例二">例二</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		StringBuffer string = <span class="keyword">new</span> StringBuffer(<span class="string">"Hello"</span>);</div><div class="line">		test(string);</div><div class="line">		System.out.println(string);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>(StringBuffer str){</div><div class="line">		str.append(<span class="string">",world!"</span>);</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><strong>分析</strong>：首先声明一个stringbuffer类型的对象型变量，string指向对象Hello，在test内将string的引用副本传给str，因此string和str都在栈内指向同一个堆地址，只不过所处栈地址不同。test内改变了str指向的对象，因此string指向的对象也改变了，变成Hello,world!.<br><br></p>
<h4 id="例三">例三</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class value{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">15</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dataType</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		dataType type = <span class="keyword">new</span> dataType();</div><div class="line">		type.first();</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span>(){</div><div class="line">		<span class="keyword">int</span> i = <span class="number">5</span>;</div><div class="line">		value v = <span class="keyword">new</span> value();</div><div class="line">		v.i = <span class="number">25</span>;</div><div class="line">		second(v, i);</div><div class="line">		System.out.println(v.i);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span>(value v, <span class="keyword">int</span> i){</div><div class="line">		i = <span class="number">0</span>;</div><div class="line">		v.i = <span class="number">20</span>;</div><div class="line">		value val = <span class="keyword">new</span> value();</div><div class="line">		v = val;</div><div class="line">		System.out.println(v.i + <span class="string">" "</span> + i);</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<ol>
<li><p>在first内，首先程序在栈内存中开辟了一块地址编号为AD9500内存空间，用于存放<code>v</code>的引用地址，里边放的值是堆内存中的一个地址，示例中的值为BE2500<br><center> <img src="http://alexyoung.qiniudn.com/QQ图片20141229225902.png" alt=""> <center></center></center></p>
</li>
<li><p>调用函数second，程序在栈内开辟地址为AD9600内存空间存放v的副本，v的副本同样指向堆地址为BE2500的空间，然后将v的副本传入second，并且在second内，将v的副本所指对象<code>i=25</code>改为<code>i=20</code><br><center> <img src="http://alexyoung.qiniudn.com/QQ图片20141229225924.png" alt=""> <center></center></center></p>
</li>
<li><p>在second内，程序新建一个对象放在地址为BE2600的堆内，并用新的引用val（栈中地址为AD9700）指向它，所以second中输出结果为：15 0<br><center> <img src="http://alexyoung.qiniudn.com/QQ图片20141229225934.png" alt=""> <center></center></center></p>
</li>
<li><p>但原v并未改变，改变的只是它传入second的副本，所以在first中仍然输出<code>i=20</code><br><br></p>
</li>
</ol>
<hr>
<p><strong>PS</strong>：在JAVA里，“=”不能被看成是一个赋值语句，它不是在把一个对象赋给另外一个对象，它的执行过程实质上是将右边对象的地址传给了左边的引用，使得左边的引用指向了右边的对象。JAVA表面上看起来没有指针，但它的引用其实质就是一个指针，引用里面存放的并不是对象，而是该对象的地址，使得该引用指向了对象。在JAVA里，“=”语句不应该被翻译成赋值语句，因为它所执行的确实不是一个赋值的过程，而是一个传地址的过程，被译成赋值语句会造成很多误解，译得不准确。 </p>
]]></content>
    <summary type="html">
    <![CDATA[When you're passing primitives into a method，you get a distinct copy of the primitive. When you're passing a reference into a method, you get a copy of the reference.]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA基本类型和包装类]]></title>
    <link href="http://alexyyek.github.io/2014/12/29/wrapperClass/"/>
    <id>http://alexyyek.github.io/2014/12/29/wrapperClass/</id>
    <published>2014-12-29T09:03:38.000Z</published>
    <updated>2014-12-29T14:20:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="JAVA的包装类">JAVA的包装类</h2>
<p>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)，有些地方也翻译为外覆类或数据类型类，如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">基本类型</th>
<th style="text-align:center">大小</th>
<th style="text-align:center">包装器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">/</td>
<td style="text-align:center">Boolean</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">16bit</td>
<td style="text-align:center">Character</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">8bit</td>
<td style="text-align:center">Byte</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">16bit</td>
<td style="text-align:center">Short</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">32bit</td>
<td style="text-align:center">Integer</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">64bit</td>
<td style="text-align:center">Long</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">32bit</td>
<td style="text-align:center">Float</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">64bit</td>
<td style="text-align:center">Double</td>
</tr>
<tr>
<td style="text-align:center">void</td>
<td style="text-align:center">/</td>
<td style="text-align:center">Void</td>
</tr>
</tbody>
</table>
<p>Java中的包装器类有两个主要的目的： </p>
<ol>
<li>提供一种机制，将基本值“包装”到对象中，从而使基本值能够包含在为对象而保留的操作中，比如添加到Collections 中，或者从带对象返回值的方法中返回。注意，java5增加了自动装箱和拆箱，程序员过去需手工执行的许多包装操作，现在可以由java自动处理了。 </li>
<li>为基本值提供分类功能。这些功能大多数于各种转换有关：在基本值和String对象间相互转换，在基本值和String对象之间按不同基数转换，如二进制、八进制和十六进制。 </li>
</ol>
<h3 id="包装类共同的方法">包装类共同的方法</h3>
<ul>
<li>带有<code>基本值参数</code>并创建包装类对象的构造函数。如利用Integer包装类创建对象，Integer obj=new Integer(145);</li>
<li>带有<code>字符串参数</code>并创建包装类对象的构造函数.如：new Integer(“-45.36”);</li>
<li>可生成对象基本值的<code>typeValue</code>方法，如：obj.intValue();</li>
<li>将字符串转换为基本值的<code>parseType</code>方法，如：Integer.parseInt(args[0]);</li>
<li>生成哈稀表代码的<code>hashCode</code>方法，如：obj.hasCode();</li>
<li>对同一个类的两个对象进行比较的<code>equals()</code>方法，如：obj1.eauqls(obj2);</li>
<li>生成字符串表示法的<code>toString()</code>方法，如：obj.toString().<br><br></li>
</ul>
<hr>
<h3 id="装箱和拆箱">装箱和拆箱</h3>
<p>自动装箱和拆箱问题是Java中一个老生常谈的问题了，今天就来一些看一下装箱和拆箱中的若干问题。本文先讲述装箱和拆箱最基本的东西，再来看一下面试笔试中经常遇到的与装箱、拆箱相关的问题。<br><br></p>
<h4 id="定义">定义</h4>
<p>在前面的文章中提到，Java为每种基本数据类型都提供了对应的包装器类型，至于为什么会为每种基本数据类型提供包装器类型在此不进行阐述，有兴趣的朋友可以查阅相关资料。在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">100</span>);</div></pre></td></tr></table></figure>

<p>而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</div></pre></td></tr></table></figure>

<p>这个过程中会自动根据数值创建对应的 Integer对象，这就是装箱。<br>那什么是拆箱呢？顾名思义，跟装箱对应，就是自动将包装器类型转换为基本数据类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer i = <span class="number">10</span>; <span class="comment">//装箱</span></div><div class="line"><span class="keyword">int</span> index = i;  <span class="comment">//拆箱</span></div></pre></td></tr></table></figure>

<p>简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</p>
<p>注意：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Integer test = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">int</span> f = test.intValue();</div></pre></td></tr></table></figure>

<p>上面的代码编写时不会报错，但编译是通不过的。<br><br></p>
<h4 id="实现机制">实现机制</h4>
<p>我们就以Interger类为例，下面看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">    Integer i = <span class="number">10</span>; <span class="comment">//装箱</span></div><div class="line">    <span class="keyword">int</span> index = i;  <span class="comment">//拆箱</span></div><div class="line">}</div></pre></td></tr></table></figure>

<p>反编译class文件之后得到如下内容：</p>
<p><center> <img src="http://alexyoung.qiniudn.com/101641567956500.jpg" alt=""> <center></center></center></p>
<p>从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是Integer的<code>valueOf(int)</code>方法。而在拆箱的时候自动调用的是Integer的<code>intValue</code>方法。</p>
<p>其他的也类似，比如Double、Character，不相信的朋友可以自己手动尝试一下。</p>
<p>因此可以用一句话总结装箱和拆箱的实现过程：</p>
<p><strong>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的xxxValue方法实现的。（xxx代表对应的基本数据类型）。</strong></p>
<p><br></p>
<hr>
<p><br></p>
<h4 id="面试问题">面试问题</h4>
<p>虽然大多数人对装箱和拆箱的概念都清楚，但是在面试和笔试中遇到了与装箱和拆箱的问题却不一定会答得上来。下面列举一些常见的与装箱/拆箱有关的面试题，建议先自己尝试编译看源码做做。</p>
<ul>
<li>下面这段代码的输出结果是什么？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Integer i1 = <span class="number">100</span>;</div><div class="line">        Integer i2 = <span class="number">100</span>;</div><div class="line">        Integer i3 = <span class="number">200</span>;</div><div class="line">        Integer i4 = <span class="number">200</span>;</div><div class="line">        </div><div class="line">        System.out.println(i1==i2);</div><div class="line">        System.out.println(i3==i4);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>也许有些朋友会说都会输出false，或者也有朋友会说都会输出true。这里注意“==”和“equal”的区别：<br><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">基本类型</th>
<th style="text-align:center">==</th>
<th style="text-align:center">equals</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">字符串变量</td>
<td style="text-align:center">对象在内存中的首地址</td>
<td style="text-align:center">字符串内容</td>
</tr>
<tr>
<td style="text-align:center">非字符串变量</td>
<td style="text-align:center">对象在内存中的首地址</td>
<td style="text-align:center">对象在内存中的首地址</td>
</tr>
<tr>
<td style="text-align:center">基本类型</td>
<td style="text-align:center">值</td>
<td style="text-align:center">不可用</td>
</tr>
<tr>
<td style="text-align:center">包装类</td>
<td style="text-align:center">地址</td>
<td style="text-align:center">内容</td>
</tr>
</tbody>
</table>
<p>结果：<br>true<br>false</p>
<p>为什么会出现这样的结果？输出结果表明 i1 和 i2 指向的是同一个对象，而 i3 和 i4 指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的<code>valueOf</code>方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span>(<span class="keyword">int</span> i) {</div><div class="line">        <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> && i &lt;= IntegerCache.high)</div><div class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在 [-128,127] 之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。</p>
<p>上面的代码中 i1 和 i2 的数值为100，因此会直接从cache中取已经存在的对象，所以 i1 和 i2 指向的是同一个对象，而 i3 和 i4 则是分别指向不同的对象。</p>
<ul>
<li>下面这段代码的输出结果是什么？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Double i1 = <span class="number">100.0</span>;</div><div class="line">        Double i2 = <span class="number">100.0</span>;</div><div class="line">        Double i3 = <span class="number">200.0</span>;</div><div class="line">        Double i4 = <span class="number">200.0</span>;</div><div class="line">        </div><div class="line">        System.out.println(i1==i2);</div><div class="line">        System.out.println(i3==i4);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>也许有的朋友会认为跟上面一道题目的输出结果相同，但是事实上却不是。实际输出结果为：<br>false<br>false<br>至于具体为什么，读者可以去查看Double类的<code>valueOf</code>的实现。</p>
<p>在这里只解释一下为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p>
<p>注意，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的，Double、Float的valueOf方法的实现是类似的。</p>
<ul>
<li>下面这段代码的输出结果是什么？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Boolean i1 = <span class="keyword">false</span>;</div><div class="line">        Boolean i2 = <span class="keyword">false</span>;</div><div class="line">        Boolean i3 = <span class="keyword">true</span>;</div><div class="line">        Boolean i4 = <span class="keyword">true</span>;</div><div class="line">         </div><div class="line">        System.out.println(i1==i2);</div><div class="line">        System.out.println(i3==i4);</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>输出结果为：<br>true<br>true<br>至于为什么是这个结果，同样地，看了Boolean类的源码也会一目了然。下面是Boolean的valueOf方法的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span>(<span class="keyword">boolean</span> b) {</div><div class="line">        <span class="keyword">return</span> (b ? TRUE : FALSE);</div><div class="line">    }</div></pre></td></tr></table></figure>

<p>至于TRUE和FALSE的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line">     * The {@code Boolean} object corresponding to the primitive</div><div class="line">     * value {@code true}.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean TRUE = <span class="keyword">new</span> Boolean(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    <span class="javadoc">/**</span></div><div class="line">     * The {@code Boolean} object corresponding to the primitive</div><div class="line">     * value {@code false}.</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Boolean FALSE = <span class="keyword">new</span> Boolean(<span class="keyword">false</span>);</div></pre></td></tr></table></figure>

<ul>
<li>谈谈Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。<br>当然，这个题目属于比较宽泛类型的。但是要点一定要答上，我总结一下主要有以下这两点区别：</li>
</ul>
<p>1）第一种方式不会触发自动装箱的过程；而第二种方式会触发；</p>
<p>2）在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。</p>
<ul>
<li>下面这段代码的输出结果是什么？</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {</div><div class="line">        Integer a = <span class="number">1</span>;</div><div class="line">        Integer b = <span class="number">2</span>;</div><div class="line">        Integer c = <span class="number">3</span>;</div><div class="line">        Integer d = <span class="number">3</span>;</div><div class="line">        Integer e = <span class="number">321</span>;</div><div class="line">        Integer f = <span class="number">321</span>;</div><div class="line">        Long g = <span class="number">3</span>L;</div><div class="line">        Long h = <span class="number">2</span>L;</div><div class="line">         </div><div class="line">        System.out.println(c==d);</div><div class="line">        System.out.println(e==f);</div><div class="line">        System.out.println(c==(a+b));</div><div class="line">        System.out.println(c.equals(a+b));</div><div class="line">        System.out.println(g==(a+b));</div><div class="line">        System.out.println(g.equals(a+b));</div><div class="line">        System.out.println(g.equals(a+h));</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p>先别看输出结果，读者自己想一下这段代码的输出结果是什么。这里面需要注意的是：当 “==” 运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals方法并不会进行类型转换。明白了这2点之后，上面的输出结果便一目了然：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">false</span></div><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">true</span></div><div class="line"><span class="keyword">false</span></div><div class="line"><span class="keyword">true</span></div></pre></td></tr></table></figure>

<p>第一个和第二个输出结果没有什么疑问。第三句由于  a+b 包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等。而对于c.equals(a+b)会先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较。同理对于后面的也是这样，不过要注意倒数第二个和最后一个输出的结果（如果数值是int类型的，装箱过程调用的是Integer.valueOf；如果是long类型的，装箱调用的Long.valueOf方法）。</p>
]]></content>
    <summary type="html">
    <![CDATA[Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，统称为包装类(Wrapper Class).]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[教育网配置IPV6回避收费及轻松翻墙]]></title>
    <link href="http://alexyyek.github.io/2014/12/27/ipv6/"/>
    <id>http://alexyyek.github.io/2014/12/27/ipv6/</id>
    <published>2014-12-27T09:06:18.000Z</published>
    <updated>2014-12-30T02:20:08.000Z</updated>
    <content type="html"><![CDATA[<p>明光村职业技术学院终于还是没能逃离收费的命运，虽然还有半年就卷铺盖跑路了，但面对每个月只给10G外网流量，100块都不给我的抠门政策，废话不多说，直接上干货。</p>
<h2 id="目录">目录</h2>
<h3 id="设置IPV6">设置IPV6</h3>
<ul>
<li>首先安装ipv6，这个是基础，win7默认安装，xp运行命令<code>ipv6 install</code>。访问网站 <a href="http://6rank.edu.cn/" target="_blank" rel="external">http://6rank.edu.cn</a> 看看IPv6配置是否正常。更详细介绍请自行百度。</li>
<li>打开网络和共享中心 → 更改适配器设置 → 本地连接 → 属性 → 双击Internet协议版本6（IPV6），设置首选DNS服务器为：<strong>2001:778::37</strong></li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/QQ图片20141227164226.jpg" alt=""> <center></center></center></p>
<p><a href="http://ipv6.lt/nat64_en.php" target="_blank" rel="external"><strong>原理</strong></a>：NAT64服务器，能将所有ipv4的网站都转化对应的ipv6地址，也相当于一种代理。晚上速度比较受影响，日间科研完全可以满足。</p>
<p><center> <img src="http://alexyoung.qiniudn.com/graph_relay.png" alt=""> <center></center></center></p>
<ul>
<li>将Internet协议版本4（IPV4）前的对勾去掉，确定后退出，即可只通过IPV6访问网站，不用登陆 <a href="http://10.3.8.211/" target="_blank" rel="external">http://10.3.8.211/</a>，此时流量不计入已使用流量</li>
</ul>
<h3 id="设置hosts翻墙">设置hosts翻墙</h3>
<p>如果你是通过代理访问 <a href="https://www.youtube.com/" target="_blank" rel="external">youtube</a>，往往速度很不给力。如果是教育网有ipv6的话，那就好办了，看1080P流畅的一比，而且是教育网使用ipv6是不计费的。方法很简单，就是修改hosts.</p>
<ul>
<li><p>访问 <a href="http://serve.netsh.org/pub/ipv6-hosts/" target="_blank" rel="external"><strong>网站</strong></a>，勾选你所要的服务，如下图，点击立刻获取。<br><center> <img src="http://alexyoung.qiniudn.com/QQ图片20141227165359.jpg" alt=""> <center></center></center></p>
</li>
<li><p>将生成的hosts文件内容贴到你的hosts文件里并保存：<code>C:\Windows\System32\drivers\etc</code></p>
</li>
<li>最后总是以<strong>HTTPS</strong>的方式打开Youtube、facebook，如：<a href="https://www.youtube.com/" target="_blank" rel="external">https://www.youtube.com/</a>，<a href="https://www.facebook.com/" target="_blank" rel="external">https://www.facebook.com/</a><br>如果嫌麻烦，可以 <a href="http://blog.netsh.org/posts/chrome-http-redirect-https_369.netsh.html" target="_blank" rel="external"><strong>点这里</strong></a> 设置chrome强制http定向到https</li>
</ul>
<p>PS.如果某天发生访问不了例如youtube的情况，是因为ipv6地址会经常失效，也可能是地址变更，或者河蟹出现，记得更新hosts。<br>访问youtube看1080P无压力</p>
<p><img src="http://alexyoung.qiniudn.com/QQ图片20141227161806.jpg" alt=""></p>
<p><a href="https://code.google.com/p/ipv6-hosts/" target="_blank" rel="external">https://code.google.com/p/ipv6-hosts/</a></p>
<p><strong>PS</strong>：本方法只是临时解决方案，目的是培养大家合理利用搜索引擎，解决实际问题的意识，欢迎大家提出不同的改进意见和更完善的解决方案。</p>
]]></content>
    <summary type="html">
    <![CDATA[IPV6谁用谁知道]]>
    
    </summary>
    
      <category term="skill" scheme="http://alexyyek.github.io/tags/skill/"/>
    
      <category term="黑科技" scheme="http://alexyyek.github.io/categories/%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[红黑树]]></title>
    <link href="http://alexyyek.github.io/2014/12/23/RBTree/"/>
    <id>http://alexyyek.github.io/2014/12/23/RBTree/</id>
    <published>2014-12-23T08:13:09.000Z</published>
    <updated>2014-12-25T08:13:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="红黑树">红黑树</h2>
<p>红黑树(Red-Black Tree，简称R-B Tree)，它一种特殊的二叉查找树。<br>红黑树是特殊的二叉查找树，意味着它满足二叉查找树的特征：任意一个节点所包含的键值，大于等于左孩子的键值，小于等于右孩子的键值。<br>除了具备该特性之外，红黑树还包括许多额外的信息。</p>
<h3 id="性质">性质</h3>
<p>红黑树的每个节点上都有存储位表示节点的颜色，颜色是红(Red)或黑(Black)。<br>红黑树的特性:</p>
<ol>
<li>每个节点或者是黑色，或者是红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ol>
<p>关于它的特性，需要注意的是：<br>第一，特性(3)中的叶子节点，是只为空(NIL或null)的节点。<br>第二，特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。</p>
<p>红黑树结构图类似：</p>
<p><center> <img src="http://alexyoung.qiniudn.com/8394323_13013004048ddW.jpg" alt=""> <center><br><br></center></center></p>
<hr>
<h3 id="基本操作">基本操作</h3>
<p>从某个结点x出发（不包括该结点）到达一个叶节点的任意一条路径上，黑色结点的个数成为该结点x的黑高度，用<code>bh(x)</code>表示。根据性质5黑高度概念是明确定义的，红黑树的黑高度定义为其根节点的黑高度。</p>
<p><strong>性质</strong>：一颗有n个内结点的红黑树的高度至多为<code>2lg(n+1)</code>，红黑树的插入和删除操作都可以在<code>O(lgn)</code>时间内完成。<br><br></p>
<h4 id="旋转">旋转</h4>
<p>红黑树的旋转分为左旋和右旋，因为在插入和删除基本操作中可能改变树的结构，从而破坏红黑树的基本性质，所以需要一定的旋转操作。</p>
<p><center> <img src="http://alexyoung.qiniudn.com/251733282013849.jpg" alt=""> <center></center></center></p>
<p>从图上可以看到，左旋操作中将Y节点顶替其父节点X，之前的父节点X成为Y的左子树，Y的右子树不动，Y的左子树移到X的右子树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span>(Node&lt;T&gt; x){</div><div class="line">		<span class="comment">//consider the left child of y</span></div><div class="line">		Node&lt;T&gt; y = x.right;</div><div class="line">		x.right = y.left;</div><div class="line">		<span class="keyword">if</span> (y.left != <span class="keyword">null</span>) {</div><div class="line">			y.left.parent = x;</div><div class="line">		}</div><div class="line">		<span class="comment">//consider the node y</span></div><div class="line">		y.parent = x.parent;</div><div class="line">		<span class="keyword">if</span> (x.parent == <span class="keyword">null</span>) {</div><div class="line">			root = y;</div><div class="line">		}<span class="keyword">else</span>{</div><div class="line">			<span class="keyword">if</span>(x == x.parent.left)</div><div class="line">			x.parent.left = y;</div><div class="line">			<span class="keyword">else</span> </div><div class="line">			x.parent.right = y;</div><div class="line">		}</div><div class="line">		<span class="comment">//consider the Node x</span></div><div class="line">		y.left = x;</div><div class="line">		x.parent = y;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>右旋同理，是左旋的逆操作：</p>
<p><center> <img src="http://alexyoung.qiniudn.com/251735527958942.jpg" alt=""> <center></center></center></p>
<p><br></p>
<hr>
<p><br></p>
<h4 id="插入">插入</h4>
<p>将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当作一颗二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过”旋转和重新着色”等一系列操作来修正该树，使之重新成为一颗红黑树。详细描述如下：<br><strong>第一步</strong>： 将红黑树当作一颗二叉查找树，将节点插入。<br>红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然是一颗二叉查找树。也就意味着，树的键值仍然是有序的。此外，无论是左旋还是右旋，若旋转之前这棵树是二叉查找树，旋转之后它一定还是二叉查找树。这也就意味着，任何的旋转和重新着色操作，都不会改变它仍然是一颗二叉查找树的事实。</p>
<p><strong>第二步</strong>：将插入的节点着色为”红色”。<br>为什么着色成红色，而不是黑色呢？为什么呢？在回答之前，我们需要重新温习一下红黑树的特性：<br>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 注意：这里叶子节点，是指为空的叶子节点！<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p>
<p>将插入的节点着色为红色，不会违背”特性(5)”！少违背一条特性，就意味着我们需要处理的情况越少。接下来，就要努力的让这棵树满足其它性质即可；满足了的话，它就又是一颗红黑树了。</p>
<p><strong>第三步</strong>：通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。<br>    第二步中，将插入节点着色为”红色”之后，不会违背”特性(5)”。那它到底会违背哪些特性呢？<br>    对于”特性(1)”，显然不会违背了。因为我们已经将它涂成红色了。<br>    对于”特性(2)”，唯一可能违背的情况是插入的节点为根节点。<br>    对于”特性(3)”，显然不会违背了。这里的叶子节点是指的空叶子节点，插入非空节点并不会对它们造成影响。<br>    对于”特性(4)”，如果插入节点的父节点是红色的，就有可能违背！<br>    那接下来，想办法使之”满足特性”，就可以将树重新构造成红黑树了。</p>
<p>插入操作代码见最后的完整代码，下面主要研究插入后的修正操作：</p>
<ul>
<li>修复情况1：当前结点的父结点是红色，祖父结点的另一个子结点（叔叔结点）是红色。</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_insert_case_3.png" alt=""> <center></center></center></p>
<p>父节点和叔叔节点都是RED，则祖父节点肯定存在，且为BLACK，改变祖父节点、父节点和叔叔节点的颜色，将N上移到祖父节点继续迭代。</p>
<ul>
<li>修复情况2：当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的右孩子</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_insert_case_4.png" alt=""> <center></center></center></p>
<p>此时当前节点的父节点做为新的当前节点，以新当前节点为支点左旋。</p>
<ul>
<li>插入修复情况3：当前节点的父节点是红色,叔叔节点是黑色，当前节点是其父节点的左孩子</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_insert_case_5.png" alt=""> <center></center></center></p>
<p>情况2通过一个左旋转变成情况三，因为节点N和父节点P都是红色的，所以旋转不影响数的黑高度。情况三中改变一些节点颜色，然后通过一个右旋解决。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertFixUp</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="comment">//	若父节点存在，并且父节点的颜色是红色</span></div><div class="line">		<span class="keyword">while</span>(node.parent != <span class="keyword">null</span> && isRed(node.parent)) {</div><div class="line">			<span class="comment">// 若父节点”是“祖父节点的左孩子</span></div><div class="line">			<span class="keyword">if</span> (parentOf(node) == parentOf(parentOf(node)).left) {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(parentOf(node)).right;	 <span class="comment">//叔叔节点，即父节点的兄弟节点</span></div><div class="line">				<span class="comment">//情况一：如果叔叔节点是红色，因为父节点是红色，显然祖父节点是黑色</span></div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {									</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					node = parentOf(parentOf(node));</div><div class="line">				}</div><div class="line">				<span class="keyword">else</span> {	</div><div class="line">					<span class="keyword">if</span> (parentOf(node).right == node) {	<span class="comment">//情况二：叔叔节点是黑色，而Z是右孩子</span></div><div class="line">						 node = parentOf(node);</div><div class="line">						 leftRotate(node);</div><div class="line">					}</div><div class="line">					</div><div class="line">					parentOf(node).color = BLACK;	<span class="comment">//情况三：叔叔节点黑色，Z是左孩子</span></div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					rightRotate(parentOf(parentOf(node)));</div><div class="line">				}</div><div class="line">			}</div><div class="line">			<span class="comment">// 若父节点”是“祖父节点的右孩子</span></div><div class="line">			<span class="keyword">else</span> {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(parentOf(node)).left;</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					node = parentOf(parentOf(node));</div><div class="line">				}</div><div class="line">				<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">if</span> (parentOf(node).left == node) {</div><div class="line">						 node = parentOf(node);</div><div class="line">						 rightRotate(node);</div><div class="line">					}</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					leftRotate(parentOf(parentOf(node)));</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="comment">/* 1.防止插入节点为根节点        </span></div><div class="line">		 * 2.防止树深度较低时grandparent为root节点,从而在情况一uncle为red时，把root节点置为red 	 */</div><div class="line">		<span class="keyword">if</span> (node == root) {</div><div class="line">			node.color = BLACK;</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<p><br></p>
<h4 id="删除">删除</h4>
<p>将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。详细描述如下：<br><strong>第一步</strong>：将红黑树当作一颗二叉查找树，将节点删除。<br>这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：</p>
<ol>
<li>被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。</li>
<li>被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</li>
<li>被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了,从而转换成为情况1或情况2</li>
</ol>
<p><strong>第二步</strong>：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。<br>因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。</p>
<p>删除操作代码见最后的完整代码，下面主要研究插入后的修正操作：<br>当删除节点是红色的，红黑性质仍然得以保存，故考虑删除节点是黑色的情况。</p>
<ul>
<li>修复情况1：兄弟节点为红色(此时父节点和兄弟节点的子节点分为黑)。</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_delete_case_2.png" alt=""> <center></center></center></p>
<p>因为兄弟节点必有黑孩子，可以改变兄弟节点S和父节点P的颜色，在对P做一次左旋，从而转换为情形2-4，图中转换为情况2</p>
<ul>
<li>修复情况2：兄弟是黑色且兄弟节点的两个子节点全为黑色。</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_delete_case_4.png" alt=""> <center></center></center></p>
<p>因为S节点和S的两个子节点都是黑色，故需要从S支数去除一层黑色，来平衡黑高度，故将S的颜色改为RED，并将N直到P上，继续迭代。</p>
<ul>
<li>修复情况3：兄弟节点是黑色，兄弟的左子是红色，右子是黑色。</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_delete_case_5.png" alt=""> <center></center></center></p>
<p>交换兄弟节点S与其左孩子的颜色，然后对S进行右旋，现在N的新兄弟S是一个有红色右孩子的黑节点，进入情况4</p>
<ul>
<li>修复情况4：当前节点颜色是黑-黑色，它的兄弟节点是黑色，但是兄弟节点的右子是红色，兄弟节点左子的颜色任意。</li>
</ul>
<p><center> <img src="http://alexyoung.qiniudn.com/Red-black_tree_delete_case_6.png" alt=""> <center></center></center></p>
<p>修改某些节点颜色，并对P做一次左旋，将N置为根，循环结束。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeFixUp</span>(Node&lt;T&gt; node){</div><div class="line">	</div><div class="line">		<span class="keyword">while</span> (node != <span class="keyword">this</span>.root && node.color == BLACK) {</div><div class="line">			<span class="comment">// 若节点是父节点的左孩子</span></div><div class="line">			<span class="keyword">if</span> (node == parentOf(node).left) {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(node).right;		</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {		<span class="comment">//情况一：叔叔节点为红色</span></div><div class="line">					parentOf(node).color = RED;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					leftRotate(parentOf(node));</div><div class="line">					uncle = parentOf(node).right;</div><div class="line">				}</div><div class="line">				<span class="comment">//情况二：叔叔节点为黑色，且有两个黑孩子</span></div><div class="line">				<span class="keyword">if</span> (isBlack(uncle.left) && isBlack(uncle.right)) {</div><div class="line">					uncle.color = RED;</div><div class="line">					node = parentOf(node);</div><div class="line">				}<span class="keyword">else</span> {										</div><div class="line">					<span class="keyword">if</span> (isBlack(uncle.right)) {		<span class="comment">//情况三：叔叔节点的左孩子为红色，右孩子为黑色</span></div><div class="line">						uncle.left.color = BLACK;</div><div class="line">						uncle.color = RED;</div><div class="line">						rightRotate(uncle);</div><div class="line">						uncle = parentOf(node).right;</div><div class="line">					}</div><div class="line">					uncle.color = parentOf(node).color;		<span class="comment">//情况四：叔叔节点的右孩子为红色</span></div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.right.color = BLACK;</div><div class="line">					leftRotate(parentOf(node));</div><div class="line">					node = root;</div><div class="line">				}</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(node).left;</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {</div><div class="line">					parentOf(node).color = RED;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					rightRotate(parentOf(node));</div><div class="line">					uncle = parentOf(node).left;</div><div class="line">				}</div><div class="line">				<span class="keyword">if</span> (isBlack(uncle.left) && isBlack(uncle.right)) {</div><div class="line">					uncle.color = RED;</div><div class="line">					node = parentOf(node);</div><div class="line">				}<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">if</span> (isBlack(uncle.left)) {</div><div class="line">						uncle.right.color = BLACK;</div><div class="line">						uncle.color = RED;</div><div class="line">						leftRotate(uncle);</div><div class="line">						uncle = parentOf(node).left;</div><div class="line">					}</div><div class="line">					uncle.color = parentOf(node).color;</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.left.color = BLACK;</div><div class="line">					rightRotate(parentOf(node));</div><div class="line">					node = root;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		node.color = BLACK;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<p><br></p>
<h3 id="动态顺序统计">动态顺序统计</h3>
<p>在之前的<a href="http://alexyyek.github.io/2014/12/08/select/" target="_blank" rel="external"><strong>顺序统计学</strong></a>问题中，我们尝试在<code>O(n)</code>的时间内找到无序集合中第i小的数。这里将介绍如何修改红黑树的结构，使得任意的顺序统计量都可以在<code>O(lgn)</code>时间内确定。</p>
<p>一颗<strong>顺序统计量数</strong>通过在红黑树的每个节点中存入附加信息而成，即除了节点的key值，还包含了域<code>size</code>，如下图size的规则为：</p>
<p><center> $size[x]=size[left[x]]+size[right[x]]+1$ <center></center></center></p>
<p><center> <img src="http://alexyoung.qiniudn.com/01212325-22d4dc3f9b39450e9e5254db69372047.png" alt=""><center></center></center></p>
<p><strong>如何扩张数据结构：</strong></p>
<ul>
<li>选择基础的数据结构</li>
<li>确定要在基础数据结构中添加哪些信息（根据需要）</li>
<li>验证可用基础数据结构上的基础修改操作来维护新添加的信息</li>
<li>设计新的操作</li>
</ul>
<p><br></p>
<h4 id="检索给定排序的元素">检索给定排序的元素</h4>
<p>为了找出顺序统计数中第i小的关键字，递归版伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">OS-SELECT(root[T],i)</div><div class="line">r = size[left[x]] + <span class="number">1</span></div><div class="line"><span class="keyword">if</span> r = i</div><div class="line">    then <span class="keyword">return</span> x</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> i &lt; r</div><div class="line">    then <span class="keyword">return</span> OS-SELECT(left[x],i)</div><div class="line"><span class="keyword">else</span> </div><div class="line">    <span class="keyword">return</span> OS-SELECT(right[x], i-r)</div></pre></td></tr></table></figure>

<p><br></p>
<h4 id="确定一个元素的秩">确定一个元素的秩</h4>
<p>过程OS-RANK返回在对树进行中序遍历得到的线性序中x的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">OS-RANK(T,x)</div><div class="line">r = size[left[x]] + <span class="number">1</span></div><div class="line">y = x</div><div class="line"><span class="keyword">while</span> y != root[T]</div><div class="line">    do <span class="keyword">if</span> y = right[p[y]]</div><div class="line">        r = r + size[left[p[y]]] + <span class="number">1</span></div><div class="line">        y = p[y]</div><div class="line"><span class="keyword">return</span> r</div></pre></td></tr></table></figure>

<p><br></p>
<h4 id="对子树规模的维护">对子树规模的维护</h4>
<p>红黑树的插入和删除可能会改变树的结构，为了维护红黑树的结构，需要更新域size的值，左旋在原有代码下增加两行：</p>
<p><center> $size[y] = size[x]$ <center></center></center></p>
<p><center> $size[x] = size[left[x]] + size[right[x]] + 1$ <center></center></center></p>
<p><center> <img src="http://alexyoung.qiniudn.com/101600338568211.png" alt=""> <center></center></center></p>
<p>点击<a href="http://www.cnblogs.com/alan-forever/p/3657086.html" target="_blank" rel="external"><strong>具体讲解</strong></a></p>
<figure class="highlight C"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * x结点上进行左旋转，y结点（x结点的右儿子）的左儿子成为x结点的新右儿子</div><div class="line"> * x结点成为y结点的左儿子的新父结点</div><div class="line"> * x结点的父结点成为y结点的新父结点，y结点成为x结点的新父结点</div><div class="line"> * x结点成为y结点的新左儿子</div><div class="line"> */</div><div class="line"><span class="keyword">void</span> Left_Rotate(RB_Tree *T, RB_TreeNode *x){</div><div class="line">    RB_TreeNode *y = x-&gt;right;       <span class="comment">//x点右儿子          </span></div><div class="line">    x-&gt;right = y-&gt;left;              <span class="comment">//y结点的左儿子会成为x结点的右儿子</span></div><div class="line">    <span class="keyword">if</span>(y-&gt;left != NIL)</div><div class="line">        y-&gt;left-&gt;parent = x;         <span class="comment">//如果y有左儿子,y的左儿子的父结点为x</span></div><div class="line">    y-&gt;parent = x-&gt;parent;</div><div class="line">    <span class="keyword">if</span>(x-&gt;parent == NIL)</div><div class="line">        T-&gt;root = y;                <span class="comment">//如果x的父结点为哨兵，说明x为根结点，则y成为根结点</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)</div><div class="line">        x-&gt;parent-&gt;left = y;        </div><div class="line">    <span class="keyword">else</span></div><div class="line">        x-&gt;parent-&gt;right = y;       <span class="comment">//判断x为其父结点的左、右儿子，y成为x父结点对应的儿子</span></div><div class="line">    y-&gt;left = x;                    <span class="comment">//y的左儿子为x</span></div><div class="line">    x-&gt;parent = y;                  <span class="comment">//x的父结点为y</span></div><div class="line"></div><div class="line">    <span class="comment">/*调整size域*/</span></div><div class="line">    y-&gt;size = x-&gt;size;</div><div class="line">    x-&gt;size = x-&gt;left-&gt;size + x-&gt;right-&gt;size + <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<h3 id="完整代码">完整代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Algorithm;</div><div class="line"></div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * red-black tree</div><div class="line"> *<span class="javadoctag"> @author</span> AlexYoung</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RBTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>{</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; root;</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt;</span>{</div><div class="line">		T key;</div><div class="line">		Node&lt;T&gt; left;</div><div class="line">		Node&lt;T&gt; right;</div><div class="line">		Node&lt;T&gt; parent;</div><div class="line">		<span class="keyword">boolean</span> color;</div><div class="line">		</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> <span class="title">Node</span>(T key, Node&lt;T&gt; left, Node&lt;T&gt; right, Node&lt;T&gt; parent, Boolean color){</div><div class="line">			<span class="keyword">this</span>.key = key;</div><div class="line">			<span class="keyword">this</span>.left = left;</div><div class="line">			<span class="keyword">this</span>.right = right;</div><div class="line">			<span class="keyword">this</span>.parent = parent;</div><div class="line">			<span class="keyword">this</span>.color = color;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> T <span class="title">getKey</span>(){</div><div class="line">			<span class="keyword">return</span> key;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> String <span class="title">toString</span>(){</div><div class="line">			<span class="keyword">return</span> <span class="string">""</span> + key + <span class="string">" "</span> + color;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">RBTree</span>(){</div><div class="line">		root = <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">parentOf</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">return</span> (node != <span class="keyword">null</span>) ? node.parent : <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">colorOf</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">return</span> (node != <span class="keyword">null</span>) ? node.color : BLACK;</div><div class="line">	}</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">return</span> (node != <span class="keyword">null</span>) && (node.color == RED) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</div><div class="line">	}</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlack</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">return</span> !isRed(node);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">miNode</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">while</span> (node.left != <span class="keyword">null</span>) {</div><div class="line">			node = node.left;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> node;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span>(Node&lt;T&gt; tree){</div><div class="line">		<span class="keyword">if</span>(tree != <span class="keyword">null</span>) {</div><div class="line">			inOrder(tree.left);</div><div class="line">			System.out.print(tree.key + <span class="string">"\t"</span>);</div><div class="line">			inOrder(tree.right);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span>(){</div><div class="line">		inOrder(root);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">maxNode</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">while</span> (node.right != <span class="keyword">null</span>) {</div><div class="line">			node = node.right;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> node;</div><div class="line">	}</div><div class="line">	<span class="comment">// 前趋</span></div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">succussor</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">if</span> (node.right != <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> miNode(node.right);</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; parent = node.parent;</div><div class="line">		<span class="keyword">while</span> (parent != <span class="keyword">null</span> && node == parent.right) {</div><div class="line">			node = parent;</div><div class="line">			parent = parent.parent;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> parent;</div><div class="line">	}</div><div class="line">	<span class="comment">// 后继</span></div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">preDecessor</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="keyword">if</span> (node.left != <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> maxNode(node.left);</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; parent = node.parent;</div><div class="line">		<span class="keyword">while</span> (parent != <span class="keyword">null</span> && node == parent.left) {</div><div class="line">			node = parent;</div><div class="line">			parent = parent.parent;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> parent;</div><div class="line">	}</div><div class="line">	<span class="comment">//	左旋</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span>(Node&lt;T&gt; x){</div><div class="line">		<span class="comment">//consider the left child of y</span></div><div class="line">		Node&lt;T&gt; y = x.right;</div><div class="line">		x.right = y.left;</div><div class="line">		<span class="keyword">if</span> (y.left != <span class="keyword">null</span>) {</div><div class="line">			y.left.parent = x;</div><div class="line">		}</div><div class="line">		<span class="comment">//consider the node y</span></div><div class="line">		y.parent = x.parent;</div><div class="line">		<span class="keyword">if</span> (x.parent == <span class="keyword">null</span>) {</div><div class="line">			root = y;</div><div class="line">		}<span class="keyword">else</span>{</div><div class="line">			<span class="keyword">if</span>(x == x.parent.left)</div><div class="line">			x.parent.left = y;</div><div class="line">			<span class="keyword">else</span> </div><div class="line">			x.parent.right = y;</div><div class="line">		}</div><div class="line">		<span class="comment">//consider the Node x</span></div><div class="line">		y.left = x;</div><div class="line">		x.parent = y;</div><div class="line">	}</div><div class="line">	<span class="comment">//	右旋</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span>(Node&lt;T&gt; x){</div><div class="line">		Node&lt;T&gt; y= x.left;</div><div class="line">		x.left = y.right;</div><div class="line">		<span class="keyword">if</span> (y.right != <span class="keyword">null</span>) {</div><div class="line">			y.right.parent = x;</div><div class="line">		}</div><div class="line">		</div><div class="line">		y.parent = x.parent;</div><div class="line">		<span class="keyword">if</span> (x.parent == <span class="keyword">null</span>) {</div><div class="line">			root = y;</div><div class="line">		}<span class="keyword">else</span>{</div><div class="line">			<span class="keyword">if</span> (x == x.parent.left)</div><div class="line">			x.parent.left = y;</div><div class="line">			<span class="keyword">else</span> </div><div class="line">			x.parent.right = y;</div><div class="line">		}</div><div class="line">		</div><div class="line">		y.right = x;</div><div class="line">		x.parent =y;</div><div class="line">	}</div><div class="line">	<span class="comment">//递归查找</span></div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">search</span>(Node&lt;T&gt; tree, T key){</div><div class="line">		<span class="keyword">if</span> (tree == <span class="keyword">null</span> || key == tree.key) {</div><div class="line">			<span class="keyword">return</span> tree;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (key.compareTo(tree.key) &lt;= <span class="number">0</span>) {</div><div class="line">			<span class="keyword">return</span> search(tree.left, key);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> search(tree.right, key);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">//非递归查找</span></div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">searchNode</span>(Node&lt;T&gt; tree, T key){</div><div class="line">		<span class="keyword">while</span> (tree != <span class="keyword">null</span> && tree.key != key) {</div><div class="line">			<span class="keyword">if</span> (key.compareTo(tree.key) &lt;= <span class="number">0</span>) {</div><div class="line">				tree = tree.left;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				tree = tree.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 将结点插入到红黑树中</div><div class="line">	 *<span class="javadoctag"> @param</span> node : 插入的结点</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span>(Node&lt;T&gt; node){</div><div class="line">		Node&lt;T&gt; y = <span class="keyword">null</span>;</div><div class="line">		Node&lt;T&gt; x = <span class="keyword">this</span>.root;</div><div class="line">		<span class="keyword">while</span> (x != <span class="keyword">null</span>) {</div><div class="line">			y = x;</div><div class="line">			<span class="keyword">if</span> (node.key.compareTo(x.key) &lt;= <span class="number">0</span>) {</div><div class="line">				x = x.left;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				x = x.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line"></div><div class="line">		node.parent = y;</div><div class="line">		<span class="keyword">if</span> (y == <span class="keyword">null</span>) {</div><div class="line">			root = node;</div><div class="line">			node.color = BLACK;</div><div class="line">		} <span class="keyword">else</span> {</div><div class="line">			<span class="keyword">if</span> (node.key.compareTo(y.key) &lt;= <span class="number">0</span>) {</div><div class="line">				y.left = node;</div><div class="line">				node.color = RED;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				y.right = node;</div><div class="line">				node.color = RED;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		</div><div class="line">		</div><div class="line">		insertFixUp(node);</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * </div><div class="line">	 *<span class="javadoctag"> @param</span> key : 插入节点的键值</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span>(T key){</div><div class="line">		Node&lt;T&gt; node = <span class="keyword">new</span> Node&lt;T&gt;(key, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, BLACK);</div><div class="line">		<span class="keyword">if</span> (node != <span class="keyword">null</span>) {</div><div class="line">			insert(node);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertFixUp</span>(Node&lt;T&gt; node){</div><div class="line">		<span class="comment">//	若父节点存在，并且父节点的颜色是红色</span></div><div class="line">		<span class="keyword">while</span>(node.parent != <span class="keyword">null</span> && isRed(node.parent)) {</div><div class="line">			<span class="comment">// 若父节点”是“祖父节点的左孩子</span></div><div class="line">			<span class="keyword">if</span> (parentOf(node) == parentOf(parentOf(node)).left) {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(parentOf(node)).right;		<span class="comment">//叔叔节点，即父节点的兄弟节点</span></div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {									<span class="comment">//情况一：如果叔叔节点是红色，因为父节点是红色，显然祖父节点是黑色</span></div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					node = parentOf(parentOf(node));</div><div class="line">				}</div><div class="line">				<span class="keyword">else</span> {	</div><div class="line">					<span class="keyword">if</span> (parentOf(node).right == node) {				<span class="comment">//情况二：叔叔节点是黑色，而Z是右孩子</span></div><div class="line">						 node = parentOf(node);</div><div class="line">						 leftRotate(node);</div><div class="line">					}</div><div class="line">					</div><div class="line">					parentOf(node).color = BLACK;					<span class="comment">//情况三：叔叔节点黑色，Z是左孩子</span></div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					rightRotate(parentOf(parentOf(node)));</div><div class="line">				}</div><div class="line">			}</div><div class="line">			<span class="comment">// 若父节点”是“祖父节点的右孩子</span></div><div class="line">			<span class="keyword">else</span> {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(parentOf(node)).left;</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					node = parentOf(parentOf(node));</div><div class="line">				}</div><div class="line">				<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">if</span> (parentOf(node).left == node) {</div><div class="line">						 node = parentOf(node);</div><div class="line">						 rightRotate(node);</div><div class="line">					}</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					parentOf(parentOf(node)).color = RED;</div><div class="line">					leftRotate(parentOf(parentOf(node)));</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="comment">/* 1.防止插入节点为根节点        </span></div><div class="line">		 * 2.防止树深度较低时grandparent为root节点,从而在情况一uncle为red时，把root节点置为red 	 */</div><div class="line">		<span class="keyword">if</span> (node == root) {</div><div class="line">			node.color = BLACK;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 删除节点</div><div class="line">	 *<span class="javadoctag"> @param</span> node : 待删除节点</div><div class="line">	 *<span class="javadoctag"> @return</span></div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; <span class="title">remove</span>(Node&lt;T&gt; node){</div><div class="line">		Node&lt;T&gt; replace = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span> (node.left == <span class="keyword">null</span> || node.right == <span class="keyword">null</span>) {</div><div class="line">			replace = node;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			replace = succussor(node);</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; child = replace.left != <span class="keyword">null</span> ? replace.left : replace.right; </div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (child == <span class="keyword">null</span>) {</div><div class="line">			child = <span class="keyword">new</span> Node&lt;T&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, replace.parent, BLACK);</div><div class="line">		}</div><div class="line">		child.parent = replace.parent;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (replace.parent == <span class="keyword">null</span>) {</div><div class="line">			root = child;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">if</span>(replace == replace.parent.left)</div><div class="line">				replace.parent.left = child;</div><div class="line">			<span class="keyword">else</span></div><div class="line">				replace.parent.right = child;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (replace != node) {</div><div class="line">			node.key = replace.key;</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (isBlack(replace)) {</div><div class="line">			removeFixUp(child);</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> replace;</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 删除某一数值</div><div class="line">	 *<span class="javadoctag"> @param</span> key : 待删除值</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(T key){</div><div class="line">		Node&lt;T&gt; node = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span> ((node = searchNode(root, key)) != <span class="keyword">null</span>) {</div><div class="line">			remove(node);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeFixUp</span>(Node&lt;T&gt; node){</div><div class="line">	</div><div class="line">		<span class="keyword">while</span> (node != <span class="keyword">this</span>.root && node.color == BLACK) {</div><div class="line">			<span class="comment">// 若节点是父节点的左孩子</span></div><div class="line">			<span class="keyword">if</span> (node == parentOf(node).left) {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(node).right;		</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {							<span class="comment">//情况一：叔叔节点为红色</span></div><div class="line">					parentOf(node).color = RED;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					leftRotate(parentOf(node));</div><div class="line">					uncle = parentOf(node).right;</div><div class="line">				}</div><div class="line">				<span class="comment">//情况二：叔叔节点为黑色，且有两个黑孩子</span></div><div class="line">				<span class="keyword">if</span> (isBlack(uncle.left) && isBlack(uncle.right)) {</div><div class="line">					uncle.color = RED;</div><div class="line">					node = parentOf(node);</div><div class="line">				}<span class="keyword">else</span> {										</div><div class="line">					<span class="keyword">if</span> (isBlack(uncle.right)) {				<span class="comment">//情况三：叔叔节点的左孩子为红色，右孩子为黑色</span></div><div class="line">						uncle.left.color = BLACK;</div><div class="line">						uncle.color = RED;</div><div class="line">						rightRotate(uncle);</div><div class="line">						uncle = parentOf(node).right;</div><div class="line">					}</div><div class="line">					uncle.color = parentOf(node).color;		<span class="comment">//情况四：叔叔节点的右孩子为红色</span></div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.right.color = BLACK;</div><div class="line">					leftRotate(parentOf(node));</div><div class="line">					node = root;</div><div class="line">				}</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				Node&lt;T&gt; uncle = parentOf(node).left;</div><div class="line">				<span class="keyword">if</span> (isRed(uncle)) {</div><div class="line">					parentOf(node).color = RED;</div><div class="line">					uncle.color = BLACK;</div><div class="line">					rightRotate(parentOf(node));</div><div class="line">					uncle = parentOf(node).left;</div><div class="line">				}</div><div class="line">				<span class="keyword">if</span> (isBlack(uncle.left) && isBlack(uncle.right)) {</div><div class="line">					uncle.color = RED;</div><div class="line">					node = parentOf(node);</div><div class="line">				}<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">if</span> (isBlack(uncle.left)) {</div><div class="line">						uncle.right.color = BLACK;</div><div class="line">						uncle.color = RED;</div><div class="line">						leftRotate(uncle);</div><div class="line">						uncle = parentOf(node).left;</div><div class="line">					}</div><div class="line">					uncle.color = parentOf(node).color;</div><div class="line">					parentOf(node).color = BLACK;</div><div class="line">					uncle.left.color = BLACK;</div><div class="line">					rightRotate(parentOf(node));</div><div class="line">					node = root;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		node.color = BLACK;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		<span class="keyword">int</span>[] arr = {<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">90</span>, <span class="number">70</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">80</span>};</div><div class="line">		RBTree&lt;Integer&gt; tree = <span class="keyword">new</span> RBTree&lt;Integer&gt;();</div><div class="line">		</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i : arr){</div><div class="line">			tree.insert(i);</div><div class="line">		}</div><div class="line">		tree.inOrder();</div><div class="line">		tree.remove(<span class="number">20</span>);</div><div class="line">		System.out.println();</div><div class="line">		tree.inOrder();</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[一颗高度为H的二叉树可以实现任何一种基本的动态集合操作，时间都为O(h)，当数的高度较低时，这种操作较快，但是当树的高度较高时，红黑树由于其平衡树的特点，保证了基本动态操作时间为O(lgn)。]]>
    
    </summary>
    
      <category term="Tree" scheme="http://alexyyek.github.io/tags/Tree/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉查找树]]></title>
    <link href="http://alexyyek.github.io/2014/12/17/BinaryTree/"/>
    <id>http://alexyyek.github.io/2014/12/17/BinaryTree/</id>
    <published>2014-12-17T09:39:28.000Z</published>
    <updated>2014-12-17T13:21:29.000Z</updated>
    <content type="html"><![CDATA[<h2 id="二叉查找树">二叉查找树</h2>
<p>一颗二叉查找树是按二叉树的结构来组织的，树中每个结点都是一个对象，节点中除了<code>key</code>域外，还包含域<code>left</code>，<code>right</code>以及<code>parent</code>，分别指向当前节点的左子节点、右子节点和父节点。</p>
<p><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/QQ图片20141217175217.png" alt=""> <center></center></center></p>
<p>在二叉查找树中：</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树。</li>
<li>没有键值相等的节点（待定）</li>
</ol>
<h3 id="遍历操作">遍历操作</h3>
<p>根据二叉查找树的性质，可以由递归算法按排列顺序输出树中的所有关键字。</p>
<p><strong>中序遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span>(Node root){</div><div class="line">		<span class="keyword">if</span> (root != <span class="keyword">null</span>) {</div><div class="line">			inOrder(root.left);</div><div class="line">			System.out.print(root.value +<span class="string">"\t"</span>);</div><div class="line">			inOrder(root.right);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>前序遍历和后续遍历形式基本一致，前序先输出root节点，后续最后输出root节点。</p>
<h3 id="查找操作">查找操作</h3>
<p>从二叉查找树根节点开始查找，并沿着树下降，对每个碰到的非空节点比较节点值与查找值大小，按情况向左右子树下降，直到找到并返回节点对象。非递归版本普遍较快。</p>
<p><strong>递归版本</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Node <span class="title">search</span>(Node tree, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">if</span> (tree == <span class="keyword">null</span> || value == tree.value) {</div><div class="line">			<span class="keyword">return</span> tree;</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (value &lt;= tree.value) {</div><div class="line">			<span class="keyword">return</span> search(tree.left, value);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> search(tree.right, value);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><strong>非递归版本</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Node <span class="title">searchNode</span>(Node tree, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">while</span> (tree != <span class="keyword">null</span> && tree.value != value) {</div><div class="line">			<span class="keyword">if</span> (value &lt;= tree.value) {</div><div class="line">				tree = tree.left;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				tree = tree.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="插入操作">插入操作</h3>
<p>插入操作与查找操作类似，将待插值与当前节点值比较，小于当前节点值则去左子树继续比较，大于当前节点值去右子树比较，直到下降直空节点，则将待插值赋给空节点并返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Node <span class="title">insertNode</span>(Node tree, <span class="keyword">int</span> x){</div><div class="line">		<span class="keyword">if</span> (tree == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Node(x);</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (x &lt;= tree.value) {</div><div class="line">			tree.left = insertNode(tree.left, x);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			tree.right = insertNode(tree.right, x);</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="删除操作">删除操作</h3>
<p>删除操作根据所删节点的子女数量可能会改变树的结构，主要分为三种情况：</p>
<ol>
<li>无children节点，直接删除<br><img src="http://7rf27k.com1.z0.glb.clouddn.com/20130506115644277.png" alt=""></li>
<li>有一个children节点，将子节点覆盖删除节点<br><img src="http://7rf27k.com1.z0.glb.clouddn.com/20130506115712159.png" alt=""></li>
<li>两个children节点都不为空，寻址其后继节点（右子树中的最小值），用后继节点值替换删除节点值，然后在其右子树中删除后继节点<br><img src="http://7rf27k.com1.z0.glb.clouddn.com/QQ图片20141217174837.jpg" alt=""></li>
</ol>
<h3 id="二叉查找树性能">二叉查找树性能</h3>
<p>对高度为<strong><code>h</code></strong>的二叉查找树，动态集合操作INSERT和DELETE的运行时间为<strong><code>O(h)</code></strong></p>
<h2 id="完整代码">完整代码</h2>
<h3 id="简单版">简单版</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>{</div><div class="line">		Node left;</div><div class="line">		Node right;</div><div class="line">		<span class="keyword">int</span> value;</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> <span class="title">Node</span>(<span class="keyword">int</span> value){</div><div class="line">			<span class="keyword">this</span>.value = value;</div><div class="line">			left = <span class="keyword">null</span>;</div><div class="line">			right = <span class="keyword">null</span>;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">private</span> Node root;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">BinarySearchTree</span>(){</div><div class="line">		root = <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">BinarySearchTree</span>(<span class="keyword">int</span>[] arr){</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i : arr){</div><div class="line">			insert(i);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span>(<span class="keyword">int</span> value){</div><div class="line">		root = insert(root, value);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node <span class="title">insert</span>(Node root, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) {</div><div class="line">			root = <span class="keyword">new</span> Node(value);</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (value &lt;= root.value) {</div><div class="line">			<span class="keyword">if</span> (root.left == <span class="keyword">null</span>) {</div><div class="line">				root.left = <span class="keyword">new</span> Node(value);</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				insert(root.left, value);</div><div class="line">			}</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">if</span> (root.right == <span class="keyword">null</span>) {</div><div class="line">				root.right = <span class="keyword">new</span> Node(value);</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				insert(root.right, value);</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="comment">//中序遍历</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span>(Node tree){</div><div class="line">		<span class="keyword">if</span> (tree != <span class="keyword">null</span>) {</div><div class="line">			inOrder(tree.left);</div><div class="line">			System.out.print(tree.value + <span class="string">"\t"</span>);</div><div class="line">			inOrder(tree.right);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">//前序遍历</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span>(Node tree){</div><div class="line">		<span class="keyword">if</span> (tree != <span class="keyword">null</span>) {</div><div class="line">			System.out.print(tree.value +<span class="string">"\t"</span>);</div><div class="line">			preOrder(tree.left);</div><div class="line">			preOrder(tree.right);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">//后续遍历</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span>(Node tree){</div><div class="line">		<span class="keyword">if</span> (tree != <span class="keyword">null</span>) {</div><div class="line">			postOrder(tree.left);</div><div class="line">			postOrder(tree.right);</div><div class="line">			System.out.print(tree.value +<span class="string">"\t"</span>);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">//递归</span></div><div class="line">	<span class="keyword">public</span> Node <span class="title">search</span>(Node tree, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">if</span> (tree == <span class="keyword">null</span> || value == tree.value) {</div><div class="line">			<span class="keyword">return</span> tree;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (value &lt;= tree.value) {</div><div class="line">			<span class="keyword">return</span> search(tree.left, value);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> search(tree.right, value);</div><div class="line">		}</div><div class="line">		</div><div class="line">	}</div><div class="line">	<span class="comment">//非递归</span></div><div class="line">	<span class="keyword">public</span> Node <span class="title">searchNoIter</span>(Node root, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">while</span> (root != <span class="keyword">null</span> && value != root.value) {</div><div class="line">			<span class="keyword">if</span> (value &lt;= root.value) {</div><div class="line">				root = root.left;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				root = root.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Null Poninter"</span> + value);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> root;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="comment">//	最小值节点</span></div><div class="line">	<span class="keyword">public</span> Node <span class="title">minNode</span>(Node root){</div><div class="line">		<span class="keyword">while</span> (root.left != <span class="keyword">null</span>) {</div><div class="line">			root = root.left;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	}</div><div class="line">	<span class="comment">//	最大值节点</span></div><div class="line">	<span class="keyword">public</span> Node <span class="title">maxNode</span>(Node root){</div><div class="line">		<span class="keyword">while</span> (root.right != <span class="keyword">null</span>) {</div><div class="line">			root = root.right;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node <span class="title">insertNode</span>(Node root, Node x){</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Node(x.value);</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (x.value &lt;= root.value) {</div><div class="line">			root.left = insertNode(root.left, x);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			root.right = insertNode(root.right, x);</div><div class="line">		}</div><div class="line">	</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	}</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node <span class="title">remove</span>(Node root, <span class="keyword">int</span> value){</div><div class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> root;</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (value &lt; root.value) {</div><div class="line">			root.left = remove(root.left, value);</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (value &gt; root.value) {</div><div class="line">			root.right = remove(root.right, value);</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (root.left != <span class="keyword">null</span> && root.right != <span class="keyword">null</span>) {</div><div class="line">			root.value = minNode(root.right).value;</div><div class="line">			root.right = remove(root.right, root.value);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			root = (root.left != <span class="keyword">null</span>)? root.left:root.right;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> root;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<h3 id="泛型带parent节点版本">泛型带parent节点版本</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Algorithm;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiSearchTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>{</div><div class="line">	<span class="keyword">private</span> Node&lt;T&gt; root;</div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt;</span>{</div><div class="line">		T key;</div><div class="line">		Node&lt;T&gt; left;</div><div class="line">		Node&lt;T&gt; right;</div><div class="line">		Node&lt;T&gt; parent;</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> <span class="title">Node</span>(T key, Node&lt;T&gt; parent, Node&lt;T&gt; left, Node&lt;T&gt;right){</div><div class="line">			<span class="keyword">this</span>.key = key;</div><div class="line">			<span class="keyword">this</span>.parent = parent;</div><div class="line">			<span class="keyword">this</span>.left = left;</div><div class="line">			<span class="keyword">this</span>.right = right;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">public</span> T <span class="title">getKey</span>(){</div><div class="line">			<span class="keyword">return</span> key;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">BiSearchTree</span>(){</div><div class="line">		root = <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span>(Node&lt;T&gt; root){</div><div class="line">		<span class="keyword">if</span> (root != <span class="keyword">null</span>) {</div><div class="line">			inOrder(root.left);</div><div class="line">			System.out.print(root.key + <span class="string">"\t"</span>);</div><div class="line">			inOrder(root.right);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">search</span>(Node&lt;T&gt; tree, T key){</div><div class="line">		<span class="keyword">if</span> (tree == <span class="keyword">null</span> || key == tree.key) {</div><div class="line">			<span class="keyword">return</span> tree;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> cmp = key.compareTo(tree.key);</div><div class="line">		<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) {</div><div class="line">			<span class="keyword">return</span> search(tree.left, key);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> search(tree.right, key);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">searchNode</span>(Node&lt;T&gt; tree, T key){</div><div class="line">		<span class="keyword">while</span> (tree != <span class="keyword">null</span> && key != tree.key) {</div><div class="line">			<span class="keyword">int</span> cmp = key.compareTo(tree.key);</div><div class="line">			<span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) {</div><div class="line">				tree = tree.left;</div><div class="line">			}<span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) {</div><div class="line">				tree = tree.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">minNode</span>(Node&lt;T&gt; tree){</div><div class="line">		<span class="keyword">while</span> (tree.left != <span class="keyword">null</span>) {</div><div class="line">			tree = tree.left;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">maxNode</span>(Node&lt;T&gt; tree){</div><div class="line">		<span class="keyword">while</span> (tree.right != <span class="keyword">null</span>) {</div><div class="line">			tree = tree.right;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> tree;</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 如果x没有右孩子。则x有以下两种可能：</div><div class="line">	 * (01) x是"一个左孩子"，则"x的后继结点"为 "它的父结点"。</div><div class="line">	 * (02) x是"一个右孩子"，则查找"是其父节点的左儿子的节点"为止，找到的这个"最低的父结点"就是"x的后继结点"。</div><div class="line">	 *<span class="javadoctag"> @param</span> x</div><div class="line">	 *<span class="javadoctag"> @return</span></div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">successor</span>(Node&lt;T&gt; x){</div><div class="line">		<span class="comment">// 如果x存在右孩子，则"x的后继结点"为 "以其右孩子为根的子树的最小结点"。</span></div><div class="line">		<span class="keyword">if</span> (x.right != <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> minNode(x.right);</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; before = x.parent;</div><div class="line">		<span class="keyword">while</span> (before != <span class="keyword">null</span> && x == before.right) {</div><div class="line">			x = before;</div><div class="line">			before = before.parent;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> before;</div><div class="line">	}</div><div class="line">	<span class="comment">// 如果x没有左孩子。则x有以下两种可能：</span></div><div class="line">	<span class="comment">// (01) x是"一个右孩子"，则"x的前驱结点"为 "它的父结点"。</span></div><div class="line">	<span class="comment">// (01) x是"一个左孩子"，则查找"是其父节点的右儿子节点"，找到的这个"最低的父结点"就是"x的前驱结点"。</span></div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">preDecessor</span>(Node&lt;T&gt; x){</div><div class="line">		<span class="keyword">if</span> (x.left != <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> maxNode(x.left);</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; before = x.parent;</div><div class="line">		<span class="keyword">while</span> (before != <span class="keyword">null</span> && x == before.left) {</div><div class="line">			x = before;</div><div class="line">			before = before.right;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> before;</div><div class="line">	}</div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 先找到插入位置的父节点，如果父节点为null，则插到父节点，否则插入左或右节点</div><div class="line">	 *<span class="javadoctag"> @param</span> tree</div><div class="line">	 *<span class="javadoctag"> @param</span> node 待插入节点</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertNode</span>(Node&lt;T&gt; tree, Node&lt;T&gt; node){</div><div class="line">		Node&lt;T&gt; before = <span class="keyword">null</span>;</div><div class="line">		Node&lt;T&gt; index = tree;</div><div class="line">		<span class="keyword">while</span> (index != <span class="keyword">null</span>) {</div><div class="line">			before = index;</div><div class="line">			<span class="keyword">if</span> (node.key.compareTo(index.key) &lt; <span class="number">0</span>) {</div><div class="line">				index = index.left;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				index = index.right;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		node.parent = before;</div><div class="line">		<span class="keyword">if</span> (before == <span class="keyword">null</span>) {</div><div class="line">			tree = node;</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (node.key.compareTo(before.key) &lt; <span class="number">0</span>) {</div><div class="line">			before.left = node;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			before.right = node;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> Node&lt;T&gt; <span class="title">remove</span>(Node&lt;T&gt; tree, T key){</div><div class="line">		Node&lt;T&gt; node = search(tree, key);</div><div class="line">		<span class="keyword">if</span> (node == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">return</span> node;</div><div class="line">		}</div><div class="line">		Node&lt;T&gt; index = <span class="keyword">null</span>;</div><div class="line">		Node&lt;T&gt; child = <span class="keyword">null</span>;</div><div class="line">		<span class="keyword">if</span> (node.left == <span class="keyword">null</span> || node.left == <span class="keyword">null</span>) {</div><div class="line">			index = node;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			index = successor(node);</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (index.left != <span class="keyword">null</span>) {</div><div class="line">			child = index.left;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			child = index.right;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (child != <span class="keyword">null</span>) {</div><div class="line">			child.parent = index.parent;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (index.parent == <span class="keyword">null</span>) {</div><div class="line">			tree = child;</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (index == index.parent.left) {</div><div class="line">			index.parent.left = child;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			index.parent.right = child;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (index != node) {</div><div class="line">			node.key = index.key;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> index;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[二叉查找树是一种数据结构，支持多种动态集合操作。在二叉查找树上执行的基本操作时间与树高成正比。]]>
    
    </summary>
    
      <category term="Tree" scheme="http://alexyyek.github.io/tags/Tree/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[哈希碰撞]]></title>
    <link href="http://alexyyek.github.io/2014/12/14/hashCollapse/"/>
    <id>http://alexyyek.github.io/2014/12/14/hashCollapse/</id>
    <published>2014-12-14T11:46:07.000Z</published>
    <updated>2014-12-16T13:59:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="链地址法">链地址法</h2>
<p>Java.util.Hashtable类实现了JAVA中的哈希表，内部采用Entry[]数组，每个Entry均可作为链表的头，用来解决哈希碰撞。</p>
<h3 id="Hashtable特点"><strong>Hashtable特点</strong></h3>
<ul>
<li>线程安全，能用于多线程环境中。</li>
<li>Key、Value均不能为null。</li>
<li>Hashtable同样实现了Serializable接口，它支持序列化，实现了Cloneable接口，能被克隆。</li>
<li>包含了一个Entry[]数组，而Entry又是一个链表，用来处理冲突。</li>
<li>每个Key对应了Entry数组中固定的位置（记为index），称为槽位（Slot）。槽位计算公式为：<pre><code>       (key.hash<span class="variable">Code</span>() &amp; <span class="number">0</span>x7<span class="variable">FFFFFFF</span>) <span class="comment">% Entry[].length() </span>
</code></pre></li>
<li>当Entry[]的实际元素数量（Count）超过了分配容量（Capacity）的75%时，新建一个Entry[]是原先的2倍，重新Hash（rehash）。</li>
<li>rehash的核心思路是，将旧Entry[]数组的元素重新计算槽位，散列到新Entry[]中。<br><br></li>
</ul>
<hr>
<h3 id="Hashtable源码分析"><strong>Hashtable源码分析</strong></h3>
<p><strong>Entry类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Entry&lt;K,V&gt; <span class="comment">// Entry&lt;K,V&gt;是槽中的元素，可做链表，解决散列冲突。</span></div><div class="line">{</div><div class="line">     <span class="keyword">int</span> hash; <span class="comment">// 即key.hashCode()</span></div><div class="line">     K key;</div><div class="line">     V value;</div><div class="line">     Entry&lt;K,V&gt; next; <span class="comment">// 用来实现链表结构。同一链表中的key的hash是相同的。</span></div><div class="line">     <span class="keyword">protected</span> <span class="title">Entry</span>(<span class="keyword">int</span> hash, K key, V value, Entry&lt;K,V&gt; next) {</div><div class="line">          <span class="keyword">this</span>.hash=hash;<span class="keyword">this</span>.key=key;<span class="keyword">this</span>.value=value;<span class="keyword">this</span>.next=next;</div><div class="line">     }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><br><br><strong>构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="title">Hashtable</span>(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor) {</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                initialCapacity);</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);</div><div class="line"> </div><div class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</div><div class="line">        initialCapacity = <span class="number">1</span>;</div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity];</div><div class="line">    threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Constructs a new, empty hashtable with the specified initial capacity</div><div class="line"> * and default load factor (0.75).</div><div class="line"> *<span class="javadoctag"> @param</span>     initialCapacity   the initial capacity of the hashtable.</div><div class="line"> *<span class="javadoctag"> @exception</span> IllegalArgumentException if the initial capacity is less</div><div class="line"> *              than zero.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="title">Hashtable</span>(<span class="keyword">int</span> initialCapacity) {</div><div class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75</span>f);</div><div class="line">}</div><div class="line"> </div><div class="line"><span class="javadoc">/**</span></div><div class="line"> * Constructs a new, empty hashtable with a default initial capacity (11)</div><div class="line"> * and load factor (0.75).</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="title">Hashtable</span>() {</div><div class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75</span>f);</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>threshold：Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”</li>
<li>loadFactor：加载因子，通常设为<strong><code>0.75</code></strong><br><br></li>
</ul>
<p><strong>hashcode</strong><br>考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在）。</p>
<p>也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span>(Object key) {</div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">    <span class="keyword">int</span> index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) {</div><div class="line">        <span class="keyword">if</span> ((e.hash == hash) && e.key.equals(key)) {</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值(实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值)；</p>
<ul>
<li>if（table中没有该hashcode值），then → 直接存进去</li>
<li>if（存在该hashcode值），then → 调用equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址<br>所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：<strong>Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。</strong><br><br></li>
</ul>
<p><strong>addEntry</strong><br>addEntry方法实现向Hashtable中添加k-v值对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span>(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index) {</div><div class="line">    modCount++;</div><div class="line"> </div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">if</span> (count &gt;= threshold) {</div><div class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></div><div class="line">        rehash();</div><div class="line"> </div><div class="line">        tab = table;</div><div class="line">        hash = key.hashCode();</div><div class="line">        index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    }</div><div class="line"> </div><div class="line">    <span class="comment">// Creates the new entry.</span></div><div class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index]; <span class="comment">// 旧有Entry</span></div><div class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e); <span class="comment">/* 旧有Entry成为了新增Entry的next */</span></div><div class="line">    count++;</div><div class="line">}</div></pre></td></tr></table></figure>

<p>当count大于阀值时，要重新进行hash，重新确定Hashtable的大小<br><br></p>
<p><strong>rehash</strong><br>rehash方法即再次hash，当Entry[]的实际存储数量占分配容量的约75%时，扩容并且重新计算各个对象的槽位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span>() {</div><div class="line">          <span class="keyword">int</span> oldCapacity = table.length;</div><div class="line">          Entry[] oldMap = table;</div><div class="line">          <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 2倍+1</span></div><div class="line">          Entry[] newMap = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">          threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</div><div class="line">          table = newMap;</div><div class="line"> </div><div class="line">          <span class="keyword">for</span>( <span class="keyword">int</span> i=oldCapacity; i-- &gt;<span class="number">0</span>;){ <span class="comment">//  i的取值范围为 [oldCapacity-1,0]</span></div><div class="line">               <span class="keyword">for</span> (Entry&lt;K,V&gt; old = oldMap[i]; old!=<span class="keyword">null</span>;){ <span class="comment">// 遍历旧Entry[]</span></div><div class="line">                    Entry&lt;K,V&gt; e = old;</div><div class="line">                    <span class="comment">//重新计算各个元素在新Entry[]中的槽位index。</span></div><div class="line">                    <span class="keyword">int</span> index = (e.hash & <span class="number">0x7FFFFFFF</span>) % newCapacity;     </div><div class="line">                    e.next = newMap[index]; <span class="comment">// 已经存在槽位中的Entry成为了新增Entry的next </span></div><div class="line">                    newMap[index]=e;     <span class="comment">// 放到槽位中</span></div><div class="line">                    old = old.next;</div><div class="line">               }</div><div class="line">          }</div><div class="line"> </div><div class="line">     }</div></pre></td></tr></table></figure>

<p><br></p>
<hr>
<h3 id="Hashtable源码总结">Hashtable源码总结</h3>
<p><strong>1</strong>. <strong>关于hashCode()和equals()方法</strong><br>下面这段话摘自Effective Java一书：</p>
<blockquote>
<ul>
<li>在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。</li>
<li>如果两个对象根据equals方法比较是相等的，那么调用两个对象的hashCode方法必须返回相同的整数结果。</li>
<li>如果两个对象根据equals方法比较是不等的，则hashCode方法不一定得返回不同的整数。</li>
</ul>
</blockquote>
<p>对于第二条和第三条很好理解，但是第一条，很多时候就会忽略。在《Java编程思想》一书中的P495页也有同第一条类似的一段话：</p>
<blockquote>
<p>设计hashCode()时最重要的因素就是：无论何时，对同一个对象调用hashCode()都应该产生同样的值。如果在讲一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。</p>
</blockquote>
<p><strong>所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码。</strong></p>
<p><br><br><strong>2</strong>. <strong>Hashtable中key和value都不允许为null</strong><br>而HashMap中key和value都允许为null（key只能有一个为null，而value则可以有多个为null）。但是如果在Hashtable中有类似put(null,null)的操作，编译同样可以通过，因为key和value都是Object类型，但运行时会抛出NullPointerException异常，这是JDK的规范规定的。<br><br><br><strong>3</strong>. <strong>Hashtable计算hash值</strong><br>直接用key的hashCode()，而HashMap重新计算了key的hash值，Hashtable在求hash值对应的位置索引时，用取模运算，而HashMap在求位置索引时，则用与运算，且这里一般先用hash&amp;0x7FFFFFFF后，再对length取模，&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，<strong>只有符号外改变，而后面的位都不变</strong> 。</p>
<p><br></p>
<hr>
<h3 id="链地址法性能分析">链地址法性能分析</h3>
<p>给定一个能存放n个元素，具有m个槽位的散列表T，定义T的装载因子$a=n/m$，即一个链中的平均元素数。假定可以在<code>O(1)</code>的时间内计算出散列值h(k)，即计算散列函数和寻址槽h(k)为<code>O(1)</code>时间。现查找元素k：</p>
<ul>
<li><p>一次不成功情况<br>在简单一致散列的假设下。一次不成功查找的<code>期望</code>时间为<code>0(1+a)</code><br>一次不成功即查找遍整个散列表<code>T[h(k)]</code>，平均每个链表查找元素为$a=n/m$，加上计算哈希h(k)的时间，总时间为<code>O(1+a)</code></p>
</li>
<li><p>一次成功情况<br>在简单一致散列的假设下。一次成功查找的期望时间为<code>0(1+a)</code><br><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/QQ图片20141215121340.png" alt=""> <center></center></center></p>
</li>
</ul>
<p>由于链表中新元素是在表头插入的，所以一次成功的查找中，所检查的元素数比x所在链表中出现在x前面的元素数多1<br>在hash值为index的槽位，一次成功的查找中，所检查元素的期望为：</p>
<p>$E\ [1/n·\sum_{i=1}^n(1+\sum_{j=i+1}^n X_{ij})]$</p>
<p>$=1/n·\sum_{i=1}^n(1+\sum_{j=i+1}^n E[X_{ij}])=1/n·\sum_{i=1}^n(1+\sum_{j=i+1}^n1/m)$</p>
<p>$=1+1/{mn}(\sum_{i=1}^nn-\sum_{i=1}^ni)=1+1/{mn}(n^2-n(n+1)/2)$</p>
<p>$=1+(n-1_/2m)=1+a/2-a/2n$</p>
<p>于是，一次成功的查找所需全部时间为<code>O(2+a/2-a/2n)</code>=<code>O(1+a)</code>.</p>
<p><strong>Conclusion</strong>：如果散列表中槽位数至少与表中的元素数成正比，则有n=O(m)，从而 $a=n/m=O(m)/m=O(1)$<br>所以平均查找操作需要常数量的时间，且已经知道插入操作最坏情况需要<code>O(1)</code>，删除操作最坏需要<code>O(1)</code>，因而全部字典操作可以在<code>O(1)</code>时间完成。</p>
<h2 id="开放寻址法">开放寻址法</h2>
<p>前面讲的方法主要基于用链表的方法解决哈希冲突，但元素数n大于槽位数m时，必然会导致至少一个槽位被多个元素hash到，因此链地址法的查询性能平均为<code>O(1+a)</code>，不能达到理想的<code>O(1)</code>。<br>开放寻址法中，所有的元素都存放在散列表里，即每个表项是动态集合中的一个元素，或者为NIL。当要插入一个元素时，可以连续的检查散列表的各项,直到找个一个空槽来存放待插入元素，整个数组必须支持<code>动态扩容</code>：当数组空闲节点低于一个阀值时，将扩展数组容量为原来的一倍。这个阀值通常是<code>0.72</code>。当然检查的顺序不一定是0,1,…,m-1，主要分为下面三种探查方法：</p>
<h3 id="线性探查">线性探查</h3>
<p>将散列表T[0,1,…,m-1]看成是一个循环向量，若初始探查的地址为d(即h(key)=d)，则最长的探查序列为：</p>
<p><center> $d，d+l，d+2，…，m-1，0，1，…，d-1$ <center></center></center></p>
<p>散列函数为</p>
<p><center> $h(k,i)=(h^*(k)+i) \ mod \ m \ , \ i=0,1,…,m-1$ <center></center></center></p>
<p>探查过程终止于三种情况：</p>
<ol>
<li>若当前探查的单元为空，则表示查找失败（若是插入则将key写入其中）；</li>
<li>若当前探查的单元中含有key，则查找成功，但对于插入意味着失败；</li>
<li>若探查到T[d-1]时仍未发现空单元也未找到key，则无论是查找还是插入均意味着失败(此时表满)。</li>
</ol>
<p><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/直接寻址.jpg" alt=""> <center> </center></center></p>
<p>用线性探测法处理冲突，思路清晰，算法简单，但存在下列缺点：</p>
<ul>
<li>处理溢出需另编程序。一般可另外设立一个溢出表，专门存放哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。</li>
<li>按上述算法建立起来的哈希表，删除工作非常困难。假如要从哈希表中删除一个记录，按理应将这个记录所在位置置为空，但我们不能这样做，而只能标上已被删除的标记<code>DELETE</code>，否则，将会影响以后的查找。</li>
<li>线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长（即不同关键字值的哈希地址相邻在一起愈长），则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。</li>
</ul>
<p><strong>线性补偿探测法</strong><br>线性补偿探测法的基本思想是：将线性探测的步长从 1 改为 Q ，即将上述算法中的 </p>
<p>$h(k,i)=(h^”(k)+1) \ mod \ m$ 改为 $h(k,i)=(h^”(k)+Q) \ mod \ m$ </p>
<p>而且要求 Q 与 m 是<code>互质</code>的，以便能探测到哈希表中的所有单元。<br><br></p>
<hr>
<h3 id="二次探查">二次探查</h3>
<p>二次探查采用如下形式的散列函数：</p>
<p><center> $h(k,i)=(h^*(k)+c_1i+c_2i^2) \ mod \ m \ , \ i=0,1,…,m-1, \ c_2\not=0$ <center></center></center></p>
<p>其中$h^*(k)$是一个辅助散列函数，$c_1$和 $c_2$为辅助常数。初始的探查位置为$T[h^*(k)]$，后续的探查位置要加上一个偏移量，该偏移量以二次的方式依赖于探查序号i。这种探查方法的效果要比线性探查好很多，但是，为了能够充分利用散列表，$c_1$，$c_2$和 $m$的值要受到限制。此外，如果两个关键字的初始探查位置相同，那么它们的探查序列也是相同的。这一性质可导致一种轻度的群集，称为二次群集。<br><br></p>
<hr>
<h3 id="双重散列">双重散列</h3>
<p>双重散列是用于开放寻址最好的方法之一，它采用如下形式的散列函数：</p>
<p><center> $h(k,i)=(h_1(k)+ih_2(k)) \ mod \ m$ <center></center></center></p>
<p>为了能查找整个散列表，值$h_2(k)$要与表的大小m<code>互质</code>，确保这一条件成立的方法有两种</p>
<ol>
<li>取m为2的幂，并设计一个总产生奇数的$h_2$</li>
<li>取m为质数，并设计一个总是产生较m小的正整数的$h_2$</li>
</ol>
<p>例如下图所示，散列表大小为 $m=13$，$h_1(k)=k \ mod \ 13$, $h_2(k)=1+(k \ mod \ 11)$，因为$14\equiv1\ (mod\ 13)$，$14\equiv3\ (mod\ 11)$，故在探查了槽1和槽5并发现被占用后，关键字14被插入到空槽9中。</p>
<p><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/QQ图片20141215204708.png" alt=""> <center></center></center></p>
<p>双重散列法中用了$O(m^2)$种探查序列，而线性探查或二次探查中用了$O(m)$种，所以是一种改进。<br><br></p>
<hr>
<h3 id="开放寻址散列性能分析">开放寻址散列性能分析</h3>
<p>在开放寻址法中，每个槽位至多只有一个元素，因而 $n\leq m$，这意味着 $n \leq 1$<br>下面分析在<code>一致散列</code>假设下，用开放寻址法进行散列时预期的探查数</p>
<ul>
<li>给定一个装载因子为$a=n/m&lt;1$的开放寻址散列表，在<code>一次不成功</code>的查找中，期望的探查数至多为：$\frac{1}{(1-a)}$</li>
<li>给定一个装载因子为$a&lt;1$的开放寻址散列表，<code>一次成功</code>查找中的期望探查数至多为：$\frac{1}{a}·ln\frac{1}{1-a}$</li>
</ul>
<h2 id="Java代码实现">Java代码实现</h2>
<h3 id="Hashtable链地址法">Hashtable链地址法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Practice;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Objects;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{</div><div class="line">	<span class="keyword">private</span> Entry&lt;K, V&gt;[] table;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> threhold;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>{</div><div class="line">		<span class="keyword">int</span> hash;</div><div class="line">		K key;</div><div class="line">		V value;</div><div class="line">		Entry next;</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="title">Entry</span>() {</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="title">Entry</span>(<span class="keyword">int</span> hash, K key, V value, Entry next) {</div><div class="line">			<span class="keyword">this</span>.hash = hash;</div><div class="line">			<span class="keyword">this</span>.key = key;</div><div class="line">			<span class="keyword">this</span>.value = value;</div><div class="line">			<span class="keyword">this</span>.next = next;</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> K <span class="title">getKey</span>() {</div><div class="line">			<span class="keyword">return</span> key;</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> V <span class="title">getValue</span>() {</div><div class="line">			<span class="keyword">return</span> value;</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> V <span class="title">setValue</span>(V value) {</div><div class="line">			<span class="keyword">if</span> (value == <span class="keyword">null</span>) {</div><div class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">			}</div><div class="line">			V old = <span class="keyword">this</span>.value;</div><div class="line">			<span class="keyword">this</span>.value = value;</div><div class="line">			<span class="keyword">return</span> old;</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span>(Object o) {</div><div class="line">			<span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Entry)) {</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			}</div><div class="line">			Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) o;</div><div class="line">			<span class="keyword">return</span> (key == <span class="keyword">null</span> ? e.getKey() == <span class="keyword">null</span> : key.equals(e.getKey()))</div><div class="line">					&& (value == <span class="keyword">null</span> ? e.getValue() == <span class="keyword">null</span> : value.equals(e</div><div class="line">							.getValue()));</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashcode</span>() {</div><div class="line">			<span class="keyword">return</span> hash ^ Objects.hashCode(value);</div><div class="line">		}</div><div class="line"></div><div class="line">		<span class="keyword">public</span> String <span class="title">toString</span>() {</div><div class="line">			<span class="keyword">return</span> key.toString() + <span class="string">"="</span> + value.toString();</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">Hashtable</span>(<span class="keyword">int</span> initCapacity, <span class="keyword">float</span> loadFactor) {</div><div class="line">		<span class="keyword">if</span> (initCapacity &lt; <span class="number">0</span>)</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity"</span></div><div class="line">					+ initCapacity);</div><div class="line">		<span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load"</span> + loadFactor);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (initCapacity == <span class="number">0</span>)</div><div class="line">			initCapacity = <span class="number">1</span>;</div><div class="line">		<span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">		table = <span class="keyword">new</span> Entry[initCapacity];</div><div class="line">		threhold = (<span class="keyword">int</span>) Math</div><div class="line">				.min(initCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">Hashtable</span>(<span class="keyword">int</span> initCapacity) {</div><div class="line">		<span class="keyword">this</span>(initCapacity, <span class="number">0.75</span>f);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="title">Hashtable</span>() {</div><div class="line">		<span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75</span>f);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span>() {</div><div class="line">		<span class="keyword">return</span> count;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span>(K key, V value) {</div><div class="line">		<span class="keyword">if</span> (value == <span class="keyword">null</span>) {</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">		}</div><div class="line"></div><div class="line">		Entry&lt;?, ?&gt; tab[] = table;</div><div class="line">		<span class="keyword">int</span> hash = key.hashCode();</div><div class="line">		<span class="keyword">int</span> index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">		<span class="keyword">for</span> (Entry&lt;K, V&gt; entry = (Entry&lt;K, V&gt;) tab[index]; entry != <span class="keyword">null</span>; entry = entry.next) {</div><div class="line">			<span class="keyword">if</span> ((entry.hash == hash) && entry.key.equals(key)) {</div><div class="line">				V old = entry.value;</div><div class="line">				entry.value = value;</div><div class="line">				<span class="keyword">return</span> old;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">if</span> (count &gt; threhold) {</div><div class="line">			rehash();</div><div class="line">			tab = table;</div><div class="line">			hash = key.hashCode();</div><div class="line">			index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">		Entry&lt;K, V&gt; entry = (Entry&lt;K, V&gt;) tab[index];</div><div class="line">		tab[index] = <span class="keyword">new</span> Entry&lt;K, V&gt;(hash, key, value, entry);</div><div class="line">		count ++;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span>(Object key){</div><div class="line">		Entry&lt;?, ?&gt; tab[] = table;</div><div class="line">		<span class="keyword">int</span> hash = key.hashCode();</div><div class="line">		<span class="keyword">int</span> index = (hash & <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">		<span class="keyword">for</span> (Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) tab[index]; e != <span class="keyword">null</span> ; e = e.next) {</div><div class="line">			<span class="keyword">if</span> (e.hash == hash && e.key.equals(key)) {</div><div class="line">				<span class="keyword">return</span> e.value;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span>(){</div><div class="line">		<span class="keyword">int</span> oldCapacity = table.length;</div><div class="line">		Entry&lt;?, ?&gt;[] oldEntry = table;</div><div class="line">		</div><div class="line">		<span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line">		</div><div class="line">		Entry[]	newMap = <span class="keyword">new</span> Entry[newCapacity];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity; i &gt; <span class="number">0</span>; i--) {</div><div class="line">			<span class="keyword">for</span> (Entry&lt;K, V&gt; e = (Entry&lt;K, V&gt;) oldEntry[i];  e != <span class="keyword">null</span>; e = e.next) {</div><div class="line">				<span class="keyword">int</span> index = (e.hash & <span class="number">0x7FFFFFFF</span>) % newCapacity;</div><div class="line">				e.next = newMap[index];</div><div class="line">				newMap[index] = e;</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String arg[]) {</div><div class="line">        Hashtable&lt;String, String&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;String, String&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) {</div><div class="line">            hashtable.put(<span class="string">"lyx"</span> + i, <span class="string">"lyx"</span> + i);</div><div class="line">        }</div><div class="line"> </div><div class="line">        hashtable.put(<span class="string">"lyx0"</span>, <span class="string">"aaaaaaaaaaaaaaaaaaaaa"</span>);</div><div class="line">        hashtable.put(<span class="string">"lyx0"</span>, <span class="string">"aaaaaaaaaaaaaaaaaaaaa"</span>);</div><div class="line">        hashtable.put(<span class="string">"lyx0"</span>, <span class="string">"aaaaaaaaaaaaaaaaaaaaa"</span>);</div><div class="line">        hashtable.put(<span class="string">"lyx0"</span>, <span class="string">"aabbccdd"</span>);</div><div class="line"> </div><div class="line">        System.out.println(hashtable.get(<span class="string">"lyx0"</span>));</div><div class="line">        System.out.println(hashtable.get(<span class="string">"lyx1"</span>));</div><div class="line">        System.out.println(hashtable.get(<span class="string">"lyx2"</span>));</div><div class="line">        System.out.println(hashtable.get(<span class="string">"lyx3"</span>));</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>


<h3 id="线性探查-1">线性探查</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> Practice;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.nio.BufferOverflowException;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHash</span>&lt;<span class="title">T</span>&gt; </span>{</div><div class="line">	<span class="keyword">private</span> T[] table;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tableCapacity;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="title">LinearProbingHash</span>(<span class="keyword">int</span> tableSize){</div><div class="line">		table = (T[]) <span class="keyword">new</span> Object[tableSize];</div><div class="line">		<span class="keyword">this</span>.tableCapacity = tableSize;</div><div class="line">		size = <span class="number">0</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(T item){</div><div class="line">		<span class="keyword">int</span> index, originIndex;</div><div class="line">		index = (item.hashCode() & <span class="number">0x7FFFFFFF</span>) % tableCapacity;</div><div class="line">		originIndex = index;</div><div class="line">		do {</div><div class="line">			<span class="keyword">if</span> (table[index] == <span class="keyword">null</span> || table[index].equals(<span class="string">"DELETE"</span>)) {</div><div class="line">				table[index] = item;</div><div class="line">				size++;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				index = (index + <span class="number">1</span>) % tableCapacity;</div><div class="line">			}</div><div class="line">		} <span class="keyword">while</span> (index != originIndex);</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span>(T item){</div><div class="line">		<span class="keyword">int</span> index, originIndex;</div><div class="line">		index = (item.hashCode() & <span class="number">0x7FFFFFFF</span>) % tableCapacity;</div><div class="line">		originIndex = index;</div><div class="line">		do {</div><div class="line">			<span class="keyword">if</span> (table[index].equals(item)) {</div><div class="line">				table[index] = (T) <span class="string">"DELETE"</span>;</div><div class="line">				size--;</div><div class="line">				<span class="keyword">return</span> index;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				index = (index & <span class="number">0x7FFFFFFF</span>) % tableCapacity;</div><div class="line">			}</div><div class="line">		} <span class="keyword">while</span> (index != originIndex);</div><div class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span>(T item){</div><div class="line">		<span class="keyword">return</span> (find(item) &lt; <span class="number">0</span>) ? <span class="keyword">false</span> : <span class="keyword">true</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span>(){</div><div class="line">		<span class="keyword">return</span> size;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span>(T item){</div><div class="line">		<span class="keyword">int</span> index, originIndex;</div><div class="line">		index = (item.hashCode() & <span class="number">0x7FFFFFFF</span>) % tableCapacity;</div><div class="line">		originIndex = index;</div><div class="line">		do {</div><div class="line">			<span class="keyword">if</span> (table[index].equals(item)) {</div><div class="line">				<span class="keyword">return</span> index;</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				index = (index + <span class="number">1</span>) % tableCapacity;</div><div class="line">			}</div><div class="line">		} <span class="keyword">while</span> (index != originIndex);</div><div class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> String <span class="title">toString</span>() {  </div><div class="line">        <span class="keyword">int</span> max = tableCapacity - <span class="number">1</span>;  </div><div class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer();  </div><div class="line">        buf.append(<span class="string">"["</span>);  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tableCapacity; i++) {  </div><div class="line">            <span class="keyword">if</span>(table[i] != <span class="keyword">null</span>) {  </div><div class="line">                buf.append(table[i]);  </div><div class="line">                <span class="keyword">if</span>(i &lt; max)  </div><div class="line">                    buf.append(<span class="string">", "</span>);  </div><div class="line">            }  </div><div class="line">        }  </div><div class="line">        buf.append(<span class="string">"]"</span>);  </div><div class="line">        <span class="keyword">return</span> buf.toString();  </div><div class="line">    }  </div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args) {  </div><div class="line">        LinearProbingHash&lt;Integer&gt; lp = <span class="keyword">new</span> LinearProbingHash&lt;Integer&gt;(<span class="number">10</span>);  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">54</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">77</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">94</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">89</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">14</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">45</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">35</span>));  </div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">76</span>));  </div><div class="line">          </div><div class="line">        System.out.println(lp); <span class="comment">// [35, 76, 54, 94, 14, 77, 45, 89]  </span></div><div class="line">        System.out.println(lp.contains(<span class="keyword">new</span> Integer(<span class="number">45</span>))); <span class="comment">// true  </span></div><div class="line">        System.out.println(lp.size()); <span class="comment">// 8  </span></div><div class="line">        </div><div class="line">        lp.delete(<span class="keyword">new</span> Integer(<span class="number">77</span>));</div><div class="line">        System.out.println(lp); <span class="comment">// [35, 76, 54, 94, 14, DELETE, 45, 89]</span></div><div class="line">        System.out.println(lp.size()); <span class="comment">// 7</span></div><div class="line">        lp.add(<span class="keyword">new</span> Integer(<span class="number">100</span>));</div><div class="line">        System.out.println(lp); <span class="comment">// [35, 76, 100, 54, 94, 14, DELETE, 45, 89]</span></div><div class="line">        System.out.println(lp.size()); <span class="comment">// 8</span></div><div class="line">    }  </div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[当多个关键字映射到同一槽位时，便发生哈希碰撞。主要解决方案有两种，一种是基于链表的链地址法，另一种则是开放寻址法。]]>
    
    </summary>
    
      <category term="hash" scheme="http://alexyyek.github.io/tags/hash/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[散列函数]]></title>
    <link href="http://alexyyek.github.io/2014/12/11/hash/"/>
    <id>http://alexyyek.github.io/2014/12/11/hash/</id>
    <published>2014-12-11T14:12:51.000Z</published>
    <updated>2014-12-15T10:31:00.000Z</updated>
    <content type="html"><![CDATA[<p>一个好的散列函数应满足<code>简单一致</code>散列的假设：每个关键字都等可能的散列到m个槽位的任何一个之中，并与其它的关键字已被散列到哪个槽位无关。</p>
<h2 id="除法散列法">除法散列法</h2>
<p>在用来设计散列函数的除法散列法中，通过取k除以m的余数，将关键字k映射到m个槽中的某一个上，即散列函数为:</p>
<p><center> $$h(k)=k mod m$$ <center></center></center></p>
<p>当应用除法散列法时，要避免选择m的某些值，m常常选择与近2的整数幂的不太接近的<code>素数</code>。<br><strong>Explain</strong>：如果 $m=2^p$，二进制除法相当于右位移<code>&gt;&gt;</code>，例如<code>111010&gt;&gt;3</code>,即除以$2^3$，右移3位变为<code>111</code>，<code>010</code>则作为余数被移除，故在做取余操作时值为<code>010</code>,即为k的p个最低位数字。</p>
<h2 id="乘法散列法">乘法散列法</h2>
<p>乘法散列法整体包含两步：</p>
<ul>
<li>用关键字k乘上常数<code>A(0&lt;A&lt;1)</code>，并去除kA的小数部分</li>
<li>用m乘以这个值，再取结果的底<code>floor</code><br>公式：    <code>h(k)=Math.floor[m(kA mod 1)]</code><br><center><img src="http://alexyoung.qiniudn.com/26822401_1334109664MN4j.png" alt=""><center></center></center></li>
</ul>
<p><strong>STEP</strong>：</p>
<ul>
<li>假设某计算机的字长为 $w$ 位，而 $k$ 正好可容于一个字中（$k&lt;2^w$)</li>
<li>现在选取范围$[0，2^w]$内的任意数值 $s$，$k×s$ 即可用$R_1·2^w+R_0$来表示</li>
<li>因此$(k·A) mod 1=k·s/2^w$就是将$k×s$整体向右平移 $w$ 位，此时$R_0$即为小数部分</li>
<li>再乘以$2^m$相当于左移 $m$ 位，散列值 $h(k)$ 为$R_0$的前m位。</li>
</ul>
<h2 id="全域散列">全域散列</h2>
<p>如果让某个与你作对的人来选择要散列的关键字，那么他会选择全部散列到同一槽位的n个关键字，使得<code>平均检索时间</code>为<code>O(n)</code>，任何一个特定的散列函数都无法避免这种最坏情况的发生。唯一有效的改进方法是<code>随机的选择散列函数</code>，使之独立于要存储的关键字，这便是全域散列(universal hashing)，无论对手如何选择关键字，平均性态都很好。</p>
<p><strong>步骤</strong></p>
<ul>
<li>选择一个足够大的<code>质数</code>$p$，使得每个关键字都落在 $[0, p-1]$ 范围内；</li>
<li>集合$Z_p$ = $\{0,1,…,p-1\}$，集合$Z^*_p$= $\{1,2,…,p-1\}$，对于任何 $a \in Z^*_p$，$b \in Z_p$，定义散列函数 $h_{a,b}$：</li>
</ul>
<p><center> $h_{a,b}(k) = ((ak+b)\ mod \ p)\ mod \ m$ <center></center></center></p>
<p>假定关键字的范围大于散列表的槽位数，即 $p&gt;m$，对 $a$而言有<code>p</code>种选择，对 $b$ 而言有<code>p-1</code>种可能，所以 $H_{a,b}$有<code>p(p-1)</code>种可能性。当随机的选择关键字$k \not= l$，两者发生碰撞的概率不大于<code>1/m</code>。</p>
<p><strong>Proof</strong>：<br>考虑 $Z_p $ 中两个不同的关键字 $k$ 和 $l$，即 $k \not= l$，对某一给定的随机散列函数$h_{a,b}$</p>
<p><center> $r=(ak+b)\ mod\ p$         ,      $s=(al+b)\ mod \ p$ <center></center></center></p>
<p>此处必有 $ r\not= s$，因为 $r-s = a(k-l)\ mod\ p$</p>
<p><code>p</code>为质数，故<code>a</code>和<code>k-l</code>模<code>p</code>均不为0，因此在模<code>p</code>这一层次上，尚不出现冲突。</p>
<p>故对于某个给定的<code>r</code>值，<code>s</code>的可能取值为余下的<code>p-1</code>种，其中满足$s \not= r$且$r \equiv s(mod \ p)$的值的数目至多为$(p-1)/m$，所以<code>s</code>与<code>r</code>发生碰撞的概率至多为 $((p-1)/m)/(p-1)=1/m$</p>
<p>$H_{a,b}$是全域的。</p>
<h2 id="完美哈希">完美哈希</h2>
<p>当键值是<code>static</code>(即固定不变)的时候，我们可以涉及方案使得最差情况下的查询性能也很出色，这就是完美哈希。实际上，很多地方都会用到静态关键字集合。比如一种语言的保留字集合，一张CD-ROM里的文件名集合。而完美哈希可以在<code>最坏情况</code>下以<code>O(1)</code>复杂度查找，性能非常出色的。<br>完美哈希的思想就是采用两级的框架，每一级上都用全域哈希：</p>
<p><center> <img src="http://7rf27k.com1.z0.glb.clouddn.com/30143317-b1a1356610cb4d6eb8cda2a1e9f36eba.png" alt=""> <center></center></center></p>
<p>完美哈希的结构如上图。具体来说，第一级和带链表的哈希非常的相似，只是第一级发生冲突后后面接的不是链表，而是一个新的哈希表。后面那个哈希结构，我们可以看到前端存储了一些哈希表的基本性质：$m$ 是哈希表槽数；$a,b$ 全域哈希函数要确定的两个值(一般是随机选然后确定下来的)，后面跟着哈希表。</p>
<p>为了保证不冲突，<strong>每个二级哈希表的数量是第一级映射到这个槽中元素个数的平方</strong>，这样可以保证整个哈希表非常的稀疏。下面给出一个定理，能更清楚的看到设置 $m=n^2$的作用。</p>
<p><strong>定理</strong>：设$H$是一类全域哈希函数，哈希表的槽数 $m=n^2$。 那么，如果我们用一个随机函数 $h \in H$把 $n$ 个keys映射到表中。冲突次数的期望最多是1/2.</p>
<p><strong>Proof</strong>：根据全域哈希的定义，对任意选出的哈希函数h，表中2个给定keys冲突的概率是 $1/m$,即 $1/n^2$<br>且总共有$C_2^n$可能的键值对，那么冲突次数的期望就是：</p>
<p><center> $C_2^n/n^2=n(n−1)/2·n^2 &lt; 1/2$   <center></center></center></p>
<p>证毕！</p>
]]></content>
    <summary type="html">
    <![CDATA[一个好的散列函数应满足简单一致散列的假设：每个关键字都等可能的散列到m个槽位的任何一个之中，并与其它的关键字已被散列到哪个槽位无关。]]>
    
    </summary>
    
      <category term="hash" scheme="http://alexyyek.github.io/tags/hash/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[中位数和顺序统计学]]></title>
    <link href="http://alexyyek.github.io/2014/12/08/select/"/>
    <id>http://alexyyek.github.io/2014/12/08/select/</id>
    <published>2014-12-08T13:38:01.000Z</published>
    <updated>2014-12-08T14:09:55.000Z</updated>
    <content type="html"><![CDATA[<h2 id="期望线性时间选择问题">期望线性时间选择问题</h2>
<p>从集合中选出第N大的数，RANDOMIZED-SELECT算法与快速排序类似，对输入数组进行递归划分，但RANDOMIZED-SELECT只处理划分的一边，因此快排的期望运行时间是<code>O(nlgn)</code>，而RANDOMIZED-SELECT<code>期望运行时间</code>只需要<code>O(n)</code> </p>
<p><strong>伪代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">RANDOMIZED-SELECT(A,p,r,i)</div><div class="line"><span class="keyword">if</span> p==r</div><div class="line">    <span class="keyword">return</span> A[p]</div><div class="line">q = RANDOM-PARTITION(A,p,r)</div><div class="line">k = q - p + <span class="number">1</span></div><div class="line"><span class="keyword">if</span> i=k</div><div class="line">    <span class="keyword">return</span> A[q]</div><div class="line">elseif i &lt; k</div><div class="line">    <span class="keyword">return</span> RANDOMIZED-SELECT(A,p,q-q,i)</div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> RANDOMIZED-SELECT(A,q+<span class="number">1</span>,r,i-k)</div></pre></td></tr></table></figure>

<hr>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		<span class="keyword">int</span>[] data ={<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">3</span>};</div><div class="line">		RandomizedSelect select = <span class="keyword">new</span> RandomizedSelect();</div><div class="line">		<span class="keyword">int</span> rank = <span class="number">9</span>;</div><div class="line">		System.out.println(select.select(data, <span class="number">0</span>, data.length-<span class="number">1</span>, rank));</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> rank){</div><div class="line">		<span class="keyword">if</span> (start == end) {</div><div class="line">			<span class="keyword">return</span> data[start];</div><div class="line">		}</div><div class="line">		<span class="keyword">int</span> threshold = randonPartition(data, start, end);</div><div class="line">		<span class="keyword">int</span> k = threshold - start + <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span> (rank == k) { </div><div class="line">			<span class="keyword">return</span> data[threshold];</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (rank &lt; k) {</div><div class="line">			<span class="keyword">return</span> select(data, start, threshold-<span class="number">1</span>, rank);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> select(data, threshold+<span class="number">1</span>, end, rank-k);</div><div class="line">		}</div><div class="line">		</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randonPartition</span>(<span class="keyword">int</span>[] data,<span class="keyword">int</span> start,<span class="keyword">int</span> end){</div><div class="line"> 		<span class="keyword">int</span> q = start + (<span class="keyword">int</span>)Math.random()*(end - start + <span class="number">1</span>);</div><div class="line"> 		<span class="keyword">int</span> temp = data[q];</div><div class="line"> 		data[q] = data[end];</div><div class="line"> 		data[end] = temp;</div><div class="line">		<span class="keyword">return</span> partition(data, start, end);</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> start, <span class="keyword">int</span> end){</div><div class="line">		<span class="keyword">int</span> value = data[end];</div><div class="line">		<span class="keyword">int</span> init = start - <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) {</div><div class="line">			<span class="keyword">if</span> (data[i] &lt; value) {</div><div class="line">				init++;</div><div class="line">				<span class="keyword">int</span> temp = data[init];</div><div class="line">				data[init] = data[i];</div><div class="line">				data[i] = temp;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">int</span> temp = data[end];</div><div class="line">		data[end] = data[init+<span class="number">1</span>];</div><div class="line">		data[init+<span class="number">1</span>] = temp;</div><div class="line">		<span class="keyword">return</span> init+<span class="number">1</span>;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>在最坏的情况下，例如：总是找到最小元素时，总是在最大元素处划分，这是时间复杂度为<code>O(n^2)</code>。但平均时间复杂度与n呈线性关系，为<code>O(n)</code></p>
<h2 id="最坏线性时间选择算法">最坏线性时间选择算法</h2>
<p>该算法利用了RANDOMIZED-SELECT对输入数组进行划分的思维，但不同之处在于该算法保证了数组的划分是好的划分。SELECT算法最坏情况运行时间为<code>O(n)</code></p>
<p><center><img src="http://alexyoung.qiniudn.com/1357624243_8923.jpg" alt=""><center></center></center></p>
<p>算法思路：如果能在线性时间内找到一个划分基准使得按这个基准所划分出的2个子数组的长度都至少为原数组长度的<code>ε</code>倍<code>(0&lt;ε&lt;1)</code>,那么就可以在最坏情况下用<code>O(n)</code>时间完成选择任务。例如，当<code>ε=9/10</code>，算法递归调用所产生的子数组的长度至少缩短1/10。所以，在最坏情况下，算法所需的计算时间<code>T(n)</code>满足递推式<code>T(n)&lt;=T(9n/10)+O(n)</code>。由此可得<code>T(n)=O(n)</code></p>
<p><br></p>
<hr>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Select</span> </span>{</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(String[] args){</div><div class="line">		<span class="keyword">int</span> length = <span class="number">37</span>; <span class="keyword">int</span> rank = <span class="number">10</span>;<span class="comment">/* 37个元素中找出第10小的元素 */</span>  </div><div class="line">		<span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[length];</div><div class="line">		Random rm = <span class="keyword">new</span> Random();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</div><div class="line">			data[i] = rm.nextInt(<span class="number">100</span>);</div><div class="line">		}</div><div class="line">		</div><div class="line">		Select select =  <span class="keyword">new</span> Select();</div><div class="line">		System.out.println(Arrays.toString(data));</div><div class="line">		System.out.println(select.select(data, <span class="number">0</span>, length-<span class="number">1</span>, rank));</div><div class="line">		Arrays.sort(data);</div><div class="line">		System.out.println(Arrays.toString(data));</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> <span class="title">select</span>(<span class="keyword">int</span>[] data,<span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> rank){</div><div class="line">		<span class="keyword">if</span> ((high-low)&lt;<span class="number">5</span>) {</div><div class="line">			insertSort(data, low, high);</div><div class="line">			<span class="keyword">return</span> data[low+rank-<span class="number">1</span>];</div><div class="line">		}</div><div class="line">		<span class="keyword">int</span> group = (high - low + <span class="number">5</span>) / <span class="number">5</span>;</div><div class="line">		<span class="comment">/* 第一步：将输入数组的n个元素划分为n/5组，每组5个元素，且至多只有一个组由剩下的n mod5个元素组成 */</span>  </div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; group; i++) {</div><div class="line">			<span class="keyword">int</span> left = low + i*<span class="number">5</span>;</div><div class="line">			<span class="keyword">int</span> right = (low + i*<span class="number">5</span> + <span class="number">4</span>) &gt; high ? high : (low + i*<span class="number">5</span> + <span class="number">4</span>);</div><div class="line">			<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</div><div class="line">		<span class="comment">/* 第二步：寻找(n+4)/5个组中每一组的中位数。首先对每组中的元素（至多为5个）进行插入排序，然后从排序过的序列中选出中位数 */</span>  </div><div class="line">			insertSort(data, left, right);</div><div class="line">			swap(data, low+i, mid);<span class="comment">// 将中位数置前 </span></div><div class="line">		}</div><div class="line">		<span class="comment">/* 第三步：对第二步中找出的(n+4)/5个中位数，递归调用select以找出其中位数x*/</span>  </div><div class="line">		<span class="keyword">int</span> pivot = select(data, low, low+group-<span class="number">1</span>, (group+<span class="number">1</span>)/<span class="number">2</span>);</div><div class="line">		<span class="comment">/* 第四步：利用修改过的partition过程，按中位数的中位数x对输入数组进行划分 */</span></div><div class="line">		<span class="keyword">int</span> threshold = partition(data, low, high, pivot);</div><div class="line">		<span class="comment">/* 第五步：判断threshold位置是否为要找的数，若不是则在低区或者高区递归select*/</span> </div><div class="line">		<span class="keyword">int</span> k = threshold - low + <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span> (k == rank) {</div><div class="line">			<span class="keyword">return</span> data[threshold];</div><div class="line">		}<span class="keyword">else</span> <span class="keyword">if</span> (k &gt; rank) {</div><div class="line">			<span class="keyword">return</span> select(data, low, threshold-<span class="number">1</span>, rank);</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> select(data, threshold+<span class="number">1</span>, high, rank-k);</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> pivot){</div><div class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">		<span class="comment">/* 找到枢纽的位置index */</span>  </div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt;= high; i++) {</div><div class="line">			<span class="keyword">if</span> (data[i] == pivot) {</div><div class="line">				index = i;</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		swap(data, index, high);</div><div class="line">		<span class="keyword">int</span> init = low - <span class="number">1</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; i++) {</div><div class="line">			<span class="keyword">if</span> (data[i] &lt; pivot) {</div><div class="line">				init++;</div><div class="line">				swap(data, init, i);</div><div class="line">			}</div><div class="line">		}</div><div class="line">		swap(data, init+<span class="number">1</span>, high);</div><div class="line">		<span class="keyword">return</span> init+<span class="number">1</span>;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> a, <span class="keyword">int</span> b){</div><div class="line">		<span class="keyword">int</span> temp = data[a];</div><div class="line">		data[a] = data[b];</div><div class="line">		data[b] = temp;</div><div class="line">	}</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span>(<span class="keyword">int</span>[] data,<span class="keyword">int</span> low,<span class="keyword">int</span> high){</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = low+<span class="number">1</span>; i &lt;= high; i++) {</div><div class="line">			<span class="keyword">int</span> key = data[i];</div><div class="line">			<span class="keyword">int</span> k = i - <span class="number">1</span>;</div><div class="line">			<span class="keyword">while</span> (k &gt;= low && data[k] &gt; key) {</div><div class="line">				data[k+<span class="number">1</span>] = data[k];</div><div class="line">				k--;</div><div class="line">			}</div><div class="line">			data[k+<span class="number">1</span>] = key;</div><div class="line">		}</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[从一个由N个不同数值构成的集合中选择其第i个顺序统计量。]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[线性时间排序]]></title>
    <link href="http://alexyyek.github.io/2014/12/07/lineSort/"/>
    <id>http://alexyyek.github.io/2014/12/07/lineSort/</id>
    <published>2014-12-07T13:43:08.000Z</published>
    <updated>2014-12-07T14:19:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="快速排序算法">快速排序算法</h2>
<ul>
<li>分解<br>数组<code>A[p..r]</code>被划分为两个子数组，<code>A[p..q-1]</code>和<code>A[q+1..r]</code>，使得<code>A[p..q-1]</code>中每个元素都小于等于<code>A(q)</code>，且小于等于<code>A[q+1..r]</code>中元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">QUICKSORT(A,p,r)</div><div class="line"><span class="comment">//正常方法</span></div><div class="line"><span class="keyword">if</span> (p &lt; r){</div><div class="line">    then q = PARTITION(A,p,r)</div><div class="line">    QUICKSORT(A,p,q-<span class="number">1</span>)</div><div class="line">    QUICKSORT(A,q+<span class="number">1</span>,r)</div><div class="line">}</div><div class="line"><span class="comment">//尾递归方法</span></div><div class="line"><span class="keyword">while</span> (start &lt; end) {</div><div class="line">	<span class="keyword">int</span> q = partition(data, start, end);</div><div class="line">	quickSort(data, start, q-<span class="number">1</span>);</div><div class="line">	start = q + <span class="number">1</span>;</div><div class="line">}</div></pre></td></tr></table></figure>

<ul>
<li>解决<br>通过递归调用，两个子数组各自内部排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PARTITION(A,p,r)</div><div class="line">x = A[r]</div><div class="line">i = p-<span class="number">1</span></div><div class="line"><span class="keyword">for</span> j=p to r-<span class="number">1</span></div><div class="line">    <span class="keyword">if</span> A[j] &lt; x</div><div class="line">    i++</div><div class="line">    A[j]=A[i]</div><div class="line">exchange A[i+<span class="number">1</span>] ↔ A[r]</div><div class="line"><span class="keyword">return</span> i+<span class="number">1</span></div></pre></td></tr></table></figure>

<p>因为子数组是内部排序，所以无需合并操作，平均时间复杂度<code>O(nlgn)</code></p>
<h2 id="线性时间排序">线性时间排序</h2>
<p>之前的排序算法都属于<code>比较排序</code>，任何比较排序在最坏的情况下都要做<code>Ω(nlgn)</code>次比较来进行排序，下面介绍三种线性时间运行的排序</p>
<h3 id="计数排序">计数排序</h3>
<p>计数排序的前提是确定输入范围大小为0～k。在这个前提下，我们可以使用计数的方法对数组进行排序，而不是使用比较。算法思想如下：因为输入数组A中的元素范围固定，因此可以使用一个大小为k的数组C对A中的元素进行映射。</p>
<p><center><img src="http://alexyoung.qiniudn.com/QQ图片201412007210801.png" alt=""><center></center></center></p>
<p><strong>伪代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">COUNTING-SORT(A,B,k)</div><div class="line"><span class="keyword">for</span> i←<span class="number">0</span> to k</div><div class="line">    do C[i] = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> j←<span class="number">1</span> to length[A]</div><div class="line">    do C[A[j]] = C[A[j]] + <span class="number">1</span></div><div class="line">    C[i]中包含等于i的元素个数</div><div class="line"><span class="keyword">for</span> i←<span class="number">1</span> to k</div><div class="line">    C[i] = C[i-<span class="number">1</span>] + C[i]</div><div class="line"><span class="keyword">for</span> j←<span class="number">1</span> to length[A]</div><div class="line">    do B[C[A[j]]] = A[j]</div><div class="line">    C[A[j]]--</div></pre></td></tr></table></figure>

<h3 id="基数排序">基数排序</h3>
<p>实现原理：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。给定n个d位数，每一个数位有k种可能取值，基数排序能以<code>O(d(n+k))</code>的时间正确排序。<br>基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>
<p><center><img src="http://alexyoung.qiniudn.com/1338051031_6070.jpg" alt=""><center></center></center></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> radix){</div><div class="line">		<span class="keyword">int</span> queue = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> bit = <span class="number">1</span>; <span class="comment">//数位</span></div><div class="line">		<span class="keyword">int</span> position = <span class="number">1</span>;<span class="comment">//当前数位</span></div><div class="line">		<span class="keyword">int</span>[][] reminder = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][data.length];</div><div class="line">		<span class="keyword">int</span>[] order = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line">		</div><div class="line">		<span class="keyword">while</span> (position &lt;= radix) {</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) {</div><div class="line">				<span class="keyword">int</span> lsd = (data[i] / bit) % <span class="number">10</span>;</div><div class="line">				reminder[lsd][order[lsd]] = data[i];</div><div class="line">				order[lsd]++;</div><div class="line">			}</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</div><div class="line">				<span class="keyword">if</span> (order[i] != <span class="number">0</span>) {</div><div class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; order[i]; j++) {</div><div class="line">						data[queue++] = reminder[i][j];</div><div class="line">					}</div><div class="line">				}</div><div class="line">				order[i] = <span class="number">0</span>;</div><div class="line">			}</div><div class="line">			bit *= <span class="number">10</span>;</div><div class="line">			queue = <span class="number">0</span>;</div><div class="line">			position++;</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="桶排序">桶排序</h3>
<p>桶排序的思想是把区间[0,1)划分成n个相同大小的子区间，称为桶，然后将n个输入数分布到各个桶中去。因为输入数均匀且独立分布在[0,1)上，所以，一般不会有很多数落在一个桶中的情况。为了得到结果，先对各个桶中的数进行排序，然后按次序把各桶中的元素列出来。桶排序的时间复杂度为<code>O(n)</code></p>
<p><center><img src="http://alexyoung.qiniudn.com/bucket_sort.PNG" alt=""><center></center></center></p>
<p><strong>伪代码</strong></p>
<figure class="highlight JAVA"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BUCKET-SORT(A)</div><div class="line">n = length(A)</div><div class="line"><span class="keyword">for</span> i=<span class="number">1</span> to n</div><div class="line">    do insert A[i] to list Math.floor(B[n*A[i]])</div><div class="line"><span class="keyword">for</span> i=<span class="number">1</span> to n</div><div class="line">    do sort list B[i] (recommand Collections.sort)</div><div class="line">concatenate the list B[<span class="number">1</span>] to B[n] INTO A</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[不同于比较排序O(lgn)的时间复杂度，线性时间排序可以在O(n)的时间完成排序。]]>
    
    </summary>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HeapSort]]></title>
    <link href="http://alexyyek.github.io/2014/12/07/heap/"/>
    <id>http://alexyyek.github.io/2014/12/07/heap/</id>
    <published>2014-12-07T06:52:35.000Z</published>
    <updated>2014-12-07T07:00:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="堆排序">堆排序</h2>
<p>堆数据结构是一种数组对象，它可以被视为一颗完全二叉树，树中每个节点与数组中存放该节点值的元素对应。堆分为大根堆和小根堆；大根堆是指除根节点以外每个节点<code>i</code>都有<code>A[parent(i)]&gt;=A[i]</code>，即每个节点的值最多和父节点的值一样大，这样堆中的最大值就在根节点中，且以某个节点为根的子树中，各个节点的值都不大于该子树根节点的值，图1就是一个大根堆。小根堆的刚好相反，每个节点的值都不小于其父节点。</p>
<center><img src="http://alexyoung.qiniudn.com/B44BD10DE99C61C6E965337C8EFFBE6A_B500_900_392_301.PNG" alt=""></center>

<h3 id="保持堆的性质">保持堆的性质</h3>
<p><strong>maxHeapify</strong>是对大根堆进行操作的重要子程序，其输入为一个数组A和一个下标i，maxHeapify被调用时假定left(i)和right(i)都满足大根堆的性质，但是A[i]有可能小于其子女而违反了大根堆性质，maxHeapify使A[i]下降，使以A[i]为根的堆成为大根堆。其过程如图 2所示：<br><img src="http://alexyoung.qiniudn.com/CBDE478800037BD91BF72E29598EFEBD_B500_900_500_341.PNG" alt=""><br><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> length, <span class="keyword">int</span> index){</div><div class="line">		<span class="keyword">int</span> left = getLeftChildIndex(index);</div><div class="line">		<span class="keyword">int</span> right = getRightChildIndex(index);</div><div class="line">		<span class="keyword">int</span> largest = index;</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (left &lt; length && data[left] &gt; data[index]) {</div><div class="line">			largest = left;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (right &lt; length && data[right] &gt; data[largest]) {</div><div class="line">			largest = right;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (largest != index) {</div><div class="line">			<span class="keyword">int</span> temp = data[index];</div><div class="line">			data[index] = data[largest];</div><div class="line">			data[largest] = temp;</div><div class="line">			maxHeapify(data, length, largest);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="建堆">建堆</h3>
<p><strong>buildMaxHeap</strong>算法是利用maxHeapify算法来进行的。用数组存储一个有n个元素堆时，叶节点的下标是n/2+1、n/2+2……n（这里就不做证明了，有兴趣可以自己证明），建立大根堆就是利用这个性质。叶节点可以看做只有一个元素的堆，只有一个元素也就自然满足大根堆的性质，所以以叶节点为根的堆都是大根堆。但是以其它节点为根的堆就不一定是大根堆，为了使他们满足大根堆的性质，就在节点上调用maxHeapify（叶节点是大根堆就满足了函数输入时的条件）。所以建立大根堆的过程就是在除叶节点以为的节点上调用maxHeapify。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span>(<span class="keyword">int</span>[] data){</div><div class="line">		<span class="keyword">int</span> start = getParentIndex(data.length);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &gt;= <span class="number">0</span>; i--) {</div><div class="line">			maxHeapify(data, data.length, i);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h3 id="堆排序-1">堆排序</h3>
<p><strong>heapSort</strong>也是利用maxHeapify算法来进行的。在一个大根堆中，最大元素就是堆的根。堆排序就是利用的这个性质。在一个含有n个元素的数组上调用buildMaxHeap，就能得到最大的元素，然后将最大的元素和数组的尾部，再将最大元素从堆中除去，此时堆的元素为n-1个，但是不满足大根堆的性质，就在根节点上调用maxHeapify使其成为大根堆。不断重复这个过程直到堆中只剩下一个元素，就完成了排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span>(<span class="keyword">int</span>[] data){</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = data.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) {</div><div class="line">			<span class="keyword">int</span> temp = data[<span class="number">0</span>];</div><div class="line">			data[<span class="number">0</span>]	= data[i];</div><div class="line">			data[i] = temp;</div><div class="line">			maxHeapify(data, i, <span class="number">0</span>);</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

<h2 id="优先级队列">优先级队列</h2>
<p>优先级队列是一种用来维护由一组数组元素构成集合S的数据结构，每个元素都有一个关键字key。</p>
<ul>
<li>INSERT(S,x)：元素x插入集合S</li>
<li>MAXIMUN(S)：返回S中具有最大key的元素</li>
<li>EXTRACT-MAX(S)：去掉并返回S中具有最大key的元素</li>
<li>INCREASE-KEY(S,x,k)：将元素x的key值增加到k，k&gt;=key</li>
</ul>
<h3 id="伪代码">伪代码</h3>
<p>HEAP-MAXIMUN(A)，时间复杂度<code>O(1)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> A[<span class="number">1</span>];</div></pre></td></tr></table></figure>

<p>HEAP-EXTRACT-MAX(A)，时间复杂度<code>O(lgn)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> heap-size[A]&lt;<span class="number">1</span></div><div class="line">    then error <span class="string">"heap underflow"</span></div><div class="line">max ← A[<span class="number">1</span>]</div><div class="line">A[<span class="number">1</span>] ← A[heap-size[A]]</div><div class="line">heap-size[A] ← heap-size[A]-<span class="number">1</span></div><div class="line">MAX-HEAPIFY(A,<span class="number">1</span>)</div><div class="line"><span class="keyword">return</span> max</div></pre></td></tr></table></figure>

<p>HEAP-INCREASE-KEY(A,i,key)，时间复杂度<code>O(lgn)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> key&lt;A[i]</div><div class="line">    then error <span class="string">"new key is smaller than the current key"</span></div><div class="line">A[i] ← key</div><div class="line"><span class="keyword">while</span> i&gt;<span class="number">1</span> && A[parent[i]]&lt;A[i]</div><div class="line">    do exchange A[i] ↔ A[parent[i]]</div><div class="line">    i ← parent(i)</div></pre></td></tr></table></figure>

<p>HEAP-INSERT(A,key)，时间复杂度<code>O(lgn)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">heap-size[A] ← heap-size[A]+<span class="number">1</span></div><div class="line">A[heap-size[A]] ← -∞</div><div class="line">HEAP-INCREASE-KEY(A,heap-size[A],key)</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[堆数据结构是一种数组对象，它可以被视为一颗完全二叉树，树中每个节点与数组中存放该节点值的元素对应。]]>
    
    </summary>
    
      <category term="heap" scheme="http://alexyyek.github.io/tags/heap/"/>
    
      <category term="coding" scheme="http://alexyyek.github.io/tags/coding/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Count And Say]]></title>
    <link href="http://alexyyek.github.io/2014/12/06/CountAndSay/"/>
    <id>http://alexyyek.github.io/2014/12/06/CountAndSay/</id>
    <published>2014-12-06T09:31:42.000Z</published>
    <updated>2014-12-06T09:46:52.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Count_and_Say">Count and Say</h2>
<p>Question : The count-and-say sequence is the sequence of integers beginning as follows:<br><code>1, 11, 21, 1211, 111221, ...</code></p>
<p><code>1</code> is read off as <code>one 1</code> or <code>11</code>.<br><code>11</code> is read off as <code>two 1s</code> or <code>21</code>.<br><code>21</code> is read off as <code>one 2, then one 1</code> or <code>1211</code>.<br>Given an integer <code>n</code>, generate the nth sequence.<br><a id="more"></a> </p>
<h3 id="Best_solution">Best solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">countAndSay</span>(<span class="keyword">int</span> n) {</div><div class="line">	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>) {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line"></div><div class="line">	String first = <span class="string">"1"</span>;</div><div class="line">	<span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) {</div><div class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; first.length(); j++) {</div><div class="line">			<span class="keyword">if</span> (j &lt; first.length() - <span class="number">1</span></div><div class="line">					&& (first.charAt(j) == first.charAt(j + <span class="number">1</span>))) {</div><div class="line">				count++;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				sb.append(count + <span class="string">""</span> + first.charAt(j));</div><div class="line">				count = <span class="number">1</span>;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		first = sb.toString();</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> first;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>Analyze</strong> : 题目非常简单，序列迭代规则已经列出，求第n次迭代的值。基本方法判断相邻两个字符是否一样，算出每一次的序列值，迭代到n次为止。其实也可以用递归的方法来做，给出第n-1次的规则，求第n次的值。<br><br></p>
<hr>
<p>比较有意思的是用DFS的思想来解决此题，代码如下：</p>
<h3 id="DFS">DFS</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> String s = <span class="string">"1"</span>;</div><div class="line"><span class="keyword">public</span> String <span class="title">countSay</span>(<span class="keyword">int</span> n) {</div><div class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</div><div class="line">        dfs(s.length());</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span>(<span class="keyword">int</span> length) {</div><div class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">1</span>, i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (i &lt; length - <span class="number">1</span> && s.charAt(i) == s.charAt(<span class="number">1</span> + i)) {</div><div class="line">        count++;</div><div class="line">        i++;</div><div class="line">    }</div><div class="line">    s = s.substring(i + <span class="number">1</span>) + count + s.charAt(i);</div><div class="line">    dfs(length - count);</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>Analyze</strong> : 深度优先算法的思路也很简单，比如第4次迭代结果为1211，现在进行第5次迭代</p>
<ul>
<li>树<code>1-2-1-1</code>根节点为<code>1</code>，出现一次所以值变成<code>11</code>,树变成<code>2-1-1</code>，所以整体值为<code>21111</code>；</li>
<li>第二次运算<code>2</code>出现一次，值为<code>12</code>，树还剩<code>1-1</code>，所以整体值为<code>111112</code>，注意这里前面11是待统计的树<code>1-1</code>,中间的11是第一次的运算值，最后的12是第二次的运算值；</li>
<li>由于树<code>1-1</code>中<code>1</code>出现了两次，所以值为<code>21</code>，s = s.substring(i + 1) + count + s.charAt(i) = 111221</li>
</ul>
<h3 id="More">More</h3>
<p>这道题在leetcode上的表述略有不清，我第一次就把此题误解为给定任意整数n，去求此整数的第n次迭代值<br>比如5-&gt;15-&gt;1115-&gt;3115-&gt;132115-&gt;1113122115，结果发现高估此题了…<br>既然都写了就列在下面吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">countAndSay</span>(<span class="keyword">int</span> n) {</div><div class="line">	<span class="keyword">if</span> (n &lt; <span class="number">0</span>) {</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	}</div><div class="line">	String word = String.valueOf(n);</div><div class="line">	<span class="keyword">while</span> (n &gt; <span class="number">0</span>) {</div><div class="line">		<span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">		StringBuffer sBuffer = <span class="keyword">new</span> StringBuffer();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) {</div><div class="line">			<span class="keyword">if</span> (i &lt; word.length() - <span class="number">1</span></div><div class="line">					&& word.charAt(i) == word.charAt(i + <span class="number">1</span>)) {</div><div class="line">				count++;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				sBuffer.append(count).append(word.charAt(i));</div><div class="line">				count = <span class="number">1</span>;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		word = sBuffer.toString();</div><div class="line">		n--;</div><div class="line">	}</div><div class="line">	<span class="keyword">return</span> word;</div><div class="line">}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[The count-and-say sequence is the sequence of integers beginning as follows 1, 11, 21, 1211, 111221, ... , Given an integer n, generate the nth sequence.]]>
    
    </summary>
    
      <category term="dfs" scheme="http://alexyyek.github.io/tags/dfs/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Trapping Rain Water]]></title>
    <link href="http://alexyyek.github.io/2014/12/04/TrappingRainWater/"/>
    <id>http://alexyyek.github.io/2014/12/04/TrappingRainWater/</id>
    <published>2014-12-04T07:17:18.000Z</published>
    <updated>2014-12-04T07:49:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Trapping_Rain_Water">Trapping Rain Water</h2>
<p>Question : Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br><a id="more"></a><br>For example:<br>Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.</p>
<p><img src="http://leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png" alt=""></p>
<h3 id="Best_Solution">Best Solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span>(<span class="keyword">int</span>[] A) {</div><div class="line">		<span class="keyword">int</span> a = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> b = A.length - <span class="number">1</span>;</div><div class="line">		<span class="keyword">int</span> max = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> leftmax = <span class="number">0</span>;</div><div class="line">		<span class="keyword">int</span> rightmax = <span class="number">0</span>;</div><div class="line">		<span class="keyword">while</span> (a &lt;= b) {</div><div class="line">			leftmax = Math.max(leftmax, A[a]);</div><div class="line">			rightmax = Math.max(rightmax, A[b]);</div><div class="line">			<span class="keyword">if</span> (leftmax &lt; rightmax) {</div><div class="line">				max += (leftmax - A[a]); </div><div class="line">				a++;</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				max += (rightmax - A[b]);</div><div class="line">				b--;</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> max;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><strong>Analyze</strong> : I calculated the stored water at each index a and b in my code. At the start of every loop, I update the current maximum height from left side (that is from A[0,1…a]) and the maximum height from right side(from A[b,b+1…n-1]). if(leftmax &lt; rightmax) then, at least (leftmax-A[a]) water can definitely be stored no matter what happens between [a,b] since we know there is a barrier at the rightside(rightmax &gt; leftmax).</p>
]]></content>
    <summary type="html">
    <![CDATA[Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.]]>
    
    </summary>
    
      <category term="Arrays" scheme="http://alexyyek.github.io/tags/Arrays/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Simplify Path]]></title>
    <link href="http://alexyyek.github.io/2014/11/30/SimplifyPath/"/>
    <id>http://alexyyek.github.io/2014/11/30/SimplifyPath/</id>
    <published>2014-11-30T13:13:12.000Z</published>
    <updated>2014-12-01T05:04:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Simplify_Path">Simplify Path</h2>
<p>Question:Given an absolute path for a file (Unix-style), simplify it.<br><a id="more"></a></p>
<p>For example,<br>path = <code>/home/</code> =&gt; <code>/home</code><br>path = <code>/a/./b/../../c/</code> =&gt; <code>/c</code><br><br></p>
<table>
<thead>
<tr>
<th>Situation</th>
<th style="text-align:center">Meaning</th>
<th style="text-align:center">Solution</th>
</tr>
</thead>
<tbody>
<tr>
<td>/..</td>
<td style="text-align:center">返回上级目录</td>
<td style="text-align:center">若stack不空，stack.pop()</td>
</tr>
<tr>
<td>/.</td>
<td style="text-align:center">留在本目录</td>
<td style="text-align:center">无操作</td>
</tr>
<tr>
<td>/</td>
<td style="text-align:center">多余的slash</td>
<td style="text-align:center">无操作</td>
</tr>
<tr>
<td>other</td>
<td style="text-align:center">有效目录名</td>
<td style="text-align:center">入栈</td>
</tr>
</tbody>
</table>
<h3 id="My_solution">My solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">soluition</span>(String path) {</div><div class="line">        String[] unit = path.split(<span class="string">"/"</span>);</div><div class="line">        StringBuffer line = <span class="keyword">new</span> StringBuffer();</div><div class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unit.length; i++) {</div><div class="line">        	<span class="keyword">if</span> (!unit[i].equals(<span class="string">""</span>)) {</div><div class="line">        		<span class="keyword">if</span> (unit[i].equals(<span class="string">"."</span>)) {</div><div class="line">    				<span class="keyword">continue</span>;</div><div class="line">    			}<span class="keyword">else</span> <span class="keyword">if</span> (unit[i].equals(<span class="string">".."</span>)) {</div><div class="line">    				<span class="keyword">if</span> (!stack.isEmpty()) {</div><div class="line">    					stack.pop();</div><div class="line">        				stack.pop();</div><div class="line">					}</div><div class="line">    			}<span class="keyword">else</span> {</div><div class="line">    				stack.push(<span class="string">"/"</span>);</div><div class="line">    				stack.push(unit[i]);</div><div class="line">    			}</div><div class="line">			}</div><div class="line">		}</div><div class="line">        <span class="keyword">if</span> (stack.isEmpty()) {</div><div class="line">			<span class="keyword">return</span> <span class="string">"/"</span>;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">while</span> (!stack.isEmpty()) {</div><div class="line">				line.insert(<span class="number">0</span>, stack.pop());</div><div class="line">			}</div><div class="line">			<span class="keyword">return</span> line.toString();</div><div class="line">		}</div><div class="line">    }</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[Question:Given an absolute path for a file (Unix-style), simplify it.]]>
    
    </summary>
    
      <category term="stack" scheme="http://alexyyek.github.io/tags/stack/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Valid Parentheses]]></title>
    <link href="http://alexyyek.github.io/2014/11/28/valid-parentheses/"/>
    <id>http://alexyyek.github.io/2014/11/28/valid-parentheses/</id>
    <published>2014-11-28T14:42:18.000Z</published>
    <updated>2014-11-29T06:16:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Valid_Parentheses">Valid Parentheses</h2>
<p>Question：Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.<br>The brackets must close in the correct order, <code>()</code> and <code>()[]{}</code> are all valid but <code>(]</code> and <code>([)]</code> are not.<br><a id="more"></a>  </p>
<h3 id="Best_Solution">Best Solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span>(String s){</div><div class="line">		HashMap&lt;Character, Character&gt;map = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</div><div class="line">		map.put(<span class="string">'('</span>, <span class="string">')'</span>);</div><div class="line">		map.put(<span class="string">'['</span>, <span class="string">']'</span>);</div><div class="line">		map.put(<span class="string">'{'</span>, <span class="string">'}'</span>);</div><div class="line">		</div><div class="line">		Stack&lt;Character&gt;stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) {</div><div class="line">			<span class="keyword">char</span> head = s.charAt(i);</div><div class="line">			</div><div class="line">			<span class="keyword">if</span> (map.containsKey(head)) {</div><div class="line">				stack.push(head);</div><div class="line">			}<span class="keyword">else</span> <span class="keyword">if</span> (map.values().contains(head)) {</div><div class="line">				<span class="keyword">if</span> (!stack.isEmpty() && map.get(stack.peek()).equals(head)) {</div><div class="line">					stack.pop();</div><div class="line">				}<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> stack.isEmpty();</div><div class="line">	}</div></pre></td></tr></table></figure>

<p><strong>Analyze</strong>：思想非常简单，当看到左括号的时候就push入栈，看到右括号时与stack.peek相匹配，匹配成功则pop，如果字符串valid，则stack.isEmpty会为true，即所有左括号都匹配到对应的右括号。<br>PS. 一定要在else if内加栈空判断，防止字符串以右括号开始，如<code>}[()]</code><br><br></p>
<h3 id="My_Solution">My Solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span>(String s){</div><div class="line">		HashMap&lt;String, String&gt;map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">		map.put(<span class="string">"("</span>, <span class="string">")"</span>);</div><div class="line">		map.put(<span class="string">"["</span>, <span class="string">"]"</span>);</div><div class="line">		map.put(<span class="string">"{"</span>, <span class="string">"}"</span>);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (s.length()%<span class="number">2</span> != <span class="number">0</span>) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		}</div><div class="line">		</div><div class="line">		Stack&lt;String&gt;stack = <span class="keyword">new</span> Stack&lt;String&gt;();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = s.length(); i &gt; <span class="number">0</span>; i--) {</div><div class="line">			stack.push(s.substring(i-<span class="number">1</span>, i));</div><div class="line">		}</div><div class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (!map.containsKey(stack.peek())) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">while</span> (!stack.isEmpty()) {</div><div class="line">			String head = stack.pop();</div><div class="line">			<span class="keyword">if</span> (map.containsKey(head)) {</div><div class="line">				list.add(head);</div><div class="line">			}<span class="keyword">else</span> {</div><div class="line">				<span class="keyword">if</span> (head.equals(map.get(list.get(list.size() - <span class="number">1</span>)))) {</div><div class="line">					list.remove(list.size() - <span class="number">1</span>);</div><div class="line">				}<span class="keyword">else</span> {</div><div class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">				}</div><div class="line">			}</div><div class="line">		}</div><div class="line">		</div><div class="line">		<span class="keyword">if</span> (!list.isEmpty()) {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		}<span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		}</div><div class="line">	}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. The brackets must close in the correct order, `()` and `()[]{}` are all valid but `(]` and `([)]` are not.]]>
    
    </summary>
    
      <category term="stack" scheme="http://alexyyek.github.io/tags/stack/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Min Stack]]></title>
    <link href="http://alexyyek.github.io/2014/11/19/Stack/"/>
    <id>http://alexyyek.github.io/2014/11/19/Stack/</id>
    <published>2014-11-19T12:54:53.000Z</published>
    <updated>2014-11-28T14:50:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Min_Stack">Min Stack</h2>
<p>Question : Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.<br><a id="more"></a>   </p>
<ul>
<li>push(x) — Push element x onto stack.</li>
<li>pop() — Removes the element on top of the stack.</li>
<li>top() — Get the top element.</li>
<li>getMin() — Retrieve the minimum element in the stack.<br><br></li>
</ul>
<hr>
<h3 id="Best_solution">Best solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStackBest</span> </span>{</div><div class="line">	Stack&lt;Long&gt; stack;</div><div class="line">	<span class="keyword">long</span> min = <span class="number">0</span>;</div><div class="line">	<span class="keyword">public</span> <span class="title">MinStackBest</span>() {</div><div class="line">		stack = <span class="keyword">new</span> Stack&lt;Long&gt;();</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(<span class="keyword">int</span> x) {</div><div class="line">		<span class="keyword">if</span> (stack.isEmpty()) {</div><div class="line">			stack.push(<span class="number">0</span>L);</div><div class="line">			min = x;</div><div class="line">		} <span class="keyword">else</span> {</div><div class="line">			stack.push(x - min);</div><div class="line">			<span class="keyword">if</span> (x &lt; min) {</div><div class="line">				min = x;</div><div class="line">			}</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span>() {</div><div class="line">		<span class="keyword">if</span> (stack.isEmpty()) {</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		}</div><div class="line">		<span class="keyword">long</span> pop = stack.pop();</div><div class="line">		<span class="keyword">if</span> (pop &lt; <span class="number">0</span>) {</div><div class="line">			min = min - pop;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span>() {</div><div class="line">		<span class="keyword">long</span> top = stack.peek();</div><div class="line">		<span class="keyword">if</span> (top &gt; <span class="number">0</span>) {</div><div class="line">			<span class="keyword">return</span> (<span class="keyword">int</span>) (min + top);</div><div class="line">		} <span class="keyword">else</span> {</div><div class="line">			<span class="keyword">return</span> (<span class="keyword">int</span>) min;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span>() {</div><div class="line">		<span class="keyword">return</span> (<span class="keyword">int</span>) min;</div><div class="line">	}</div></pre></td></tr></table></figure>

<p>The thought is to store the gap between the current value and min value, while the only problem is int is 4 bit<br>so the Max gap = Integer.MAXVALUE - Integer.MINVALUE, and that value beyond int, so the author init the min value as long.</p>
<p><br></p>
<h3 id="Another_solution">Another solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>{</div><div class="line">	</div><div class="line">	<span class="keyword">static</span> class Element{</div><div class="line">		<span class="keyword">final</span> <span class="keyword">int</span> value;</div><div class="line">		<span class="keyword">final</span> <span class="keyword">int</span> min;</div><div class="line">		Element(<span class="keyword">int</span> value, <span class="keyword">int</span> min){</div><div class="line">			<span class="keyword">this</span>.value = value;</div><div class="line">			<span class="keyword">this</span>.min = min;</div><div class="line">		}</div><div class="line">	}</div><div class="line">	</div><div class="line">	Stack&lt;Element&gt;stack = <span class="keyword">new</span> Stack&lt;Element&gt;();</div><div class="line">	</div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span>(<span class="keyword">int</span> x) {</div><div class="line">		<span class="keyword">int</span> min = (stack.isEmpty()) ? x : Math.min(x, stack.peek().min);</div><div class="line">		stack.push(<span class="keyword">new</span> Element(x, min));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span>() {</div><div class="line">    	stack.pop();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span>() {</div><div class="line">    	<span class="keyword">return</span> stack.peek().value;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span>() {</div><div class="line">        <span class="keyword">return</span> stack.peek().min;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<p><br></p>
<h2 id="Review_Stack">Review Stack</h2>
<p>Here’s the source code, compose by one Constructor and five Method</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="javadoc">/**</span></div><div class="line">	 * 构造函数</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="title">Stack</span>() {</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * push函数：将元素存入栈顶</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> E <span class="title">push</span>(E item) {</div><div class="line">		<span class="comment">// 将元素存入栈顶。</span></div><div class="line">		<span class="comment">// addElement()的实现在Vector.java中</span></div><div class="line">		addElement(item);</div><div class="line"></div><div class="line">		<span class="keyword">return</span> item;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * pop函数：返回栈顶元素，并将其从栈中删除</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">pop</span>() {</div><div class="line">		E obj;</div><div class="line">		<span class="keyword">int</span> len = size();</div><div class="line"></div><div class="line">		obj = peek();</div><div class="line">		<span class="comment">// 删除栈顶元素，removeElementAt()的实现在Vector.java中</span></div><div class="line">		removeElementAt(len - <span class="number">1</span>);</div><div class="line"></div><div class="line">		<span class="keyword">return</span> obj;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * peek函数：返回栈顶元素，不执行删除操作</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">peek</span>() {</div><div class="line">		<span class="keyword">int</span> len = size();</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (len == <span class="number">0</span>)</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</div><div class="line">		<span class="comment">// 返回栈顶元素，elementAt()具体实现在Vector.java中</span></div><div class="line">		<span class="keyword">return</span> elementAt(len - <span class="number">1</span>);</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 栈是否为空</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span>() {</div><div class="line">		<span class="keyword">return</span> size() == <span class="number">0</span>;</div><div class="line">	}</div><div class="line"></div><div class="line">	<span class="javadoc">/**</span></div><div class="line">	 * 查找“元素o”在栈中的位置：由栈底向栈顶方向数</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">search</span>(Object o) {</div><div class="line">		<span class="comment">// 获取元素索引，elementAt()具体实现在Vector.java中</span></div><div class="line">		<span class="keyword">int</span> i = lastIndexOf(o);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) {</div><div class="line">			<span class="keyword">return</span> size() - i;</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">	}</div></pre></td></tr></table></figure>

]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Min_Stack">Min Stack</h2>
<p>Question : Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.<br>]]>
    
    </summary>
    
      <category term="stack" scheme="http://alexyyek.github.io/tags/stack/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Single Number]]></title>
    <link href="http://alexyyek.github.io/2014/11/17/Single-Number/"/>
    <id>http://alexyyek.github.io/2014/11/17/Single-Number/</id>
    <published>2014-11-17T08:30:25.000Z</published>
    <updated>2014-11-28T14:45:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Single_Number">Single Number</h2>
<p>Question : Given an array of integers, every element appears <code>twice</code> except for one. Find that single one.<br><a id="more"></a><br><br></p>
<h3 id="Best_solution">Best solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span>(<span class="keyword">int</span>[] A) {</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) {</div><div class="line">			result ^= A[i];</div><div class="line">		}</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">    }</div><div class="line">}</div></pre></td></tr></table></figure>

<h3 id="My_solution">My solution</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span>(<span class="keyword">int</span>[] A) {</div><div class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) {</div><div class="line">			<span class="keyword">int</span> key = A[i];</div><div class="line">			<span class="keyword">if</span> (map.containsKey(key)) {</div><div class="line">				map.put(key, map.get(key) + <span class="number">1</span>);</div><div class="line">				<span class="keyword">if</span> (map.get(key) == <span class="number">2</span>) {</div><div class="line">					map.remove(key);</div><div class="line">				}</div><div class="line">			} <span class="keyword">else</span> {</div><div class="line">				map.put(key, <span class="number">1</span>);</div><div class="line">			}</div><div class="line">		}</div><div class="line">		String result = map.keySet().toString();</div><div class="line">		<span class="keyword">int</span> out = Integer.parseInt(result.substring(<span class="number">1</span>, result.length()-<span class="number">1</span>));</div><div class="line">		<span class="keyword">return</span> out;</div><div class="line">	}</div><div class="line">}</div></pre></td></tr></table></figure>

<p>从性能上来评判用XOR无疑使最好的，复杂度只有O(N)。</p>
<p>我个人的方法略显笨拙，复杂度虽然也是O(N), 但开辟的多余的内存空间，不过当element出现的次数改变时，反而有更好的鲁棒性.<br><br></p>
<h3 id="change_question">change question</h3>
<p>Given an array of integers, every element appears <code>three</code> times except for one. Find that single one.<br><br></p>
<h4 id="best_answer">best answer</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span>(<span class="keyword">int</span>[] A) {</div><div class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>, twos = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++){</div><div class="line">        ones = (ones ^ A[i]) & ~twos;</div><div class="line">        twos = (twos ^ A[i]) & ~ones;</div><div class="line">    }</div><div class="line">    <span class="keyword">return</span> ones;</div><div class="line">}</div></pre></td></tr></table></figure>

<p><br></p>
<h4 id="Inference">Inference</h4>
<p>题目中改变了element的出现次数，变成了出现三次，当然用我之前的程序改个数字就能搞定，但仍需要分析一下最优的解法<br>best answer思路：出现三次，可以用2个bit来表征这三个状态，分别是00→10→01→00<br>ones和twos分别承担了这两个bit位<br>如果推理一下可以发现</p>
<blockquote>
<p>ones = ones ^ A[i]; if (twos == 1) then ones = 0, that can be tansformed to ones = (ones ^ &gt;A[i]) &amp; ~twos.</p>
<p>twos = twos ^ A[i]; if (ones == 1) then twos = 0 and twos = (twos ^ A[i]) &amp; ~ones.</p>
</blockquote>
<p><br></p>
<h2 id="回顾">回顾</h2>
<p><br></p>
<h3 id="位移动运算符:">位移动运算符:</h3>
<p><strong>&lt;&lt;</strong>表示左移, 左移一位表示原来的值乘2.</p>
<p>例如：3 &lt;&lt;2(3为int型) </p>
<blockquote>
<ol>
<li>把3转换为二进制数字0000 0000 0000 0000 0000 0000 0000 0011， </li>
<li>把该数字高位(左侧)的两个零移出，其他的数字都朝左平移2位， </li>
<li>在低位(右侧)的两个空位补零。则得到的最终结果是0000 0000 0000 0000 0000 0000 0000 1100. 转换为十进制是12。</li>
</ol>
</blockquote>
<p>同理<strong>&gt;&gt;</strong>表示右移. 右移一位表示除2. </p>
<p>低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1 </p>
<p><br></p>
<h3 id="位运算:">位运算:</h3>
<p>位运算符包括:　与（&amp;）、非（~）、或（|）、异或（^）</p>
<blockquote>
<p>&amp;：当两边操作数的位同时为1时，结果为1，否则为0。如1100&amp;1010=1000 　</p>
<p>| ：当两边操作数的位有一边为1时，结果为1，否则为0。如1100|1010=1110 　</p>
<p>~：0变1,1变0 　　</p>
<p>^：两边的位不同时，结果为1，否则为0.如1100^1010=0110</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Single_Number">Single Number</h2>
<p>Question : Given an array of integers, every element appears <code>twice</code> except for one. Find that single one.<br>]]>
    
    </summary>
    
      <category term="Bit Manipulation" scheme="http://alexyyek.github.io/tags/Bit-Manipulation/"/>
    
      <category term="leetcode" scheme="http://alexyyek.github.io/tags/leetcode/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java处理字符串-删除所有标点]]></title>
    <link href="http://alexyyek.github.io/2014/11/15/new/"/>
    <id>http://alexyyek.github.io/2014/11/15/new/</id>
    <published>2014-11-15T06:45:40.000Z</published>
    <updated>2014-11-28T14:44:06.000Z</updated>
    <content type="html"><![CDATA[<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str = str.replaceAll(<span class="string">"[\\pP‘’“”]"</span>, <span class="string">""</span>);</div></pre></td></tr></table></figure>

<p>在这里利用的是Unicode编码，Unicode 编码并不只是为某个字符简单定义了一个编码，而且还将其进行了归类。</p>
<p><a id="more"></a><br>\pP 其中的小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。</p>
<p>大写 P 表示 Unicode 字符集七个字符属性之一：标点字符。其他六个包括：</p>
<ul>
<li>L：字母 </li>
<li>M：标记符号（一般不会单独出现）</li>
<li>Z：分隔符（比如空格、换行等）      </li>
<li>S：符号（比如数学符号、货币符号等）</li>
<li>N：数字（比如阿拉伯数字、罗马数字等）</li>
<li>C：其他字符</li>
</ul>
<p>Java 中用于 Unicode 的正则表达式数据都是由 Unicode 组织提供的。<br>Unicode 正则表达式<a href="http://www.unicode.org/reports/tr18/" target="_blank" rel="external">标准</a>（可以找到所有的子属性）<br>这个<a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt" target="_blank" rel="external">文本文档</a>一行是一个字符，第一列是 Unicode 编码，第二列是字符名，第三列是 Unicode 属性，以及其他一些字符信息。</p>
<h3 id="实例">实例</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">String</span> str = <span class="string">",.!，，D_NAME。！；‘’”“《》**dfs  #$%^&()-+1431221中国123漢字かどうかのjavaを決定"</span>;  </div><div class="line">str = str.replaceAll(<span class="string">"[\\pP‘’“”]"</span>, <span class="string">""</span>);  </div><div class="line">System.out.println(str);</div></pre></td></tr></table></figure>

<p>输出结果: DNAMEdfs  $^+1431221中国123漢字かどうかのjavaを決定</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str = str.replaceAll(<span class="string">"[\\pP‘’“”]"</span>, <span class="string">""</span>);</div></pre></td></tr></table></figure>

<p>在这里利用的是Unicode编码，Unicode 编码并不只是为某个字符简单定义了一个编码，而且还将其进行了归类。</p>
<p>]]>
    
    </summary>
    
      <category term="skill" scheme="http://alexyyek.github.io/tags/skill/"/>
    
      <category term="Java" scheme="http://alexyyek.github.io/categories/Java/"/>
    
  </entry>
  
</feed>
